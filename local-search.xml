<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java SE(8)-泛型</title>
    <link href="/2025/04/12/java8/"/>
    <url>/2025/04/12/java8/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p><strong>泛型</strong>（Generics）是 Java提供的一种机制，<strong>让类、接口、方法在定义时可以指定类型参数</strong>，从而实现类型安全和代码复用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">exer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        HashMap&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        map.put(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//Entry是Map接口的子接口</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry : map.entrySet()) &#123;<br>            System.out.println(entry);<br>        &#125;<br><br>        System.out.println();<br><br>        <span class="hljs-comment">//for增强的简便写法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> entry : map.entrySet()) &#123;<br>            System.out.println(entry.getKey());<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(7)-集合框架</title>
    <link href="/2025/04/10/java7/"/>
    <url>/2025/04/10/java7/</url>
    
    <content type="html"><![CDATA[<h1 id="collection">Collection</h1><p><strong>内存层面</strong>需要针对多个数据进行存储，可以考虑的<strong>容器</strong>有：数组、集合类。</p><p>数组初始化后的长度不可变，存储数据为单一类型，可包含重复元素，不适用于不可重复的场景；可用的属性和方法都极少；不便删除和插入元素。</p><p>Java中的集合框架（Java Collections Framework，简称JCF）是一个统一的架构，用于表示和操作一组对象。</p><p>Java集合框架体系：</p><ul><li><code>java.util.Collection</code>:存储一个一个的数据<ul><li>子接口：<strong>List</strong>，存储<strong>有序</strong>的、<strong>可重复</strong>的数据（动态数组）<ul><li><code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code></li></ul></li><li>子接口：<strong>Set</strong>，存储<strong>无序</strong>的、<strong>不可重复</strong>的数据（类似集合）<ul><li><code>HashSet</code>,<code>LinkedHashSet</code>,<code>TreeSet</code></li></ul></li></ul></li><li><code>java.util.Map</code>:存储一对一对的数据<ul><li><code>HashMap</code>,<code>LinkedHashMap</code>,<code>TreeMap</code>,<code>Hashtable</code>,<code>Properties</code></li></ul></li></ul><h2 id="arraylist">ArrayList</h2><p>创建模板：<code>Collection coll = new ArrayList();</code></p><p>使用<code>xxx.add(Object e)</code>添加对象（向Collection中添加元素的时候要重写equals）。</p><table><thead><tr><th>特性</th><th>ArrayList</th><th>普通数组 (Array[])</th></tr></thead><tbody><tr><td>长度</td><td>动态变化，可自动扩容</td><td>固定长度，创建后不可更改</td></tr><tr><td>添加元素</td><td>使用 <code>add()</code> 方法添加</td><td>需指定索引或使用循环添加</td></tr><tr><td>删除元素</td><td>使用 <code>remove()</code> 方法删除</td><td>不支持直接删除，需要移动元素</td></tr><tr><td>查找元素</td><td>使用 <code>get(index)</code> 获取元素</td><td>使用 <code>array[index]</code> 访问</td></tr><tr><td>是否支持泛型</td><td>支持，例如 <code>ArrayList&lt;Integer&gt;</code></td><td>不支持泛型</td></tr><tr><td>是否支持基本类型</td><td>不支持，只能存对象（可装箱）</td><td>支持基本类型和对象类型</td></tr><tr><td>是否线程安全</td><td>默认<strong>不是</strong>线程安全的</td><td>不是线程安全</td></tr><tr><td>使用场景</td><td>元素数量不确定、操作灵活</td><td>元素数量固定、结构简单</td></tr></tbody></table><h2 id="迭代器">迭代器</h2><p>Iterator,获取迭代器的对象：<code>Iterator itr = 集合.iterator();</code></p><p>遍历集合的所有元素：<code>itr.hasNext()</code>+<code>itr.next()</code></p><figure><img src="https://i.imgur.com/uRaHFI0.png" alt="迭代器图解" /><figcaption aria-hidden="true">迭代器图解</figcaption></figure><h2 id="增强for循环">增强for循环</h2><p><strong>作用</strong>：遍历数组，集合</p><p>集合：底层使用迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (集合或数组的类型 临时变量 : 集合或数组变量) &#123;<br>    操作临时变量的输出;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="list及其实现类的特点">List及其实现类的特点</h2><p>List存储有序的可重复的数据，动态数组，每增加一个对象容量就自动加一。</p><ul><li>ArrayList:List的<strong>主要实现类</strong>，底层使用Object[]数组存储，插入和删除数据时效率低</li><li>LinkedList:底层使用双向链表的方式存储，添加和查找数据时效率较低。适用于对集合中的数据进行频繁的删除和插入操作.</li><li>Vector:古老，不用</li></ul><hr /><p>Collection、List、ArrayList的对比：</p><table><thead><tr><th>特性</th><th>Collection</th><th>List</th><th>ArrayList</th></tr></thead><tbody><tr><td>类型</td><td>接口</td><td>接口（继承自 Collection）</td><td>类（实现了 List 接口）</td></tr><tr><td>是否可实例化</td><td>❌ 不能直接实例化</td><td>❌ 不能直接实例化</td><td>✅ 可以直接实例化</td></tr><tr><td>顺序性</td><td>❌ 不保证顺序（由子接口决定）</td><td>✅ 保证元素顺序</td><td>✅ 保证元素顺序</td></tr><tr><td>是否允许重复</td><td>❓ 由具体实现决定</td><td>✅ 允许重复元素</td><td>✅ 允许重复元素</td></tr><tr><td>随机访问效率</td><td>❌ 无此功能</td><td>✅ 有 <code>get(int)</code> 方法</td><td>✅ 快速随机访问（基于数组）</td></tr><tr><td>常见实现类</td><td>List、Set、Queue 等</td><td>ArrayList、LinkedList 等</td><td>自身是实现类</td></tr><tr><td>典型使用场景</td><td>操作所有集合的通用方法</td><td>操作有序集合（如列表）</td><td>频繁查询、随机访问</td></tr><tr><td>方法示例</td><td><code>add()</code>, <code>remove()</code>, <code>size()</code></td><td>加上 <code>get()</code>, <code>set()</code>,<code>indexOf()</code>等</td><td>同 List，同时还有优化的内部实现</td></tr></tbody></table><h1 id="set">Set</h1><p>存储无序的不可重复的数据。</p><ul><li><code>HashSet</code>:<strong>主要实现类</strong>，底层使用<code>HashMap</code>，即数组+单向链表+红黑树<ul><li><code>LinkedHashSet</code>:<code>HashSet</code>的子类；在现有的结构的基础上又添加了一组双向链表，用于记录添加元素的先后顺序，便于频繁的查询操作。</li></ul></li><li><code>TreeSet</code>:底层使用红黑树存储。可以按照添加元素的指定的属性大小顺序进行遍历。</li></ul><p>常用方法即<code>Collection</code>中常用的方法，无新增方法。</p><ul><li>使用频率：相较于List和Map来说Set使用的频率较小。</li><li>用来过滤重复数据。</li></ul><p><strong>无序性</strong>：添加的元素的<strong>存储顺序</strong>并非依次紧密排列，使用哈希算法。如果想保留添加元素的顺序，就用<code>LinkedHashSet</code>；如果希望自动排序，就用<code>TreeSet</code>。</p><p>添加到HashSet/LinkedHashSet中的元素的要求：元素所在的类要重写两个方法：<code>equal()</code>和<code>hashCode()</code>。比较的标准：哈希值和equals得到的布尔型变量的值。</p><p><code>HashSet</code>用于去重</p><h2 id="treeset">TreeSet</h2><p>底层：红黑树。可以按照指定的大小顺序自动排序。</p><ul><li>要求TreeSet中的元素必须是<strong>同一个类型</strong>，否则类型转换错误。</li><li>处理对象比较方法，排序的标准就是自然排序或定制排序对应方法的返回值。如果是零则认为是相等，不添加新元素。</li><li>不需要重写<code>hashCode()</code>和<code>equals()</code>方法。</li></ul><h1 id="map">Map</h1><h2 id="map及其实现类对比">Map及其实现类对比</h2><p><code>java.util.Map</code>:存储一对一对的<strong>键值对</strong>.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">               ┌──────────────┐<br>               │   Map接口    │<br>               └─────┬────────┘<br>                     │<br>        ┌────────────┴─────────────┐<br>        │                          │<br>  ┌─────▼─────┐              ┌─────▼─────┐<br>  │ HashMap   │              │ SortedMap │（接口）<br>  └─────┬─────┘              └─────┬─────┘<br>        │                          │<br>┌───────▼────────┐           ┌─────▼─────┐<br>│ LinkedHashMap  │           │ TreeMap   │<br>└────────────────┘           └───────────┘<br><br>┌──────────────┐<br>│ Hashtable    │（古老的线程安全实现）<br>└─────┬────────┘<br>      │<br>┌─────▼─────┐<br>│Properties │（子类，专用于配置文件）<br>└───────────┘<br></code></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>HashMap</th><th>LinkedHashMap</th><th>TreeMap</th><th>Hashtable</th><th>Properties</th></tr></thead><tbody><tr><td>所属接口</td><td>Map</td><td>Map</td><td>Map, SortedMap, NavigableMap</td><td>Map</td><td>Hashtable</td></tr><tr><td>是否线程安全</td><td>否</td><td>否</td><td>否</td><td>是</td><td>是</td></tr><tr><td>是否允许 null 键</td><td>是（最多一个）</td><td>是（最多一个）</td><td>否（键不能为 null）</td><td>否</td><td>否</td></tr><tr><td>是否有序</td><td>否</td><td>有插入顺序</td><td>有自然顺序或指定 Comparator</td><td>否</td><td>否</td></tr><tr><td>底层结构</td><td>哈希表</td><td>哈希表 + 双向链表</td><td>红黑树</td><td>哈希表</td><td>哈希表</td></tr><tr><td>性能</td><td>查询快，一般推荐</td><td>查询快，顺序操作性能略低</td><td>查询较慢，适合排序需求</td><td>查询快，但并发性能不佳</td><td>主要用于配置文件加载</td></tr><tr><td>用途</td><td>通用 Map 容器</td><td>保留插入顺序的 Map</td><td>需要排序的 Map</td><td>早期线程安全 Map，已过时</td><td>存储配置信息（key/value 字符串）</td></tr></tbody></table><h2 id="hashmap">HashMap</h2><p><code>HashSet</code>就是基于<code>HashMap</code>实现的。两者的对比如下：</p><table><thead><tr><th>特性</th><th><code>HashSet</code></th><th><code>HashMap</code></th></tr></thead><tbody><tr><td>存储结构</td><td>只存储元素（作为键）</td><td>存储键值对（key-value）</td></tr><tr><td>是否允许重复</td><td>❌ 不允许重复元素</td><td>✅ 键不允许重复，值可以重复</td></tr><tr><td>内部实现</td><td>基于 <code>HashMap</code> 实现</td><td>使用数组+链表（或红黑树）实现</td></tr><tr><td>查找效率</td><td>O(1)</td><td>O(1)</td></tr><tr><td>底层结构</td><td>实际是 <code>HashMap&lt;E, Object&gt;</code></td><td>实际是 <code>HashMap&lt;K, V&gt;</code></td></tr></tbody></table><p><code>HashSet</code>中只存储元素（值），而不是键值对。</p><p>为了实现这一点，它把元素作为<code>HashMap</code>的键，用一个统一的对象（比如<code>PRESENT</code>）作为值。</p><p>所以其实每次你往<code>HashSet</code>添加一个元素时，它是在底层的<code>HashMap</code>中添加了一条键值对：<code>map.put(element, PRESENT);</code></p><hr /><ul><li>HashMap中的key用Set来存放，无序而且不允许重复，所以同一个Map对象所对应的类<strong>需要重写hashCode和equals</strong>。</li><li>HashMap中的Value可重复、无序。<strong>不强制重写任何方法</strong>。</li></ul><blockquote><p>hashCode()：如果两个键的哈希值不同，那么肯定不是相同的键。如果相同，不一定相等，还要靠equals()再判断一次。<br />equals():二次判断</p></blockquote><ul><li>每一个键值对构成一个<strong>entry</strong>，所有的entry构成了一个Set集合</li></ul><p><strong>基本操作</strong>：</p><ul><li>增：put(Object key,Object value) putAll(Map m)</li><li>删：Object remove(Object key)</li><li>改：put(Object key,Object value)返回值为旧数据，覆盖。putAll</li><li>查：Object get(Object key)</li><li>长度：size()</li><li>遍历：Set keySet(),Collection values(),Set entrySet()</li></ul><h2 id="treemap">TreeMap</h2><ul><li>底层使用红黑树，按照<strong>key</strong>指定的大小顺序排序。</li><li>需要考虑使用对象排序</li><li>必须是<strong>同一个类型</strong>的对象</li></ul><h2 id="properties">Properties</h2><ul><li>Hashtable的子类</li><li>键和值都是String类型，用来处理属性文件</li></ul><h1 id="collections工具类">Collections工具类</h1><p><code>Collection</code>是集合框架中的存储一个一个元素的接口，又分为List和Set等子接口。</p><p><code>Collections</code>是一个操作Set,List,Map等集合的工具类。</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>サマータイムレコード じん　歌詞</title>
    <link href="/2025/04/08/summertimerecord/"/>
    <url>/2025/04/08/summertimerecord/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>これぞ夏</p><p>作詞/作曲/編曲/Guitar：じん</p><p>昨日も今日も晴天で<br />入道雲を見ていた</p><p>怠いくらいの快晴だ<br />徐々に目を閉じて</p><p>「それ」はどうも簡単に<br />思い出せやしない様で</p><p>年を取った現状に<br />浸ってたんだよ</p><p>大人ぶった作戦で<br />不思議な合図立てて</p><p>「行こうか、今日も戦争だ」<br />立ち向かって　手を取った</p><p>理不尽なんて当然で<br />一人ぼっち　強いられて</p><p>迷った僕は<br />憂鬱になりそうになってさ</p><p>背高草を分けて<br />滲む太陽睨んで</p><p>君はさ、こう言ったんだ<br />「孤独だから、おいでよ」</p><p>騒がしさがノックして<br />生まれた　感情さえも</p><p>頭に浮かんでは萎んだ</p><p>「幻なのかな？」</p><p>秘密基地に集まって<br />「楽しいね」って単純に</p><p>あの頃を思い出して<br />話をしよう</p><p>飛行機雲飛んで行って<br />「眩しいね」って泣いていた</p><p>君はどんな顔だっけ</p><p>なぜだろう</p><p>思い出せないな</p><hr /><p>痛いくらいに現実は　足早に駆け抜けた</p><p>選んだ今日は平凡で　崩れそうになる日々さ</p><p>昨日も今日も延長戦　大人だって　臆病だ</p><p>今になってなんとなく　気付けたみたいだよ</p><p>廻るセカイのイデア　枯れる太陽　炎天下</p><p>陽炎が揺らいだ　「忘れないで、さぁ、進もう」</p><p>もどかしさ何度でも　明日を夢に見ていた</p><p>戻らない、先のある世界へ　「僕たちで変えよう」 　「思い出して、終わたって　秘密基地も、冒険も」</p><p>あの日に迷い込んだ　話の事も</p><p>一人ぼっちが集まった　子供たちの作戦が　また今日も廻り出した</p><p>「また、何処かで。」</p><p>「涼しいね」って言い合った　夏空は透明だ</p><p>泣かない様に、吸い込んで　「さようなら」しよう</p><p>秘密基地に集まって　笑い合った夏の日に</p><p>「また何処かで思い出して　出逢えるかな」って</p><p>何度でも　描こう</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(6)常用类与基础API</title>
    <link href="/2025/04/08/java6/"/>
    <url>/2025/04/08/java6/</url>
    
    <content type="html"><![CDATA[<h1 id="string">String</h1><p>特性：不可变，创建后不能改变内容，任何修改其实是创建了新对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>String s1 = "hello";</code>使用<strong>字面量</strong>，在常量池里创建一个对象。如果有同样的字面量，会复用，效率更高</p><p><code>String s2 = new String("hello");</code>使用new在堆内存里创建一个对象，</p><p><code>s1==s2</code>判断为<code>false</code>,<code>s1.equals(s2)</code>判断为<code>true</code></p><h2 id="string的连接操作">String的连接操作</h2><p>常量+常量 = 常量池中的常量</p><p>常量+变量 = 堆空间中该字符串对象的地址</p><p><code>intern()</code>返回字符串常量池中对应的地址。</p><p><code>concat()</code>必然返回一个新对象</p><h2 id="常用方法">常用方法</h2><p><code>getBytes()</code>：将字符串转换成字节数组，储存的数字与编码有关，需要指定编码方式使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bytes = str.getBytes(StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure><p>utf-8或gbk都向下兼容ascii。</p><p><strong>解码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, 字符集名称);<br></code></pre></td></tr></table></figure><hr /><p><code>indexOf</code>:查找某个字符或子字符串在字符串中<strong>第一次</strong>出现的位置。没有找到则返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(String s);<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-type">char</span> ch);<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(String s, <span class="hljs-type">int</span> fromIndex);<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-type">char</span> ch, <span class="hljs-type">int</span> fromIndex);<br></code></pre></td></tr></table></figure><p>记录某个字符串在另一个字符串中出现的次数：（复杂度大）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">getSubStringCount</span><span class="hljs-params">(String str,String subStr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(subStr);<span class="hljs-comment">//第一次出现的索引</span><br><br>    <span class="hljs-keyword">while</span>(index != -<span class="hljs-number">1</span>) &#123;<br>        count++;<br>        index = str.indexOf(subStr, index+subStr.length());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="stringstringbufferstringbuilder">String,StringBuffer,StringBuilder</h2><p>String:不可变的字符序列；</p><p>StringBuffer:可变的字符序列；线程安全，效率低</p><p>StringBuilder:可变的字符序列；线程不安全，效率高</p><p>以上三者底层均为byte[].</p><p>增:append</p><p>删:delete(int start, int end)<br />deleteCharAt(int index)</p><p>改:replace(int start, int end, String str) setCharAt(int index, charc)</p><p>查:charAt(inr index)</p><p>插:insert(int index, xx)</p><p>长度:length()</p><h1 id="日期时间api">日期时间API</h1><p>旧API</p><ol type="1"><li>currentTimeMillis():与1970.1.1日0时0分0秒之间的毫秒数</li><li>Date()类</li><li>Calendar抽象类</li></ol><p><strong>新API</strong>：</p><p>最常用的API：</p><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td><code>LocalDate</code></td><td>表示日期（如：2025-04-09），不含时间和时区</td></tr><tr><td><code>LocalTime</code></td><td>表示时间（如：12:30:45），不含日期和时区</td></tr><tr><td><code>LocalDateTime</code></td><td>表示日期和时间（如：2025-04-09T12:30:45），不含时区</td></tr><tr><td><code>ZonedDateTime</code></td><td>表示带时区的日期和时间（如：2025-04-09T12:30:45+09:00[Asia/Tokyo]）</td></tr><tr><td><code>Instant</code></td><td>表示时间戳，精确到纳秒（从1970-01-01T00:00:00Z开始）（重写为ISO-8601标准的字符串）</td></tr><tr><td><code>Duration</code></td><td>表示两个时间之间的间隔（单位：秒、纳秒）</td></tr><tr><td><code>Period</code></td><td>表示两个日期之间的间隔（单位：年、月、日）</td></tr><tr><td><code>DateTimeFormatter</code></td><td>用于格式化和解析日期时间</td></tr></tbody></table><h1 id="对象的排序">对象的排序</h1><h2 id="自然排序实现comparable接口">1.自然排序：实现Comparable接口</h2><ol type="1"><li>定义一个类实现该接口</li><li><strong>实现</strong><code>public int compareTo(T o);</code>方法，指明比较的标准</li><li>创建实例，调用<code>Arrays.sort</code>或<code>compareTo</code>比较大小。</li></ol><p>实现compareTo方法之后，<code>Arrays.sort(arr)</code>的比较标准也会改变。</p><blockquote><p><code>Arrays.sort()</code> 会自动使用元素类中定义的<code>compareTo()</code>方法，所以当你重写了这个方法，排序逻辑自然也随之改变了。</p></blockquote><h2 id="定制排序">2.定制排序</h2><p>适用情况：</p><ul><li>元素类型没有实现Comparable接口，而且不方便修改代码</li><li>实现了接口，但是以后不想用这个比较方法，又不能影响已有的使用</li></ul><ol type="1"><li>创建一个实现Comparator接口的实现类A</li><li>类A要重写compare方法</li><li>创建实现类A的实例，并传入<code>Arrays.sort(arr,类A的实例)</code></li></ol><ul><li>自然排序：单一，一劳永逸，对应的接口是<code>Comparable(Object obj)</code></li><li>定制排序：多样，临时，对应的接口是<code>Comparator</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>もうじき夏が終わるから n-buna &amp;初音ミク　歌詞</title>
    <link href="/2025/04/07/%E3%82%82%E3%81%86%E3%81%98%E3%81%8D%E5%A4%8F%E3%81%8C%E7%B5%82%E3%82%8F%E3%82%8B%E3%81%8B%E3%82%89/"/>
    <url>/2025/04/07/%E3%82%82%E3%81%86%E3%81%98%E3%81%8D%E5%A4%8F%E3%81%8C%E7%B5%82%E3%82%8F%E3%82%8B%E3%81%8B%E3%82%89/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>もうじき夏が終わるから</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><p>朝　小説を読んだ</p><p>君を待っていた</p><p>夜になって気が付いた</p><p>花火の音</p><p>花揺ら歌い今日藍を飛ばせ</p><p>貴方に聞こえないように消えて</p><p>それを言えない僕じゃ言えないよ</p><p>今に夏が終わってくから</p><p><ruby>昼顔<rt>ひるがお</rt></ruby>　鳥居　<ruby>鳳仙花<rt>ほうせんか</rt></ruby>　バス停</p><p>陽の落ちる街を歩いていた</p><p>今日もまた</p><p>朝　ラジオを聞いた君を待っていた</p><p>夜になって気が付いたことを覚えている</p><p>昨日もピアノを弾いた</p><p>朝を待っている</p><p>唄を歌っている</p><p>花詩　誓い　今日藍を飛ばせ</p><p>貴方に聞こえないように叫べ</p><p>夢を見れない僕花咲いた</p><p>終わる夏よ止まってしまえ</p><p>アベリア　始発　終電車　<ruby>緑青<rt>ろくしょう</rt></ruby></p><p>蝉の鳴く街を歩いていた</p><p>今日もまた</p><p>朝、今日も駅の裏</p><p>人が立っていた</p><p>夜の藍に花が咲く</p><p>絵をえがいていた</p><p>帰ってピアノを弾いた</p><p>夜になっていた</p><p>君を待っていた</p><p>花詩　誓い　明日藍を飛ばせ</p><p>貴方が居たくない今日を叫べ</p><p>夢が言えないことに気がついた</p><p>浅い夏よ　終わってくれよ</p><p><ruby>昼顔<rt>ひるがお</rt></ruby>　鳥居　<ruby>鳳仙花<rt>ほうせんか</rt></ruby>　バス停</p><p>夜が明けた街を歩いていた</p><p>今日もまた</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(5)异常处理&amp;多线程</title>
    <link href="/2025/04/06/java5/"/>
    <url>/2025/04/06/java5/</url>
    
    <content type="html"><![CDATA[<h1 id="异常">异常</h1><p>指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止。</p><p>一旦发生某种异常Java就创建该异常类型的对象，并且抛出(throw)。</p><p><strong>Error</strong>:java虚拟机无法处理的严重问题，一般不编写针对性的代码。例如：栈内存溢出，堆内存溢出。</p><p><strong>Exception</strong>:异常处理的情况，需要针对性的代码进行处理。</p><ul><li>编译时异常</li><li>运行时异常</li></ul><p>常见的运行时异常：角标越界异常 空指针异常 类别异常 输入类型不匹配异常数字格式化异常</p><p>编译时异常：<code>ClassNotFoundException</code><code>FileNotFoundException</code> <code>IOException</code></p><h2 id="处理异常的方式">处理异常的方式</h2><h3 id="try-catch-finally">1.try-catch-finally</h3><ol type="1"><li>程序在执行的过程中，一旦出现异常，就创建该异常类的对象并抛出，然后虚拟机就终止程序。</li><li>捕获异常对象，进行相应的处理，处理后可以继续执行代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能会抛出异常的代码</span><br>    <span class="hljs-comment">//try中声明的变量作用域只在try内部</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType1 e1) &#123;<br>    <span class="hljs-comment">// 异常类型1的处理代码</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType2 e2) &#123;<br>    <span class="hljs-comment">// 异常类型2的处理代码</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 可选的代码，无论是否发生异常都会执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>catch</code>中异常处理的方式：</p><ol type="1"><li>自己编写输出语句</li><li><code>printStackTrace()</code>打印异常的详细信息（推荐）</li><li><code>getMessage()</code>获取发生异常的原因</li></ol><ul><li>运行时异常：开发时通常不进行显式的处理</li><li>编译时异常：<strong>必须</strong>进行处理，否则编译不通过</li></ul><p><code>fianlly</code>：无论try或catch中是否存在仍未被处理的异常，finally中的语句都一定会被运行。</p><p>在开发中有一些资源使用之后必须显式地进行关闭，.close放在finally中。</p><h3 id="throws">2.throws</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExceptionType1, ExceptionType2 &#123;<br>    <span class="hljs-comment">// 可能抛出异常的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该方法本身不会处理这些异常，交给调用这个方法的代码去处理。</p><p>对于编译时异常，子类重写的方法抛出的异常类型不能比父类被重写的方法抛出的异常更高级。如果父类没抛异常，则子类也不能抛。</p><ul><li>如果代码重涉及到了资源的调用，则必须考虑使用try-catch-finally来处理，保证不出现内存泄漏。</li><li>如果父类被重写的方法没有throws，则子类只能使用try-catch-finally</li></ul><h3 id="throw">3.throw</h3><p>对于不满足实际场景，但不符合系统规定的异常的问题，手动抛出对象。</p><p>语法： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionType</span>(<span class="hljs-string">&quot;错误信息&quot;</span>);<br></code></pre></td></tr></table></figure></p><p>其中<code>ExceptionType</code>可以是系统自带的标准异常类，也可以是自定义的异常类。</p><p><strong>throw和throws的区别</strong>：</p><table><thead><tr><th><strong>功能</strong></th><th><strong><code>throw</code></strong></th><th><strong><code>throws</code></strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>用于手动抛出异常。</td><td>用于声明一个方法可能抛出的异常。</td></tr><tr><td><strong>使用位置</strong></td><td>用于方法内部。</td><td>用于方法声明中，表示该方法可能会抛出异常。</td></tr><tr><td><strong>后面跟的内容</strong></td><td>后面跟一个异常对象（如 <code>new Exception()</code>）。</td><td>后面跟异常类型（如<code>IOException</code>、<code>FileNotFoundException</code>）。</td></tr><tr><td><strong>是否需要处理异常</strong></td><td>抛出的异常必须由调用该方法的代码来处理。</td><td>调用方法的代码必须处理或声明这些异常。</td></tr></tbody></table><h1 id="多线程">多线程</h1><h2 id="程序进程与线程">程序、进程与线程</h2><p>程序(program) 进程(process) 线程(thread)</p><ul><li><strong>程序</strong>：我们写的代码/应用都属于程序，是一个静态的东西，包含了要执行的指令，只有在运行时才会发挥作用，相当于菜谱。</li><li><strong>进程</strong>：运行程序时操作系统会为程序分配资源，这时程序就变成了一个进程。进程是操作系统在执行过程中的“活跃”表现，相当于看着菜谱做菜的厨师。</li><li><strong>线程</strong>：进程中的最小执行单元，负责执行具体的命令。一个进程可以有多个线程，共享进程的资源比如内存。多线程可以让程序同时执行多个任务。</li></ul><h2 id="创建和启动线程">创建和启动线程</h2><h3 id="方式一继承thread类">方式一：继承Thread类</h3><ol type="1"><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run()，补充方法体</li><li>创建子类的对象</li><li>调用start():1.启动线程 2.调用当前线程的run()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintNumber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：不能让已经启动的线程再次启动，否则报异常<code>Exception in thread "main" java.lang.IllegalThreadStateException</code></p><p>要开启另一个线程需要重新创建一个对象。</p><h3 id="方式二实现runnable接口">方式二：实现Runnable接口</h3><p><em>Runnable.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Runs this operation.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>创建一个实现Runnable接口的类</li><li>实现run()，补全操作</li><li>创建对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread实例</li><li>实例调用start()</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NumberPrint</span> <span class="hljs-variable">numberPrint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberPrint</span>();<span class="hljs-comment">//创建类的实现对象</span><br>        <span class="hljs-comment">/*Thread的其中一个构造函数接受一个Runnable接口类型的参数，而NumberPrint类实现了这个接口，因此可以直接传入。</span><br><span class="hljs-comment">        * */</span><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(numberPrint);<br>        thread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberPrint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>④之所以成立，是因为Thread类有如下构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, task, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>形参为接口<code>Runnable</code>类型。<code>Runnable</code>是<code>Thread</code>类可以接受的类型，而<code>numberPrint</code>实现了<code>Runnable</code>接口，因此<code>Thread</code>类可以接受<code>numberPrint</code>类型的对象。</p><p><code>Thread</code>类并不关心具体传入的是哪一个实现<code>Runnable</code>接口的类，<code>numberPrint</code>只是其中的一个实现。</p><p><strong>多态性</strong>体现在，<code>Thread</code>类能够接受任何实现了<code>Runnable</code>接口的对象，实际执行的是实现类中的<code>run()</code>方法。</p><h2 id="thread的常用方法">Thread的常用方法</h2><ul><li><code>start()</code>:启动线程，调用线程的run()</li><li><code>run()</code>:将线程要执行的操作声明在run()中</li><li><code>currentThread()</code>:获取当前执行代码对应的线程</li><li><code>getName()</code>:获取线程名</li><li><code>setName()</code>:设置线程名</li><li><code>sleep(long millis)</code>:Thread类的<strong>静态</strong>方法，使当前线程睡眠指定的毫秒数</li><li><code>yield()</code>:一旦执行此方法，则提示当前线程让出CPU资源，让其他同优先级的线程有机会先执行（它只是一个<strong>提示</strong>，<strong>不能保证</strong>当前线程就一定会被挂起或其他线程就一定会立即执行）。调用该方法的线程会：<ul><li>实际开发中，yield()<strong>很少用</strong>来做线程调度控制，因为它行为不确定。</li></ul></li><li><code>join()</code>:<strong>非静态</strong>方法，等指定线程执行完毕，再继续执行当前线程。一般用于main等子线程执行完，而不会用于main，因为main的结束通常就意味着整个程序的结束。</li><li><code>isAlive()</code>:判断当前线程是否存活。</li></ul><h2 id="线程的优先级">线程的优先级</h2><p>线程优先级（Thread Priority）是 Java中用于提示操作系统调度器：哪个线程应该“更重要”，<strong>更可能获得 CPU时间片先运行的</strong>一种机制。</p><p><strong>线程优先级是建议，不是命令！</strong>操作系统可以参考，也可以无视它。</p><ul><li>getPriority():获取线程的优先级</li><li>setPriority():1~10</li><li>优先级的三个常量：<ul><li>MIN_PRIORITY = 1;最低优先级</li><li>NORM_PRIORITY = 5;默认优先级</li><li>MAX_PRIORITY = 10;最高优先级</li></ul></li><li>实际项目中很少用，一般由操作系统决定线程调度。</li></ul><h2 id="线程的生命周期">线程的生命周期</h2><p>现成的不同状态被定义在<code>Thread.java</code>的枚举类中。这些状态是Java虚拟机层面定义的状态，不一定等同于操作系统的线程状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br><br>    NEW,<br><br>    RUNNABLE,<span class="hljs-comment">//就绪+运行,Ready+Running=Runnable</span><br><br>    BLOCKED,<span class="hljs-comment">//阻塞，A thread that is blocked waiting for a monitor lock is in this state.</span><br><br>    WAITING,<span class="hljs-comment">//无限期等待</span><br><br>    TIMED_WAITING,<span class="hljs-comment">//限时等待</span><br><br>    TERMINATED;<span class="hljs-comment">//终止</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="https://i.imgur.com/eTf0YbI.png" alt="线程状态图解" /><figcaption aria-hidden="true">线程状态图解</figcaption></figure><h2 id="线程的安全问题">线程的安全问题</h2><p>多个线程访问同一资源时，如果都对资源有读和写的操作，可能会出现线程安全问题。</p><h3 id="解决方法">解决方法</h3><ol type="1"><li><strong>同步代码块</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步监视器)&#123;<br>    <span class="hljs-comment">//需要被同步的代码，即操作共享数据的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>作用：需要被同步的代码，当一个线程在操作这些代码的过程中其他线程必须等待。</li><li>同步监视器，俗称锁(Lock)。哪个线程获取了锁，哪个线程就能执行需要被同步的代码。</li><li>同步监视器可以使用任何一个类的实例充当。多个线程必须共用<strong>同一个</strong>同步监视器，是唯一的。</li></ul><ol start="2" type="1"><li><strong>同步方法</strong></li></ol><p>直接把方法声明为同步方法。相当于同步代码块的简化写法。</p><ul><li><code>synchronized</code>（实例方法）的同步监视器是this当前对象</li><li><code>static synchronized</code>（静态方法）的同步监视器是当前类的class对象</li></ul><p>synchronized弊端：串行执行，性能会低一些。</p><h3 id="线程安全的懒汉式">线程安全的懒汉式</h3><p>方式一：声明为同步方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Bank</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Bank <span class="hljs-title function_">getBank</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/*相当于</span><br><span class="hljs-comment">        synchronized (Bank.class) &#123;</span><br><span class="hljs-comment">            if(bank == null) &#123;</span><br><span class="hljs-comment">                bank = new Bank();</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(bank == <span class="hljs-literal">null</span>) &#123;<br>            bank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bank</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> bank;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方式二：同步代码块，与方式一等价。</p><p>方式三：避免指令重排的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 加 volatile 防止指令重排</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Bank</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title function_">getBank</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (bank == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 第一次检查</span><br>            <span class="hljs-keyword">synchronized</span> (Bank.class) &#123;<br>                <span class="hljs-keyword">if</span> (bank == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 第二次检查</span><br>                    bank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bank</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bank;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="死锁">死锁</h2><p>两个或多个线程在执行过程中，互相等待对方释放资源，结果谁也不释放，谁也无法继续执行，程序就“卡住”了。## Lock</p><p><code>import java.util.concurrent.locks.ReentrantLock;</code></p><ol type="1"><li>创建Lock的实例，确保多个线程共用一个lock实例:<code>private final Lock mylock = new ReentrantLock();</code></li><li>执行lock方法：<code>mylock.lock</code></li><li>调用unlock()，释放对共享数据的锁定。</li></ol><p>Lock更加灵活，推荐。</p><h2 id="线程间的通信机制">线程间的通信机制</h2><p>常用方法：</p><ul><li>wait():执行此方法的线程进入等待状态，<strong>同时会释放对同步监视器的调用</strong>，这一点与sleep()不同。“不干了，等通知”</li><li>notify():用来<strong>唤醒一个正在等待这个对象锁的线程</strong>。这个线程必须是因为<code>wait()</code>暂停的，别的不会受影响（在多个线程存在的情况下，唤醒优先级最高的那一个）。“<em>你可以起来干了</em>”。被唤醒的线程从当初被wait的位置继续执行。</li><li><strong>注意</strong>:wait()和notify()在调用时都应当让同步监视器(synchronized(obj)的obj)调用，否则报<code>IllegalMonitorStateException</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(obj) &#123;<br>    obj.wait();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>notifyAll():唤醒所有被wait的线程</li></ul><p>以上三个方法<strong>必须</strong>用于<strong>同步代码块或同步方法</strong>中。</p><p>不同点： - 声明的位置: - wait():声明在Object类中 -sleep()：声明在Thread类中，静态的</p><ul><li>使用的场景不同：<ul><li>wait()：只能使用在同步代码块或同步方法中</li><li>sleep():可以在任何需要使用的场景</li></ul></li><li>使用在同步代码块或同步方法中：<ul><li>wait()：一旦执行，会释放同步监视器</li><li>sleep()：一旦执行，不会释放同步监视器</li></ul></li><li>结束阻塞的方式：<ul><li>wait()：到达指定时间自动结束阻塞 或 通过被notify唤醒，结束阻塞</li><li>sleep():到达指定时间自动结束阻塞</li></ul></li></ul><h1 id="线程池">线程池</h1><p>提前创建好多个线程，放入线程池中，使用时直接获取。不在java基础的范围之内</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(4) 面向对象-高级</title>
    <link href="/2025/04/01/java4/"/>
    <url>/2025/04/01/java4/</url>
    
    <content type="html"><![CDATA[<h1 id="关键字static">关键字static</h1><p><strong>作用</strong>：使得类的某一个成员变量被这个类的所有实例所共享（类变量、静态变量），使得我们不需要创建对象就可以调用某个方法（类方法）。</p><p>静态变量：</p><ul><li>在内存空间中只有一份，被类的多个变量共享。</li><li>在JDK8之前，静态变量存储在方法区(MethodArea)；JDK8及以后，由于永久代(PermGen)被移除，静态变量存储在元空间(Metaspace)。</li><li>在类加载时就被初始化，分配内存，只加载一次，整个程序运行期间一直存在，直到类被卸载。</li></ul><table><thead><tr><th>类别</th><th>存储位置</th><th>生命周期</th><th>归属</th></tr></thead><tbody><tr><td>静态变量（static 变量）</td><td>方法区（JDK 8+ 为元空间）</td><td>类加载时分配，类卸载时释放</td><td>属于类，所有对象共享</td></tr><tr><td>实例变量</td><td>堆（Heap）</td><td>对象创建时分配，垃圾回收时释放</td><td>属于对象，每个对象都有独立副本</td></tr><tr><td>局部变量</td><td>栈（Stack）</td><td>方法执行时分配，方法结束后释放</td><td>属于方法，只能在当前方法中访问</td></tr></tbody></table><p>类方法：</p><ul><li>随着类的加载而加载</li><li>静态方法内可以调用静态的属性或静态的方法，不可以调用非静态的结构。</li><li><code>static</code>修饰的方法内不能使用<code>this</code>和<code>super</code>，因为<code>static</code>是属于<strong>类</strong>的，而<code>this</code>和<code>super</code>代表的是当前对象和当前对象的父类部分，他们都需要依赖于<strong>对象</strong>。同理，就算对象是一个空指针，也能正常调用静态的属性和方法，因为<code>static</code>不依赖于对象。</li></ul><p>什么时候需要<code>static</code>？</p><ul><li>当前的多个实例需要共享此成员变量</li><li>一些常量，比如PI</li></ul><p>什么时候要用静态方法？</p><ul><li>方法内要操作的变量都是静态变量时</li><li>工具类中的方法，比如<code>Arrays</code>，<code>Math</code>类</li></ul><h1 id="单例设计模式">单例设计模式</h1><p>单例(Singleton)设计模式，即每个类只能存在一个实例（即只能通过特定方法获取实例，不可随意创建），并提供一个全局访问点来获取该实例。</p><h2 id="饿汉式eager">饿汉式(Eager)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 提前创建实例</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// 私有构造器，防止外部创建实例</span><br><br>    <span class="hljs-comment">//使用getter方法获取当前实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>线程安全，在类加载时就创建实例，但是占用了一定内存，生命周期过长。</li><li>适用于实例创建开销小且使用频繁的场景。</li></ul><h2 id="懒汉式lazy">懒汉式(Lazy)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// 私有构造器，防止外部创建实例</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 只有在需要时才创建</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>延迟加载，在需要使用的时候再创建</li><li>线程不安全，如果多个线程同时调用<code>getInstance()</code>，可能会创建多个实例。</li></ul><h1 id="类的成员代码块">类的成员：代码块</h1><p>Java的代码块可以分为<strong>普通代码块、构造代码块、静态代码块、同步代码块</strong>。</p><table><thead><tr><th>代码块类型</th><th>关键字</th><th>触发时机</th><th>执行次数</th><th>作用</th></tr></thead><tbody><tr><td>普通代码块</td><td><code>&#123;&#125;</code></td><td>代码运行到该块时</td><td>多次</td><td>限定变量作用域，提高可读性</td></tr><tr><td>构造代码块</td><td><code>&#123;&#125;</code>（类中，不在方法内）</td><td>每次创建对象时</td><td>每次创建对象时执行</td><td>初始化对象公共属性，避免构造方法重复代码</td></tr><tr><td>静态代码块</td><td><code>static &#123;&#125;</code></td><td>类加载时</td><td>只执行一次</td><td>初始化静态变量，执行类级别的初始化</td></tr><tr><td>同步代码块</td><td><code>synchronized &#123;&#125;</code></td><td>代码执行时</td><td>多次</td><td>线程同步，保证线程安全</td></tr></tbody></table><p>普通代码块也可以放在类内方法外，这时用于初始化属性。执行顺序是静态代码块-普通代码块-构造器-其余方法。</p><p>代码块的加载顺序<strong>先于</strong>构造器，功能大差不差，初始化的操作在构造器里也可以实现。</p><h1 id="类的属性赋值">类的属性赋值</h1><p><img src="https://i.imgur.com/0g6owHM.png" /></p><h1 id="关键字final">关键字final</h1><p><code>final</code>可用来修饰类、方法、变量。</p><ol type="1"><li><code>final</code>修饰类；表示此类不能被继承。例如：<code>String</code><code>StringBuilder</code></li><li><code>final</code>修饰方法：表示此方法不能被重写。例如：<code>getClass()</code></li><li><code>final</code>修饰变量：成员变量或局部变量。此时变量其实就变成了常量，一旦赋值就不可更改。</li></ol><p><code>final</code>修饰成员变量可以显式赋值、构造器赋值、代码块赋值。</p><p><code>final</code>修饰局部变量：一旦赋值就不可更改。形参/方法内的局部变量。</p><p><code>final</code>与<code>static</code>搭配：成员变量称之为<strong>全局常量</strong>，例如<code>Math.PI</code></p><h1 id="abstract-class">Abstract Class</h1><p>抽象类是 Java中的一种特殊类，<strong>不能被实例化</strong>，通常用作<strong>基类</strong>，用于定义通用的行为和结构。它可以包含<strong>抽象方法</strong>（没有方法体的方法）和<strong>具体方法</strong>（有方法体的方法）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法（无方法体）</span><br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 具体方法（有方法体）</span><br>        System.out.println(<span class="hljs-string">&quot;Sleeping...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用<code>abstract</code>关键字。</li><li>抽象类其实是包含构造器的，因为子类对象实例化时，需要调用父类的构造器。</li><li>抽象类中可以没有抽象方法。</li><li>子类必须重写抽象类中的所有抽象方法之后才能实例化，否则子类仍然是抽象类。</li></ul><p><strong>使用场景</strong>：</p><ul><li>定义统一的接口，让不同的子类提供具体的实现。抽象类中只提供通用的逻辑，至于扩展特定的功能则交给子类的重写(Implement)。</li></ul><h1 id="接口">接口</h1><h2 id="概述">概述</h2><p>接口(interface)的本质是一组方法的规范。关键字：<code>interface</code>，</p><p>接口内部的说明：</p><ul><li>属性：不能包含实例变量，但可以有用<code>public static final</code>修饰（默认自带）。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">MAX_AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <span class="hljs-comment">// 等价于 public static final int MAX_AGE = 100;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法：声明抽象方法，修饰为<code>public abstract</code>（可以省略，默认自带）。</li><li><strong>不能有构造器</strong>（接口<strong>不能被实例化</strong>）。</li></ul><p><strong>接口与类的关系</strong>：使用<code>implements</code>关键字让一个类实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is eating...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is sleeping...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>规则</strong>：</p><ol type="1"><li>类必须实现接口中的<strong>所有</strong>方法，否则必须将类定义为<code>abstract</code>。</li><li>一个类可以实现<strong>多个接口</strong>（不像继承，Java只能单继承）。</li><li>类可以同时继承和实现：<code>class A extends SuperA implements B,C&#123;&#125;</code></li></ol><p>接口与接口可以多继承，类只能单继承。</p><h2 id="接口的多态性">接口的多态性</h2><p><code>接口名 变量名 = new 实现类</code> 非常常用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<span class="hljs-comment">//多态</span><br>        a.eat();<br>        a.sleep();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>区分抽象类和接口</strong>：</p><ul><li>共性：都可以声明抽象方法，都不能实例化</li><li>不同：抽象类一定有构造器，接口没有构造器；</li></ul><p>接口中声明的静态方法（java8引入）只能被接口调用，不能被其实现类调用。</p><p>从java8开始，接口可以有<code>default</code>方法，允许提供默认实现。默认方法可以被实现类继承，可以被实现类重写，不过在多实现时要注意重名问题（接口冲突），接口冲突时必须重写该方法。</p><p>java9允许接口定义<strong>私有方法</strong>，只在内部使用。</p><h1 id="类的成员内部类">类的成员：内部类</h1><h2 id="概述-1">概述</h2><p><strong>内部类(innerClass)</strong>：某个类A的内部还有一个部分需要一个完整的结构B来描述，B只为A服务，不在其他地方使用。A称为外部类，B称为内部类。</p><p>举例：<code>Thread</code>类内部的<code>State</code>类，表示线程的生命周期。</p><h2 id="分类">分类</h2><h3 id="成员内部类member-inner-class">1.成员内部类(Member InnerClass)</h3><ul><li>直接声明在外部类的里面，和成员变量一个位置。<ul><li>使用static修饰的：静态成员内部类</li><li>不使用static修饰的：非静态的成员内部类</li></ul></li><li>从类的角度看：<ul><li>内部可以声明类应有的结构</li><li>此内部类可以声明父类，实现接口</li><li>可以使用final修饰</li><li>也可以使用abstract</li></ul></li><li>从外部类的成员的角度：<ul><li>内部可以调用外部的结构</li><li>可以使用4种权限修饰符</li><li>可以使用static</li></ul></li></ul><h3 id="局部内部类local-inner-class">2.局部内部类(Local InnerClass)</h3><ul><li>声明在方法内部内、构造器内或代码块内的内部类<ul><li>匿名的成员内部类</li><li>非匿名的成员内部类</li></ul></li></ul><p><mark>匿名内部类的创建</mark></p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()&#123;<span class="hljs-comment">//创建一个继承于Object的匿名子类</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>            &#125;<br>        &#125;.test();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码可以无错误无警告地运行。</p><h1 id="枚举类">枚举类</h1><h2 id="概述-2">概述</h2><p>枚举属于<strong>引用数据类型</strong>，关键词：<code>enum</code>，枚举里面定义的是已经生成且固定下来的对象，实际上枚举中的每一个枚举值都是一个<code>public static final</code>实例。</p><blockquote><p>当我们使用“enum”定义枚举类型时，实质上我们定义出来的类型继承自java.lang.Enum类型，而枚举的成员其实就是我们定义的枚举类型的一个实例（Instance），他们都被预设为final，所以我们无法改变他们，他们也是static成员，所以我们可以通过类型名称直接使用他们，当然最重要的，他们都是公开的（public）。</p></blockquote><h2 id="enum的比较">enum的比较</h2><p>一般来说引用数据类型的中比较要使用<code>.equals()</code>，但是<code>enum</code>类型是例外，也可以使用<code>==</code>，这是因为每个枚举类型的常量在JVM中只有唯一的一个实例，所以两种比较方法都完全正确。</p><h2 id="enum类型">enum类型</h2><p><code>enum</code>定义的类型与一般的<code>class</code>没有任何区别，<code>enum</code>就是<code>class</code>。有以下特点：</p><ul><li><code>enum</code>继承自<code>java.lang.Enum</code>，<strong>不可以显式地定义其父类</strong>，而且无法被继承；</li><li>无法使用<code>new</code>创建新的枚举，因为枚举类型在编译时就已经固定下来。</li></ul><p>使用<code>enum</code>关键词创建的枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED, GREEN, BLUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>与下面这种写法基本等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span> &#123; <span class="hljs-comment">// 继承自Enum，标记为final class</span><br>    <span class="hljs-comment">// 每个实例均为全局唯一:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Color</span> <span class="hljs-variable">RED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Color</span> <span class="hljs-variable">GREEN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Color</span> <span class="hljs-variable">BLUE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();<br>    <span class="hljs-comment">// private构造方法，确保外部无法调用new操作符:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Color</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然每一个枚举的值都是<code>enum</code>类的一个实例。既然是实例，就应当可以调用方法；实际上<code>Enum.java</code>中已经提供了一些用于枚举值的方法。</p><h2 id="enum的常用方法">enum的常用方法</h2><p><code>name()</code>:返回常量名，定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ordinal()</code>:返回定义的常量的定义的顺序（整型），从0开始计数。</p><p><code>values()</code>:数组变量，储存枚举类所有对象的信息。</p><h2 id="枚举类实现接口的操作">枚举类实现接口的操作</h2><ol type="1"><li>枚举类实现接口，在枚举类中实现所需方法，通过枚举类的对象调用的是<strong>同一个</strong>方法（与普通类一样）</li><li>让每一个枚举类的对象<strong>分别</strong>重写方法，匿名的内部类。</li></ol><h1 id="注解annotation">注解(Annotation)</h1><p>常见的Java内置注解：</p><p><code>@override</code>用于检查重写方法是否写对。</p><p><code>@Deprecated</code>表示某个类或方法已经<strong>不推荐使用</strong>，调用时会有警告提示。调用被它标记的类或方法时会出现删除线。</p><p><code>@SuppressWarnings</code>告诉编译器<strong>忽略特定类型的警告</strong>。</p><p>框架 = 注解 + 反射 + 设计模式</p><p>元注解：注解的注解</p><h1 id="包装类">包装类</h1><p>包装类是为每种基本数据类型提供的一个形式封装，让基本数据类型可以像引用数据类型一样使用。</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr></tbody></table><p>包装类和对应的基本数据类型的内存地址也不一样：</p><p><img src="https://i.imgur.com/DIlCOZj.png" /></p><p><code>xxx.valueOf(...)</code><strong>手动</strong>将基本数据类型转化为引用数据类型，返回一个引用数据类型的新实例。</p><ul><li><p>已经创建的包装类的值可以修改吗？<strong>不可以</strong>，例如<code>Interger</code>是不可变对象，一旦被创建，值不可修改。</p></li><li><p><strong>装箱</strong>：Boxing，将一个基本数据类型转换为对应的包装类对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.valueOf(a);  <span class="hljs-comment">// 手动装箱</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>自动装箱</strong>：Autoboxing，Java5引入，直接把基本类型赋给包装类变量，Java编译器会自动帮你调用装箱的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;  <span class="hljs-comment">// 自动装箱：相当于 Integer.valueOf(a)</span><br></code></pre></td></tr></table></figure></p></li></ul><h1 id="string数据类型转换">String数据类型转换</h1><h2 id="基本数据类型包装类string">基本数据类型、包装类——&gt;String</h2><ol type="1"><li>直接调用<code>String xxx = String.valueOf(...);</code></li><li>也可以<code>String = xxx + "";</code></li></ol><h2 id="string基本数据类型包装类">String——&gt;基本数据类型、包装类</h2><p>调用包装类的静态方法<code>pasrsexxx</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br></code></pre></td></tr></table></figure><h1 id="常量池机制">常量池机制</h1><p>例如：自动装箱使用的<code>valueOf()</code>方法有缓存机制，<code>Integer</code>缓存-128~127，超出这个范围才会新建对象。</p><p>Java 中的“常量池(ConstantPool)”是一种<strong>优化内存使用和执行效率的机制</strong>。它的本质是一个用于存放常量（字面量、符号引用等）的特殊内存区域，目的是为了重用相同的值，避免重复创建对象。</p><h1 id="idea常用快捷键">IDEA常用快捷键</h1><table><thead><tr><th>功能说明</th><th>快捷键</th></tr></thead><tbody><tr><td>智能提示 - <em>edit</em></td><td><code>Alt + Enter</code></td></tr><tr><td>提示代码模板 - <em>insert live template</em></td><td><code>Ctrl + J</code></td></tr><tr><td>使用 xx 块环绕 - <em>surround with...</em></td><td><code>Ctrl + Alt + T</code></td></tr><tr><td>调出生成 getter/setter/构造器等结构</td><td><code>Alt + Insert</code></td></tr><tr><td>自动生成返回值变量 - <em>introduce variable</em></td><td><code>Ctrl + Alt + V</code></td></tr><tr><td>复制指定行的代码 - <em>duplicate line</em></td><td><code>Ctrl + D</code></td></tr><tr><td>删除指定行的代码 - <em>delete line</em></td><td><code>Ctrl + Y</code></td></tr><tr><td>切换到下一行代码空位 - <em>start new line</em></td><td><code>Shift + Enter</code></td></tr><tr><td>切换到上一行代码空位 - <em>start new line before current</em></td><td><code>Ctrl + Alt + Enter</code></td></tr><tr><td>向上移动代码 - <em>move statement up</em></td><td><code>Ctrl + Shift + ↑</code></td></tr><tr><td>向下移动代码 - <em>move statement down</em></td><td><code>Ctrl + Shift + ↓</code></td></tr><tr><td>向上移动行 - <em>move line up</em></td><td><code>Alt + Shift + ↑</code></td></tr><tr><td>向下移动行 - <em>move line down</em></td><td><code>Alt + Shift + ↓</code></td></tr><tr><td>查看方法参数提示 - <em>parameter info</em></td><td><code>Ctrl + P</code></td></tr><tr><td>重写父类的方法</td><td><code>Ctrl + O</code></td></tr><tr><td>实现接口的方法</td><td><code>Ctrl + I</code></td></tr><tr><td>查看继承树</td><td><code>Ctrl + H</code></td></tr><tr><td>类的UML关系图</td><td><code>Ctrl + Alt + U</code></td></tr><tr><td>定位某行、列</td><td><code>Ctrl + G</code></td></tr><tr><td>搜索</td><td><code>Ctrl + F</code></td></tr><tr><td>查找替换</td><td><code>Ctrl + R</code></td></tr><tr><td>全项目搜索文本</td><td><code>Ctrl + Shift + F</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(3) 面向对象-中级</title>
    <link href="/2025/03/30/java3/"/>
    <url>/2025/03/30/java3/</url>
    
    <content type="html"><![CDATA[<h1 id="this关键词">this关键词</h1><p>用<code>this</code>关键词可用来避免形参名和属性名<strong>重名</strong>的问题。简单来说，<strong>哪个对象调用，<code>this</code>就指向这个对象</strong>。</p><p><code>this</code>还可以用来<strong>调用构造器</strong>（即构造方法重载）：</p><ul><li>必须是构造方法的<strong>第一行</strong></li><li>在一个构造器中最多声明一个<code>this(形参列表)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">This</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">This</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-string">&quot;Unknown&quot;</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//此处this调用了This()构造器</span><br>        <span class="hljs-comment">//等价于：this.name = &quot;Unknown&quot;;this.age=0;</span><br>        System.out.println(<span class="hljs-string">&quot;This is the default constructor&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//以下为this调用属性：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">This</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name: &quot;</span> + name + <span class="hljs-string">&quot;, age: &quot;</span> + age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Getter</code>和<code>Setter</code>方法的快速调用：<code>alt + Insert</code>。</p><h1 id="面向对象的继承性">面向对象的继承性</h1><p>继承(inheritance)，关键词：<code>extends</code>，子类(subclass)继承父类(superclass)的属性和方法。</p><h2 id="优势">优势</h2><ol type="1"><li>减少代码冗余，提高代码的复用性</li><li>更利于功能的扩展</li><li>为多态的使用创造了前提</li><li>描述事物之间的所属关系，父类更为通用</li><li>继承不影响父类的封装性</li></ol><h2 id="语法">语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br> <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Java中声明的类，如果没有显式的声明其父类，则默认继承于<code>java.lang.object</code></li><li>Java只支持单继承，不支持多继承，一个子类只能有一个父类</li></ul><h2 id="protected-权限修饰符">protected 权限修饰符</h2><p>声明为 protected 的成员可以被以下范围访问：</p><ol type="1"><li>同一个类 ✅（当然可以访问）</li><li>同一个包中的其他类 ✅（包内可以访问）</li><li>子类（无论是否在同一个包） ✅（继承后可以访问）</li><li>不同包中的非子类 ❌（不能访问）</li></ol><p>应用场景：</p><ul><li>用于子类的继承，子类可以访问<code>protected</code>的方法和变量。</li></ul><h1 id="方法的重写">方法的重写</h1><p>方法重写(override)指的是子类对从父类继承的方法进行重新实现，提供不同的功能。</p><ul><li>必须发生在父类和子类之间</li><li>方法名和参数列表必须相同</li><li>子类的访问权限不能比父类更严格，不能重写<code>private</code>方法</li><li>只能重写非static方法，static方法不能被重写</li><li>可使用<code>@Override</code>注解</li><li>关于返回值类型：<br />父类void，则重写必须void;<br />父类基本数据类型，则子类重写必须相同数据类型；<br />父类引用数据类型，则子类的返回值数据类型可以相同或是其子类</li></ul><p>区分方法的重载与重写：</p><table><thead><tr><th>特性</th><th>方法重写（Override）</th><th>方法重载（Overload）</th></tr></thead><tbody><tr><td><strong>发生范围</strong></td><td>子类和父类</td><td>同一个类</td></tr><tr><td><strong>方法名</strong></td><td>必须相同</td><td>必须相同</td></tr><tr><td><strong>参数列表</strong></td><td>必须相同</td><td>必须不同（参数个数或类型不同）</td></tr><tr><td><strong>返回值类型</strong></td><td>必须兼容（可以是协变返回类型）</td><td>可以不同</td></tr><tr><td><strong>访问修饰符</strong></td><td>不能比父类更严格</td><td>没有限制</td></tr><tr><td><strong>关键字</strong></td><td>可以使用 <code>@Override</code></td><td>不需要 <code>@Override</code></td></tr></tbody></table><ul><li>关键词<code>super</code>可以在存在重写的情况下调用父类中的方法，或是用来区分子类和父类中同名的属性。</li><li>子类不会继承父类的构造器，<code>super(形参列表)</code>可以调用父类的构造器，放在构造器的<strong>首行</strong>。</li><li>子类构造器默认隐式调用父类的无参构造器，<code>super()</code>，</li><li>若父类为有参构造器，则子类必须也显式调用父类的有参构造器</li><li>子类中使用<code>this</code>调用同一类中的其他构造器，用<code>super</code>调用父类的构造器，<strong>二者不能共存</strong></li></ul><h1 id="面向对象的多态性">面向对象的多态性</h1><p>多态性(Polymorphism)的使用前提： 1. 要有类的继承关系 2.要有方法的<strong>重写</strong></p><p>多态性适用于方法，不适用于属性。</p><p>缺陷：父类引用的子类无法调用子类特有的方法。</p><p>如果要判断某个对象是否属于某个类的实例，可以用<code>instanceof</code>关键字：<code>A instanceof B</code>，直接用于条件判断。</p><p>多态可以通过向下转型提取出子类，从而可以调用子类的方法。在向下转型之前，可以使用<code>instanceof</code>进行判断，避免出现异常。</p><p>多态的好处：减少了大量的重载的方法的定义；开闭原则</p><h1 id="object类">Object类</h1><p><code>java.lang.Object</code>是类层次结构的根类，是所有其他类的父类。</p><p><img src="https://i.imgur.com/aJ69aSq.png" /></p><p>重点方法：<code>equals()</code> <code>toStriung()</code><br />了解方法：<code>clone()</code> <code>finalize()</code><br />其他：<code>getClass()</code> <code>hashCode()</code><code>notify()</code> <code>wait()</code></p><h2 id="equals">equals()</h2><ul><li>自定义的类，在没有重写Object和equals()方法的情况下，调用的就是Object中声明的equals()，即比较两个引用对象的<strong>地址</strong>是否相同</li><li>对于<code>String</code> <code>File</code><code>Date</code>和包装类等，都重写了Object中的equals()方法，用于比较两个对象的实体<strong>内容</strong>是否相等。</li><li>通常需要重写equals()，以便按照值（内容）进行比较，可用IDEA自动生成。</li></ul><p><strong>IDEA自动生成的格式</strong>：</p><p>以Customer类为例:</p><table><thead><tr><th>Customer</th></tr></thead><tbody><tr><td>- name: String</td></tr><tr><td>- age: int</td></tr><tr><td>- acct: Account</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Override</span> <span class="hljs-comment">//注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123; <span class="hljs-comment">//声明</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//若对象为空，或者不属于同一个类，则直接false</span><br>    <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> (Customer) o;<span class="hljs-comment">//在确定同类的情况下，向下转型</span><br>    <span class="hljs-keyword">return</span> age == customer.age &amp;&amp; Objects.equals(name, customer.name) &amp;&amp; Objects.equals(acct, customer.acct);<br>    <span class="hljs-comment">//如果两个对象的所有属性全部相同，则返回true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区分和equals">区分<code>==</code>和<code>equals()</code></h3><p><code>==</code>：运算符</p><ol type="1"><li>适用范围：基本数据类型，引用数据类型</li><li>基本数据类型：判断数据值是否相等</li><li>引用数据类型：比较两个引用变量地址值是否相等</li></ol><p><code>equals()</code>：</p><ol type="1"><li>只能用于引用数据类型</li><li>具体使用：见上</li></ol><h2 id="tostring">toString()</h2><p>Object类中toString的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p>开发中的使用场景：</p><ul><li><code>System.out.println()</code>打印的其实就是对象的<code>toString()</code></li></ul><p>子类使用说明：</p><ul><li>自定义的类没有重写该方法的情况下，默认返回的是对象的地址值。</li><li><code>String</code> <code>File</code><code>Date</code>等Object的子类都重写了该方法，调用时返回当前对象的实体内容。</li></ul><p>开发使用说明：</p><ul><li>习惯上，自定义的类会重写toString。</li></ul><p>仍以Customer类为例，自动生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Customer&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>            <span class="hljs-string">&quot;, acct=&quot;</span> + acct +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vscode实用快捷键总结</title>
    <link href="/2025/03/29/vscode/"/>
    <url>/2025/03/29/vscode/</url>
    
    <content type="html"><![CDATA[<h3 id="行操作"><strong>🔹 行操作</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Windows / Linux</strong></th><th><strong>Mac</strong></th></tr></thead><tbody><tr><td><strong>交换当前行和上一行</strong></td><td><code>Alt + ↑</code></td><td><code>Option + ↑</code></td></tr><tr><td><strong>交换当前行和下一行</strong></td><td><code>Alt + ↓</code></td><td><code>Option + ↓</code></td></tr><tr><td><strong>复制当前行</strong></td><td><code>Shift + Alt + ↓</code></td><td><code>Shift + Option + ↓</code></td></tr><tr><td><strong>删除当前行</strong></td><td><code>Ctrl + Shift + K</code></td><td><code>Cmd + Shift + K</code></td></tr><tr><td><strong>在下一行插入一行</strong></td><td><code>Ctrl + Enter</code></td><td><code>Cmd + Enter</code></td></tr><tr><td><strong>在上一行插入一行</strong></td><td><code>Ctrl + Shift + Enter</code></td><td><code>Cmd + Shift + Enter</code></td></tr></tbody></table><hr /><h3 id="选中-编辑"><strong>🔹 选中 &amp; 编辑</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Windows / Linux</strong></th><th><strong>Mac</strong></th></tr></thead><tbody><tr><td><strong>选中整行</strong></td><td><code>Ctrl + L</code></td><td><code>Cmd + L</code></td></tr><tr><td><strong>选中多个相同单词</strong></td><td><code>Ctrl + D</code></td><td><code>Cmd + D</code></td></tr><tr><td><strong>跳过当前选中，选中下一个匹配项</strong></td><td><code>Ctrl + K, Ctrl + D</code></td><td><code>Cmd + K, Cmd + D</code></td></tr><tr><td><strong>选中所有匹配项</strong></td><td><code>Ctrl + Shift + L</code></td><td><code>Cmd + Shift + L</code></td></tr><tr><td><strong>展开选中区域</strong></td><td><code>Shift + Alt + →</code></td><td><code>Shift + Option + →</code></td></tr><tr><td><strong>缩小选中区域</strong></td><td><code>Shift + Alt + ←</code></td><td><code>Shift + Option + ←</code></td></tr></tbody></table><hr /><h3 id="多光标编辑"><strong>🔹 多光标编辑</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Windows / Linux</strong></th><th><strong>Mac</strong></th></tr></thead><tbody><tr><td><strong>添加多个光标</strong></td><td><code>Alt + 点击</code></td><td><code>Option + 点击</code></td></tr><tr><td><strong>在选中区域的每一行添加光标</strong></td><td><code>Shift + Alt + I</code></td><td><code>Shift + Option + I</code></td></tr><tr><td><strong>光标向上添加一个光标</strong></td><td><code>Ctrl + Alt + ↑</code></td><td><code>Cmd + Option + ↑</code></td></tr><tr><td><strong>光标向下添加一个光标</strong></td><td><code>Ctrl + Alt + ↓</code></td><td><code>Cmd + Option + ↓</code></td></tr></tbody></table><hr /><h3 id="代码格式-其他"><strong>🔹 代码格式 &amp; 其他</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Windows / Linux</strong></th><th><strong>Mac</strong></th></tr></thead><tbody><tr><td><strong>格式化代码</strong></td><td><code>Shift + Alt + F</code></td><td><code>Shift + Option + F</code></td></tr><tr><td><strong>快速打开文件</strong></td><td><code>Ctrl + P</code></td><td><code>Cmd + P</code></td></tr><tr><td><strong>打开终端</strong></td><td><code>Ctrl + ~</code></td><td><code>Cmd + ~</code></td></tr><tr><td><strong>查找</strong></td><td><code>Ctrl + F</code></td><td><code>Cmd + F</code></td></tr><tr><td><strong>替换</strong></td><td><code>Ctrl + H</code></td><td><code>Cmd + H</code></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(2) 面向对象-基础</title>
    <link href="/2025/03/28/java2/"/>
    <url>/2025/03/28/java2/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象的基本概念">面向对象的基本概念</h1><p>类（class）和对象（object）是面向对象的核心概念。</p><p><strong>类</strong>：具有相同特征的一大类事物</p><p><strong>对象</strong>：实际存在的该类事物的每个个体，也被称为实例（instance）。</p><p>面向对象内容的三大主线：</p><ul><li>Java类及类的成员：属性，方法，构造器；代码块、内部类。</li><li>面向对象的特征：封装、继承、多态、（抽象）</li><li>其他关键词的使用：this,super,package,import,static,final,interface,abstract等</li></ul><p>类，是一组相关<strong>属性</strong>和<strong>行为</strong>的集合，属性(field)即成员变量，行为即方法(method)。</p><h1 id="内存结构">内存结构</h1><ul><li>栈（stack）：方法内定义的变量，储存在栈中</li><li>堆（heap）：new创建的结构</li></ul><p>例如：</p><p>创建单个对象：</p><p><img src="https://i.imgur.com/Q9v6R16.png" /></p><p>创建多个对象：</p><p><img src="https://i.imgur.com/IdTtXZe.png" /></p><h1 id="类的成员属性">类的成员：属性</h1><p>属性的不同叫法：属性、成员变量、field(字段、域)、实例变量</p><p><strong>变量的分类</strong>：</p><p>按照数据类型来分：基本数据类型、引用数据类型</p><p>按照声明的位置来分：</p><ul><li>在方法体外，类体内声明的变量为<strong>成员变量（属性）</strong></li><li>在方法体内部等位置声明的变量为<strong>局部变量</strong></li></ul><p><img src="https://i.imgur.com/xx6LrzF.png" /></p><p>成员变量和局部变量在内存中分配的位置不同：</p><ul><li>成员变量（属性）存储在堆空间</li><li>局部变量存储在栈空间</li></ul><p><strong>生命周期</strong>：</p><ul><li>属性在对象创建时分配，销毁时释放。</li><li>局部变量随着方法对应的栈帧入栈，出栈而消亡。</li></ul><p><strong>是否有默认值</strong>：属性都有默认值，局部变量都没有默认值，必须先赋值再调用。</p><p>声明变量时，<code>static</code>关键字用<strong>于静态变量</strong>，访问时不需要创建对象，所有对象访问的是同一个变量，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<span class="hljs-comment">//声明</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 静态变量</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Example.num = <span class="hljs-number">20</span>; <span class="hljs-comment">// 直接用类名访问</span><br>        <span class="hljs-type">Example</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();<br>        <span class="hljs-type">Example</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();<br>        System.out.println(obj1.num); <span class="hljs-comment">// 20</span><br>        System.out.println(obj2.num); <span class="hljs-comment">// 20（所有对象访问的是同一个变量）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态变量在程序运行期间一直存在，类加载时分配，程序结束时释放。</p><h1 id="类的成员方法">类的成员：方法</h1><p>作用：类似C语言的函数，简化代码。</p><p>Java的方法<strong>不能独立存在</strong>，必须定义在类里。</p><h2 id="声明的格式">1.声明的格式</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">权限修饰符 <span class="hljs-selector-attr">[其他修饰符]</span> 返回值类型 方法名(形参列表) <span class="hljs-selector-attr">[throws 异常类型]</span> &#123; <span class="hljs-comment">//方法头</span><br>    <span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>权限修饰符</strong>：private  缺省  protected  public</p></blockquote><blockquote><p>形参列表的格式：(类型1 形参1,类型2 形参2, ...)</p></blockquote><h2id="对象调用方法时的内存分配情况">2.对象调用方法时的内存分配情况</h2><p>在 Java 中，当对象调用方法时，内存主要分为三个区域：</p><ol type="1"><li>堆（Heap） - 存放对象实例和实例变量。</li><li>栈（Stack） -存放方法调用时的局部变量、方法执行环境（方法帧）。</li><li>方法区（Method Area） -存放类的字节码信息、静态变量、方法元信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name; <span class="hljs-comment">// 实例变量（存放在堆内存）</span><br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// 局部变量（存放在栈内存）</span><br>        System.out.println(greeting);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/***************************************************/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>); <span class="hljs-comment">// 创建对象，存入堆</span><br>        p1.sayHello(); <span class="hljs-comment">// 调用方法</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 方法调用遵循“先入后出”的栈规则</span><br><span class="hljs-comment">* main入栈-sayHello入栈-sayHello出栈-main出栈-程序结束，JVM退出</span><br><span class="hljs-comment">*/</span><br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ol type="1"><li>对象 (<code>Person</code>) 创建在堆内存，实例变量(<code>name</code>) 也存放在堆。</li><li>方法调用时，会创建<strong>栈帧</strong>，局部变量存入栈内存，方法执行完后自动释放。</li><li>类的字节码信息存储在方法区，所有对象共享。</li><li><code>p1</code> 变量存放在栈内存，指向堆中的 <code>Person</code>对象。</li></ol><h1 id="对象数组">对象数组</h1><p>当数组的元素是引用类型的类(class)时，称之为对象数组。</p><p>创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名[] 数组名 = <span class="hljs-keyword">new</span> 类名[数组大小];<br></code></pre></td></tr></table></figure><h1 id="方法的应用">方法的应用</h1><h2 id="方法的重载">1.方法的重载</h2><p>方法重载（MethodOverloading）指的是在<strong>同一个类</strong>中，<strong>多个方法的名字相同，但参数列表不同</strong>（参数的类型、个数或顺序不同）。</p><p>方法的重载与形参名、权限修饰符、返回值的类型都没有关系。</p><p>编译器如何确定调用的是哪一个具体的方法？：先通过方法名，再通过形参列表。</p><p>坑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">char</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>&#125;;<br>System.out.println(arr);<br></code></pre></td></tr></table></figure><p>打印出来的结果是<code>abcdef</code>，而不是地址值。</p><h2 id="可变个数形参的方法">2.可变个数形参的方法</h2><p>在 Java 中，<strong>可变参数</strong>（Varargs，VariableArguments）允许一个方法接受<strong>可变数量的参数</strong>，使代码更加灵活。</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">返回值类型 方法名(数据类型... 变量名) &#123;<br>    <span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>可变参数在方法内部被当作<strong>数组</strong>处理，如<code>int... numbers</code>实际上等价于<code>int[] numbers</code>。</li><li>可变参数必须是方法的最后一个参数。</li><li>一个方法只能有一个可变参数。</li></ol><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Varargs2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">overload2</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">overload2</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> test.concat(<span class="hljs-string">&quot;=&quot;</span>,<span class="hljs-string">&quot;new&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>        System.out.println(info);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">overload2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">concat</span><span class="hljs-params">(String operator,String ... strs)</span>&#123;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(); <span class="hljs-comment">//拼接字符串时使用 StringBuilder可以避免频繁创建新的对象，性能更好</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>)&#123;<br>                result.append(strs[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.append(operator).append(strs[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.toString();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法的值传递机制">3.方法的值传递机制</h2><p>Java中方法的参数传递机制是<strong>按值传递(pass byvalue)</strong></p><p>方法体内声明的变量为局部变量，存储在栈空间。</p><ul><li>对于基本数据类型的变量来说，传递的是此变量保存的数据值。</li><li>对于引用型数据变量来说，传递的是此变量保存的地址值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 方法的值传递机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ep19</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2025/3/29 15:45</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValue</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">method</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">method</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        test.change(num);<br>        System.out.println(<span class="hljs-string">&quot;num = &quot;</span> + num);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">method</span> &#123;<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span> <span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>        m ++;<br>        System.out.println(<span class="hljs-string">&quot;m: &quot;</span> + m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">m: <span class="hljs-number">11</span><br>num = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></p><p>图例：</p><p><img src="https://i.imgur.com/upVuJnq.png" /></p><h2 id="递归方法">4.递归方法</h2><p><strong>递归(Recursion)</strong>是指<strong>一个方法在其内部调用自己</strong>，直到满足某个终止条件（基准条件），否则会无限递归，导致<code>StackOverflowError</code>。</p><p>递归示例：计算阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">compute</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算一个数的阶乘（递归）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n 输入一个整数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回输入值的阶乘结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">factorial</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//终止条件</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> n * factorial(n-<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：递归的内存耗用较多，占用大量的系统堆栈，需要<strong>慎用</strong>，高性能情况下尽量避免使用递归，不如循环迭代。</p><h1 id="package和import">package和import</h1><p>用于<strong>定义类的所属包</strong>，必须写在<strong>Java文件的第一行</strong>（除了注释）。</p><ul><li>package命名全部小写</li><li>通常使用公司域名的倒置</li></ul><p>例：<strong>MVC(Model-Vie-Controller)</strong>软件架构模式：</p><table><thead><tr><th>组件</th><th>作用</th><th>示例（以 Java Web 应用为例）</th></tr></thead><tbody><tr><td><strong>Model（模型）</strong></td><td>处理 <strong>数据和业务逻辑</strong>，与数据库交互</td><td>Java Bean、DAO（数据访问对象）</td></tr><tr><td><strong>View（视图）</strong></td><td>负责 <strong>用户界面</strong>，展示数据</td><td>HTML、JSP、Thymeleaf、前端框架（Vue、React）</td></tr><tr><td><strong>Controller（控制器）</strong></td><td>负责 <strong>接收用户请求</strong>，调用 Model 处理数据，并返回View</td><td>Servlet、Spring Controller</td></tr></tbody></table><ul><li><code>import</code>用于引入其他包中的类，以便可以直接使用类名，而不必写完整路径。</li><li>在同一个包中的类不需要导入。</li><li>如果使用不同的包下的同名的类，需要使用类的全名的方式指明是哪个类例如：</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">java.util.<span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>java.sql.<span class="hljs-type">date1</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.sql.Date(<span class="hljs-number">121212L</span>);<br></code></pre></td></tr></table></figure></li></ul><h1 id="面向对象的封装性">面向对象的封装性</h1><p>面向对象编程(OOP)的三大特性：<strong>封装、继承、多态</strong>。</p><h2 id="含义">含义</h2><p><strong>封装(Encapsulation)</strong>，指的是<strong>将对象的状态（属性）和行为（方法）封装在一起，并隐藏对象的内部实现细节</strong>，只向外界暴露必要的接口，以提高代码的<strong>安全性</strong>和<strong>可维护性</strong>。</p><p><code>高内聚、低耦合</code></p><h2 id="数据封装的方法">数据封装的方法</h2><p><strong>权限修饰符</strong>：<code>private</code>、<code>default</code>、<code>protected</code>、<code>public</code>，这体现了Java的封装性。我们可以用4种权限修饰符来修饰类和类的内部成员</p><p><strong>作用</strong>：体现被调用时的可见性的大小。声明为<code>private</code>的变量只能通过暴露的方法间接访问(赋值或取值)。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getnum</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>四种权限修饰符的总结</strong>(按照可见性从小到大)：</p><table><thead><tr><th>访问修饰符</th><th>同包访问</th><th>跨包访问</th><th>子类访问</th><th>适用场景</th></tr></thead><tbody><tr><td><code>private</code></td><td>❌ 不能访问</td><td>❌ 不能访问</td><td>❌ 不能访问</td><td>适用于 <strong>完全封装</strong>，只能内部访问</td></tr><tr><td><code>default</code>（无修饰符）</td><td>✅ 可以访问</td><td>❌ 无法访问</td><td>❌ 不能访问</td><td>适用于 <strong>包内使用</strong></td></tr><tr><td><code>protected</code></td><td>✅ 可以访问</td><td>❌ 无法访问</td><td>✅ 继承后可访问</td><td>适用于 <strong>子类继承但不暴露给外部</strong></td></tr><tr><td><code>public</code></td><td>✅ 可以访问</td><td>✅ 可以访问</td><td>✅ 可以访问</td><td>适用于 <strong>完全公开</strong></td></tr></tbody></table><p><strong>封装性的体现</strong>：</p><ol type="1"><li>私有化类的属性，提供公共的get和set方法，对此属性进行获取或修改。</li><li>将类中不需要对外暴露的方法设置为private。</li><li>单例模式中构造器为private，避免在类的外部创建实例。</li></ol><h1 id="类的成员构造器">类的成员：构造器</h1><p>构造器（Constructor）是<strong>用于创建对象</strong>的特殊方法，它在创建对象时会自动调用，一般用于<strong>初始化对象的属性</strong>。</p><p>构造器的声明格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">权限修饰符 类名(形参列表)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建类以后，在没有显式声明构造器的情况下，系统会默认提供一个构造器。且权限修饰符与类相同。</p><p>构造器可以重载。</p><hr /><p><strong>问1：main方法的public权限修饰符能不能换成private？</strong></p><ul><li><code>main</code>方法是 Java 程序的入口点，Java虚拟机（JVM）在执行程序时会调用<code>main</code>方法。如果<code>main</code>方法是<code>private</code>，JVM就无法访问它，导致程序启动失败。</li><li>同理，也不能是<code>protected</code>或缺省，否则JVM无法调用。</li></ul><p><strong>问2：为什么main方法必须是static?</strong></p><ul><li><code>main</code>方法是程序的入口，JVM在启动程序时不会自动创建类的对象，而是直接调用<code>main</code>方法。如果<code>main</code>不是<code>static</code>，那么JVM需要创建该类的对象，但没有默认构造方法可调用，因此会报错。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(1) 基本常识</title>
    <link href="/2025/03/22/java1/"/>
    <url>/2025/03/22/java1/</url>
    
    <content type="html"><![CDATA[<p>学习顺序：javase、mysql、jdbc、javaweb、mybatis、springmvc、spring，这几样基本上就是学习java的骨架了。</p><h1 id="变量与运算符">变量与运算符</h1><h2 id="标识符的命名规范">标识符的命名规范</h2><ul><li>包名：多单词组成时所有字母都小写 xxxyyyzzz</li><li>类名、接口名：多单词组成时，所有单词的首字母大写 XxxYyyZzz</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写age,name,bookName</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接XXX_YYY_ZZZ</li></ul><h2 id="变量">变量</h2><p>变量（variable）定义：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。</p><p>构成：数据类型 变量名 = 变量值，例如：<code>int age = 10;</code></p><p>java的变量按照数据类型分为：</p><pre><code class="hljs">基本数据类型（8种）：      整型：byte \ short \ int \ long      浮点型：float \ double      字符型：char      布尔型：boolean  引用数据类型（6种）：    类（class）      数组（array）      接口（interface）      枚举（enum）      注解（annotation）      记录（record）</code></pre><p>变量都有其<strong>作用域</strong>，只在其作用域内有效。</p><h3 id="整型">整型</h3><p>byte  short  int  long 分别占用1，2，4，8字节（有正负）。</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>取值范围</th><th>默认值</th></tr></thead><tbody><tr><td><code>byte</code></td><td>1</td><td><code>-128</code> ~ <code>127</code></td><td><code>0</code></td></tr><tr><td><code>short</code></td><td>2</td><td><code>-32,768</code> ~ <code>32,767</code></td><td><code>0</code></td></tr><tr><td><code>int</code></td><td>4</td><td><code>-2,147,483,648</code> ~ <code>2,147,483,647</code></td><td><code>0</code></td></tr><tr><td><code>long</code></td><td>8</td><td><code>-9,223,372,036,854,775,808</code> ~<code>9,223,372,036,854,775,807</code></td><td><code>0L</code></td></tr></tbody></table><ul><li>定义<code>long</code>类型的变量，赋值时需要以“l”或“L”作为后缀。</li><li>Java程序中变量通常声明为<code>int</code>。</li><li>整数常量<strong>默认为int类型</strong>。</li></ul><h3 id="浮点型">浮点型</h3><table><thead><tr><th>数据类型</th><th>字节数</th><th>取值范围</th><th>默认值</th><th>精度</th></tr></thead><tbody><tr><td><code>float</code></td><td>4</td><td><code>±1.4E-45</code> ~ <code>±3.4028235E+38</code></td><td><code>0.0f</code></td><td>约 7 位</td></tr><tr><td><code>double</code></td><td>8</td><td><code>±4.9E-324</code> ~ <code>±1.7976931348623157E+308</code></td><td><code>0.0d</code></td><td>约 15~16 位</td></tr></tbody></table><ul><li>定义<code>float</code>类型的变量，赋值时需要以“f”或“F”作为后缀。</li><li>float的表示范围大于long，但是精度不高。</li><li>Java的浮点型常量<strong>默认为double型</strong>。</li><li>float、double不适用于不容许舍入误差的金融计算领域。如果需要精确数字计算或保留特定位数的精度，需要使用BigDecimal类。</li><li><code>IEEE 754标准</code>仍然不能实现“每一个十进制小数都对应一个二进制小数”，0.1+0.2不等于0.3</li></ul><h3 id="字符型">字符型</h3><ul><li>占用两个字节</li></ul><p>字符型变量的三种表现形式：</p><ol type="1"><li>单引号<code>''</code>适用于<strong>单个字符</strong></li><li>直接使用Unicode值表示。例如<code>char c8 = '\u0043';</code></li><li>使用转义字符''将后面的字符转变为字符型常量。</li><li>ASCII码</li></ol><h3 id="布尔型">布尔型</h3><ul><li>只有两个值：true、false，常常用在流程控制语句。</li><li>可以认为占4个字节（一般不谈布尔类型占用的空间大小）。具体来说：编译时不谈几个字节，但是JVM给boolean类型分配内存空间时，boolean类型的变量占据一个槽位（slot，等于4个字节）。</li></ul><h3 id="基本数据类型间的运算规则">基本数据类型间的运算规则</h3><ol type="1"><li><strong>自动类型提升</strong>：</li></ol><p>规则：容量小的变量与容量大的变量做运算时，结果自动转换为容量大的数据类型。容量指可表示数据范围的大小。</p><p>byte---&gt;short---&gt;int---&gt;long---&gt;float---&gt;double</p><ul><li>特殊情况1：容量小于int做运算结果用int类型，否则报错，而且实际的开发中也基本用不上byte和short。</li><li>特殊情况2：char类型运算结果也用int类型，同上。</li></ul><ol start="2" type="1"><li><strong>强制类型转换</strong></li></ol><p>规则：大范围类型转换为小范围类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)d1;<br><br></code></pre></td></tr></table></figure><h3 id="string类">String类</h3><ol type="1"><li>String类属于引用数据类型，俗称字符串。</li><li>可以使用一对双引号进行赋值。</li></ol><p>String与基本数据类型间的运算：</p><ol type="1"><li>这里可以包含布尔变量在内共8种。</li><li>只能做连接运算，用+。</li></ol><h2 id="运算符">运算符</h2><h3 id="逻辑运算符">逻辑运算符</h3><table><thead><tr><th>逻辑运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与（AND）</td><td>只有两个操作数都为 <code>true</code> 时，结果才为<code>true</code></td><td><code>true &amp;&amp; false</code> → <code>false</code></td></tr><tr><td><code>\|\|</code></td><td>逻辑或（OR）</td><td>只要有一个操作数为 <code>true</code>，结果就为<code>true</code></td><td><code>true \|\| false</code> → <code>true</code></td></tr><tr><td><code>!</code></td><td>逻辑非（NOT）</td><td>取反运算，将 <code>true</code> 变 <code>false</code>，反之亦然</td><td><code>!true</code> → <code>false</code></td></tr><tr><td><code>&amp;</code></td><td>按位与（AND）</td><td>与 <code>&amp;&amp;</code>类似，但<strong>不会发生短路</strong></td><td><code>true &amp; false</code> → <code>false</code></td></tr><tr><td><code>\|</code></td><td>按位或（OR）</td><td>与 <code>\|\|</code> 类似，但<strong>不会发生短路</strong></td><td><code>true \| false</code> → <code>true</code></td></tr><tr><td><code>^</code></td><td>逻辑异或（XOR）</td><td>只有两个操作数不相同时，结果才为 <code>true</code></td><td><code>true ^ false</code> → <code>true</code></td></tr></tbody></table><ul><li>逻辑运算符针对的是布尔型变量，结果也是布尔型。</li><li><code>&amp;&amp;</code>和<code>||</code><strong>具有短路特性</strong>，即在某些情况下可以<strong>提前确定最终结果</strong>，从而跳过后续运算，提高效率并避免不必要的计算。例如，<code>A &amp;&amp; B</code>只有当<code>A</code>为<code>true</code>时，才会计算<code>B</code>，如果<code>A</code>为<code>false</code>，那么结果必然为<code>false</code>，所以<code>B</code>会被直接跳过。对于<code>||</code>则反过来，如果<code>A</code>为<code>true</code>，那么不会计算<code>B</code>。</li></ul><h3 id="位运算符">位运算符</h3><p>难点、非重点</p><table style="width:100%;"><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与（AND）</td><td>两个位都为 <code>1</code>，结果才为 <code>1</code></td><td><code>5 &amp; 3</code> → <code>101 &amp; 011 = 001</code> →<code>1</code></td></tr><tr><td><code>\|</code></td><td>按位或（OR）</td><td>只要有一个位为 <code>1</code>，结果就是 <code>1</code></td><td><code>5 \| 3</code> → <code>101 \| 011 = 111</code> →<code>7</code></td></tr><tr><td><code>^</code></td><td>按位异或（XOR）</td><td>两个位不同则为 <code>1</code>，相同则为 <code>0</code></td><td><code>5 ^ 3</code> → <code>101 ^ 011 = 110</code> →<code>6</code></td></tr><tr><td><code>~</code></td><td>按位取反（NOT）</td><td>0 变 1，1 变 0（取反补码）</td><td><code>~5</code> → <code>~00000101</code> → <code>11111010</code>（即<code>-6</code>）</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移（Left Shift）</td><td>将二进制位左移 <code>n</code> 位，右侧补 <code>0</code></td><td><code>5 &lt;&lt; 2</code> → <code>101</code> → <code>10100</code> →<code>20</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移（Arithmetic Right Shift）</td><td>保持符号位，左侧补 <code>1</code> 或 <code>0</code></td><td><code>-5 &gt;&gt; 2</code> → <code>11111011</code> →<code>11111110</code> → <code>-2</code></td></tr><tr><td><code>&gt;&gt;&gt;</code></td><td>无符号右移（Logical Right Shift）</td><td>左侧统一补 <code>0</code>，不保持符号位</td><td><code>-5 &gt;&gt;&gt; 2</code> → <code>11111011</code> →<code>00111110</code>（即 <code>1073741822</code>）</td></tr></tbody></table><p><strong>案例</strong>：如何交换两个int变量的值？String呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;m=&quot;</span> + m + <span class="hljs-string">&quot;, n=&quot;</span> + n);<br><br>        <span class="hljs-comment">//声明一个临时变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> m;<br>        m = n;<br>        n = temp;<br><br>        System.out.println(<span class="hljs-string">&quot;m=&quot;</span> + m + <span class="hljs-string">&quot;, n=&quot;</span> + n);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件运算符">条件运算符</h3><p>(条件表达式) ? 表达式1 : 表达式2</p><p>条件表达式的结果是布尔类型。</p><h1 id="流程控制">流程控制</h1><h2 id="if-else">if-else</h2><p>与C语言相同，不赘述。</p><p>如何从键盘获取不同类型的变量：使用Scanner类。Scanner类中提供了获取不同类型变量的方法，除了char，需要使用<code>scan.next().charAt(0)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//提供（或创建）一个Scanner类的实例，这里创建了一个Scanner对象sc，用于接收用户的输入</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">//调用Scanner类中的方法，获取指定类型的变量，这里使用nextLine()读取整行文本</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sc.nextLine();<br><br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + s);<br><br>        <span class="hljs-comment">//关闭资源，调用Scanner类的close()</span><br>        scan.close();<br>    &#125;<br>&#125;    <br><br></code></pre></td></tr></table></figure><h2 id="获取随机数">获取随机数</h2><p>可以使用Java提供的API：Math类的random()（不用额外导包），返回一个[0.0,1.0)范围内的double随机数。</p><p>进一步的可以得到其他范围的随机数，例如[0,100]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">101</span>);<br></code></pre></td></tr></table></figure><p>获取一个[a,b]范围的随机数：<code>(int)(Math.random() * (b - a + 1)) + a;</code></p><h2 id="switch-case">switch-case</h2><p>语法格式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br><br>    <span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:<br>        <span class="hljs-comment">//执行语句1</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:<br>        <span class="hljs-comment">//执行语句2</span><br>        <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">//执行语句</span><br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>switch中的表达式只能是特定的数据类型：byte  short  char  int 枚举(JDK5.0新增)  String(JDK7.0新增)</li><li>开发中使用switch-case时，通常case匹配的情况都有限。</li><li>default的位置是灵活的。</li></ul><h2 id="循环语句">循环语句</h2><p>共三种：for,while,do-while</p><p>循环的4个要素：</p><ol type="1"><li>初始化条件</li><li>循环条件</li><li>循环体</li><li>迭代部分</li></ol><h3 id="for循环">for循环</h3><p>for(1;2;4){<br />3<br />}</p><p>迭代部分含有多条语句时，可以用逗号连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        输入两个正整数m和n，求最大公约数和最小公倍数。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> m&lt;n?m:n;<br><br>        <span class="hljs-comment">//最大公约数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=min;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span> &amp;&amp; m%i==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;最大公约数&quot;</span>+i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最小公倍数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> m&gt;n?m:n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=max;i&lt;=m*n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i%m==<span class="hljs-number">0</span> &amp;&amp; i%n==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;最小公倍数为&quot;</span> + i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们可以在循环结构中使用break，用于跳出循环结构。</li><li>循环条件不满足/循环体中执行了break</li></ul><h3 id="while循环">while循环</h3><p>1 while(2){<br />3<br />4<br />}</p><p>练习：猜数字小游戏 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        随机生成一个1到100以内的整数，用户输入一个整数，记录猜了几次才正确</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//生成随机数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomNumber</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>)+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//记录尝试的次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">guessNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//创建对象sc</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//输入数字</span><br>        System.out.println(<span class="hljs-string">&quot;Please enter a number between 1 and 100&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">yourNumber</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-comment">//循环</span><br>        <span class="hljs-keyword">while</span>(yourNumber != randomNumber)&#123;<br>            <span class="hljs-keyword">if</span>(yourNumber &gt; randomNumber)&#123;<br>                System.out.println(<span class="hljs-string">&quot;Your number is greater than random number&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Your number is less than random number&quot;</span>);<br>            &#125;<br>            guessNumber++;<br>            <span class="hljs-comment">//重新输入数字</span><br>            System.out.println(<span class="hljs-string">&quot;Please try again&quot;</span>);<br>            yourNumber = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-comment">//结束游戏</span><br>        System.out.println(<span class="hljs-string">&quot;congratulations!you have tried &quot;</span> + guessNumber + <span class="hljs-string">&quot; guesses&quot;</span>);<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="do-while-循环">do-while 循环</h3><p>1<br />do{<br />3<br />4<br />}while(2);</p><p>执行过程：1 - 3 - 4 - 2 - 3 - 4 - ··· - 2</p><p>至少会执行一次循环体，用得相对来说比较少。</p><h3 id="无限循环结构">“无限”循环结构</h3><p>格式： while(true) 或 for(;;)，中途使用break跳出循环。</p><p>示例：九九乘法表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java">ublic <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        案例：九九乘法表</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>                System.out.print(i + <span class="hljs-string">&quot;*&quot;</span> + j + <span class="hljs-string">&quot;=&quot;</span> + i*j + <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例">案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        案例：找出100000以内的所有质数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100000</span>;i++)&#123;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;Math.sqrt(i);j++)&#123;<br>                <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>)&#123;<br>                    isFlag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isFlag)&#123;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        System.out.println(<span class="hljs-string">&quot;time spend: &quot;</span> + (endTime - startTime));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：<code>time spend: 35</code>，注意这里的Math.sqrt(i)可以大大提升运算速度，因为一个数的因数关于它的算术平方根对称。</p><h1 id="数组">数组</h1><h2 id="基础知识">基础知识</h2><p>多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，通过编号统一管理。</p><p>Java中的<strong>容器</strong>：数组、集合框架：在<strong>内存</strong>中对多个数据的存储。</p><p>数组属于<strong>引用数据类型</strong>，声明格式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//如果已知初始值：</span><br><span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">//如果未知初始值，需要动态创建：</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-comment">//后续赋值时，直接引用元素，例如</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">30</span>;<br>arr[<span class="hljs-number">3</span>] = <span class="hljs-number">40</span>;<br>arr[<span class="hljs-number">4</span>] = <span class="hljs-number">50</span>;<br><br></code></pre></td></tr></table></figure></p><ul><li>数组一旦初始化完成，其长度确定，并且无法更改。</li><li>内存中一整块连续的空间。</li><li>数组长度可以使用arr.length获取</li></ul><p><strong>数组元素的默认初始化值</strong></p><ul><li>整型：<code>0</code></li><li>浮点型：<code>0.0</code></li><li>字符型：<code>0</code>（对应<code>'\u0000'</code>）</li><li>boolean型：<code>false</code></li><li>引用数据类型：<code>null</code></li></ul><h2 id="算法案例">算法案例</h2><h3 id="生成回行数">生成回行数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpiralMatrix</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入一个数字: &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.close();<br>        <br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (num &lt;= n * n) &#123;<br>            <span class="hljs-comment">// 从左到右</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) matrix[top][i] = num++;<br>            top++;<br>            <br>            <span class="hljs-comment">// 从上到下</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) matrix[i][right] = num++;<br>            right--;<br>            <br>            <span class="hljs-comment">// 从右到左</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) matrix[bottom][i] = num++;<br>            bottom--;<br>            <br>            <span class="hljs-comment">// 从下到上</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) matrix[i][left] = num++;<br>            left++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 打印结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                System.out.printf(<span class="hljs-string">&quot;%3d &quot;</span>, matrix[i][j]);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数组的扩容">数组的扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 现有数组 int[] arr = new int []&#123;1,2,3,4,5&#125;</span><br><span class="hljs-comment"> * 将数组的长度扩容1倍，将10，20，30添加到数组中，如何操作？</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ep19</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2025/3/26 21:52</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">expansion</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> []&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br>        <span class="hljs-comment">//扩容1倍容量</span><br>        <span class="hljs-type">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [arr.length*<span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">//复制到新的数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            newArr[i] = arr[i];<br>        &#125;<br><br>        <span class="hljs-comment">//添加新的数字</span><br>        newArr[arr.length] = <span class="hljs-number">10</span>;<br>        newArr[arr.length+<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br>        newArr[arr.length+<span class="hljs-number">2</span>] = <span class="hljs-number">30</span>;<br><br>        <span class="hljs-comment">//将新的数组地址赋值给原有的数组变量</span><br>        arr = newArr;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; newArr.length; i++) &#123;<br>            System.out.print(newArr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找">查找</h3><ol type="1"><li>线性查找：遍历数组返回索引 复杂度：O(N)</li><li>二分法查找（适用于<strong>有序</strong>数组）复杂度：O(log₂N)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dichotomy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">22</span>&#125;;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否找到了</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//默认的首索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<span class="hljs-comment">//默认的尾索引</span><br><br>        <span class="hljs-keyword">while</span> (head &lt;= end) &#123;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> head + (end - head) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">if</span>(target == arr[mid]) &#123;<br>                System.out.println(<span class="hljs-string">&quot;found it, the index is &quot;</span> + mid);<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid]) &#123;<br>                head = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                end = mid - <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            System.out.println(<span class="hljs-string">&quot;not found&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序算法">排序算法</h3><ol type="1"><li>时间复杂度：分析关键字的比较次数和记录移动的次数，记为<spanclass="math inline">\(O(n)\)</span></li><li>空间复杂度：分析排序算法中需要多少辅助内存，记为<spanclass="math inline">\(S(n)\)</span></li><li>稳定性：若两个值相等的A和B在排序后的前后顺序不变，则这种排序算法是稳定的</li></ol><p><strong>冒泡排序</strong>：</p><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">bubbling</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">33</span>,<span class="hljs-number">55</span>,<span class="hljs-number">43</span>,<span class="hljs-number">22</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-comment">//打印初始数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k : arr) &#123;<br>            System.out.print(k + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br><br>        System.out.println();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                    arr[j+<span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-comment">//打印排序后的结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : arr) &#123;<br>            System.out.print(k + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>快速排序</strong></p><p>时间复杂度： <span class="math inline">\(O(n\log(n))\)</span></p><h2 id="arrays工具类">Arrays工具类</h2><p><strong>判断两个数组是否相等</strong></p><p>位置：java.util</p><p>boolean equals(int[] a,int[] b):比较两个数组的元素是否<strong>依次相等</strong>。相等时返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isEquals</span> <span class="hljs-operator">=</span> Arrays.equals(arr1,arr2);<br></code></pre></td></tr></table></figure><p><strong>输出数组信息</strong></p><p><code>System.out.println(Arrays.toString(arr1));</code></p><p><strong>填充</strong></p><p>将数组中的所有元素填充为指定的数值，例如：<code>Arrays.fill(arr1,22);</code></p><p><strong>排序</strong></p><p><code>Arrays.sort(arr3);</code>，使用快速排序算法</p><p>数组的索引，表示数组元素距离首地址的偏移量，第一个元素地址与首地址相同，偏移量为0，索引是0</p><p>案例：</p><blockquote><p>输入一个整型数组，数组里既有正数也有负数，数组中连续的一个或多个整数成一个子数组，每个子数组都有一个和，求所有子数组的和的最大值。要求时间复杂度为O(n)。</p></blockquote><p><strong>卡丹算法</strong>(Kadane's Algorithm)，用<code>currentSum</code>记录以当前位置为结尾的子数组的最大和，<code>maxSum</code>记录所有子数组中的最大和。遍历数组，对于数组中的每个元素，最大子数组和只有两种可能：</p><ol type="1"><li><code>nums[i]</code>自己构成一个子数组，最大子数组和就是它自己</li><li><code>nums[i]</code>与前面的最大子数组和相加之后，得到的结果才是最大子数组和</li></ol><p>所以，<code>currentSum</code>每次都取以上两种情况中最大的一个。之后，更新<code>maxSum</code>，记录下这个最大值即可。实现的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 输入一个整型数组，数组里既有正数也有负数，数组中连续的一个或多个整数成一个子数组，每个子数组都有一个和，</span><br><span class="hljs-comment"> * 求所有子数组的和的最大值。要求时间复杂度为O(n)。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ep19</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2025/3/27 21:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">sum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建数组</span><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//子数组和的最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentSum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//当前的子数组的和</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<span class="hljs-comment">//注意i从1开始计数，而不是0</span><br>            currentSum  = Math.max(currentSum + nums[i], nums[i]);<br>            maxSum = Math.max(maxSum, currentSum);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;maxSum is &quot;</span> + maxSum);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>卡丹算法只需要对数组进行一次遍历，因此时间复杂度是<spanclass="math inline">\(O(n)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为Hexo博客绑定域名出现ERR_SSL_UNRECOGNIZED_NAME_ALERTu错误</title>
    <link href="/2025/01/17/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    <url>/2025/01/17/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近为这个博客网站新绑定了一个域名。因为我先前没有学过计算机网络相关的知识，遇到ERR_SSL_UNRECOGNIZED_NAME_ALERTu的报错的时候反应了半天才明白要去申请一个SSL证书，在此记录一下这次绑定域名的操作流程。</p><h1 id="参考链接">参考链接</h1><p>1.<ahref="https://cps.ninja/2016/10/09/customize-your-blog-domain/">为Github 上的 Hexo 博客绑定个性域名</a></p><p>2.<ahref="https://www.littlelittleblack.com/Hexo/20200508-self-server-url.html">在自架服务器上搭建Hexo博客并绑定域名</a></p><h1 id="操作流程">操作流程</h1><p>我最开始看的是第一个链接，在namesilo上购买一个域名，然后直接使用namesilo进行DNS解析。第一个链接里有一点没有说清楚：A记录的IP地址应当是<code>username.github.io</code>的IP地址，而不是github的地址。对此，github的<ahref="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">官方文档</a>中有详细的说明：</p><p><img src="https://i.imgur.com/ZMUsLHh.png" /></p><p>向DNS解析中加入4个A记录即可。</p><p>当然也可以通过ping的方式获取IP地址。按<code>win</code>+<code>R</code>输入<code>cmd</code>，再输入<code>ping username.github.io</code>，看一下返回的IP即可：</p><p><img src="https://i.imgur.com/OEH8zEM.png" /></p><p>这次返回的是<code>185.199.109.153</code>.</p><h1 id="踩坑">踩坑</h1><p>我按照链接1的步骤操作完成之后，发现新绑定域名后的博客仍无法打开，报错：</p><p><strong>嗯… 无法访问此页面 https://kznep19.blog/上的网页似乎有问题，或者可能已永久移动到新的 Web 地址。ERR_SSL_UNRECOGNIZED_NAME_ALERTu</strong></p><p>向浏览器中输入<code>username.github.io</code>，发现原来的地址也无法访问了。起初我以为是namesilo自带的DNS解析功能无法正常使用（因为namesilo的名声似乎不是很好），所以我仿照链接2将NDS解析转移到国内的DNSPod网站上，发现仍然是同样的报错，说明问题不在这里。</p><p>注意<code>ERR_SSL_UNRECOGNIZED_NAME_ALERTu</code>，对此ChatGPT的回答如下：</p><blockquote><p>ERR_SSL_UNRECOGNIZED_NAME_ALERT 是一个与 SSL/TLS连接相关的错误，通常出现在客户端和服务器进行加密通信时。这种错误表示客户端在请求时提供的主机名（如网址）没有在服务器的证书中正确匹配，或者服务器没有正确配置SSL/TLS 证书。</p></blockquote><p>“没有正确配置 SSL/TLS证书”，我查找资料的过程中没有见到说绑定域名需要单独配置SSL证书的教程。直到我看到了<ahref="https://github.com/lss233/chatgpt-mirai-qq-bot/issues/1146">这个网站</a>，里面提到</p><blockquote><p>浏览器报错 ERR_SSL_UNRECOGNIZED_NAME_ALERT<br />其意为 “错误 SSL 无法识别的名称警报"。应该因为你还未部署SSL证书💦。SSL证书是此服务必须的，去申请一个即可 🙏。</p></blockquote><p>于是我在<ahref="https://ohttps.com/monitor/dashboard">OHTTPS</a>中为这个域名免费申请了一个SSL证书，很快网站就能正常访问了，至此问题终于得到解决。</p><p>另外，不管是OHTTPS还是DNSPod提供的SSL证书发放服务，其免费证书的有效期都只有三个月，快到期的时候要不要忘了更换证书。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>エルマ-ヨルシカ</title>
    <link href="/2025/01/07/Elma/"/>
    <url>/2025/01/07/Elma/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>雨とカプチーノ - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p><hr /><p>朝日の差す木漏れ日　僕とエルマ</p><p>まだ　まだ眠いかい</p><p>初夏の初め近づく五月の森</p><hr /><p>歩きだした顔には花の雫</p><p>ほら　涙みたいだ</p><p>このまま欠伸をしよう</p><p>なんならまた椅子にでも座ろう</p><hr /><p>許せないことなんてないんだよ</p><p>君は優しくなんてなれる</p><hr /><p>このまま何処かの遠い国で</p><p>浅い夏の隙間に寝そべったまま</p><p>涙も言葉も出ないままで</p><p>ただ夜の深さも知らないままで</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p><hr /><p>辛いことも苦しいことも何も見えないならわからないし</p><p>塞いだ目閉じたままで逃げた</p><p>月明かりの道を歩く</p><hr /><p>狭い部屋も冷たい夜も</p><p>眠い昼も　寂しい朝も</p><p>さよならの言葉越しに君の顔を見てる</p><hr /><p>このまま何処かの遠い国で</p><p>浅い夏の隙間に寝そべったまま</p><p>涙も言葉も出ないままで</p><p>ただ空の青さだけ見たままで</p><hr /><p>ただ君と終わりも知らないままで</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>少女A</title>
    <link href="/2025/01/05/%E5%B0%91%E5%A5%B3A/"/>
    <url>/2025/01/05/%E5%B0%91%E5%A5%B3A/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>神様のダンス - ヨルシカ</p><p>作詞：椎名もた（ぽわぽわP）</p><p>作曲：椎名もた（ぽわぽわP）</p><p>唄：鏡音リン</p><p>中文翻譯：https://home.gamer.com.tw/artwork.php?sn=5816671</p><hr /><p>僕の命ってったって　誰の命っつったって</p><p>即使說這是我的生命　即使說這是他人的生命</p><p>時々　公平に　裁かれるもんなんでしょ</p><p>偶爾　也會被公平地　受到裁決對吧</p><p>暗い空にやってきた　鬱を連れてやってきた</p><p>我抵達了漆黑的天空　並帶來了憂愁</p><p>時々雨　総計に　頼り切りだ　どうしよう</p><p>偶爾下起了雨　我總是　依賴著它　該怎麼辦呢</p><p>朽ちるまでの愛憎を　朽ちるまでの愛憎を</p><p>接受枯朽之前的愛憎　枯朽之前的愛憎的你</p><p>飲み込む君　簡単に　微笑む君　どうして</p><p>簡單地　露出微笑的你　為什麼</p><p>言葉を書く　曖昧に　言葉を書く　曖昧に</p><p>曖昧地　書寫著話語　曖昧地　書寫著話語</p><p>伝わりきらんないから　君だけをさ　信じて</p><p>因為根本無法全數傳達出去啊　所以我只　相信你一人</p><p>捨ててきた夢をあつめて</p><p>我開始收集起之前我所捨棄的夢想</p><p>ちょっと　ちょっと　間違えたから</p><p>因為這其中有些　有些　錯誤啊</p><p>ああ　「時に　時に　躓いたって、」</p><p>啊啊　「即使偶爾　偶爾　受到挫折、」　也還是</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い　言い寄らないで</p><p>好冷好冷好冷好冷　別如此求愛啊</p><p>ああ　君の君の君の声が</p><p>啊啊　你的你的你的聲音十分</p><p>遠い遠い遠い遠い遠い</p><p>遙遠遙遠遙遠遙遠遙遠</p><p>遠い遠い遠い遠い遠い</p><p>遙遠遙遠遙遠遙遠遙遠</p><p>遠い遠い遠い遠い　傷つけないで</p><p>遙遠遙遠遙遠遙遠　別傷害我啊</p><p>何番目でも　何番目でも</p><p>不管是第幾個　不管是第幾個</p><p>僕が僕であるために？</p><p>我也希望我能保有自我？</p><p>契り集め持ってきた　契り集め持ってきた</p><p>我收集起來各種約定　我收集起來各種約定</p><p>あの日の間違いを　飲み込むのが苦るしくて</p><p>要理解那一天的誤會　實在是過於痛苦</p><p>朽ちるまでの愛憎を　朽ちるまでの愛憎を</p><p>接受枯朽之前的愛憎　枯朽之前的愛憎的你</p><p>飲み込む君　簡単に　微笑む君　どうして</p><p>簡單地　露出微笑的你　為什麼</p><p>「子供だましの花ふたつ、」</p><p>「欺騙小孩的兩束花、」</p><p>きっと　きっと　諦めたから？</p><p>一定　一定是因為　我放棄了？</p><p>ああ　遠い夢を追いかけてさ</p><p>啊啊　我追趕著遙遠的夢想　但夢想卻十分</p><p>早い早い早い早い早い</p><p>快速快速快速快速快速</p><p>早い早い早い早い早い</p><p>快速快速快速快速快速</p><p>早い早い早い早い　追いつけないよ</p><p>快速快速快速快速　我根本無法追上啊</p><p>捨てきれず残した思いが</p><p>我無法完全捨棄並遺留下來的感受讓人十分</p><p>憎い憎い憎い憎い憎い</p><p>憎恨憎恨憎恨憎恨憎恨</p><p>憎い憎い憎い憎い憎い</p><p>憎恨憎恨憎恨憎恨憎恨</p><p>憎い憎い憎い憎い　許されないの？</p><p>憎恨憎恨憎恨憎恨　不被他人原諒嗎？</p><p>ああ　夢を夢を見てたはずが</p><p>啊啊　我本應該正在做夢　但卻感到了</p><p>怖い怖い怖い怖い怖い</p><p>恐懼恐懼恐懼恐懼恐懼</p><p>怖い怖い怖い怖い怖い</p><p>恐懼恐懼恐懼恐懼恐懼</p><p>怖い怖い怖い怖い　近づかないで</p><p>恐懼恐懼恐懼恐懼　別靠近我啊</p><p>合言葉を繰り返すだけ</p><p>我只是不斷重複著暗語而已</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い　お願いだから</p><p>好冷好冷好冷好冷　拜託你</p><p>何番目でも　何番目でも</p><p>不管是第幾個　不管是第幾個</p><p>僕が僕であるために…</p><p>我也希望我能保有自我…</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>雨とカプチーノ - ヨルシカ</title>
    <link href="/2024/12/30/%E9%9B%A8%E3%81%A8%E3%82%AB%E3%83%97%E3%83%81%E3%83%BC%E3%83%8E%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/12/30/%E9%9B%A8%E3%81%A8%E3%82%AB%E3%83%97%E3%83%81%E3%83%BC%E3%83%8E%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>雨とカプチーノ - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>灰色に白んだ言葉はカプチーノみたいな色してる</p><p>言い訳はいいよ　窓辺に置いてきて</p><p>数え切れないよ</p><hr /><p>灰色に白んだ心はカプチーノみたいな色をしてる</p><p>言い訳はいいよ　<ruby>呷<rt>あお</rt></ruby>ろうカプチーノ</p><p><ruby>戯<rt>おど</rt></ruby>けた振りをして</p><hr /><p>さぁ<ruby>揺蕩<rt>たゆた</rt></ruby>うように雨流れ</p><p>僕らに<ruby>嵐<rt>あら</rt></ruby>す花に溺れ</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないような思い出を</p><p>どうか、どうか、どうか君が溢れないように</p><hr /><p><ruby>波<rt>なみ</rt></ruby>待つ海岸　<ruby>紅<rt>くれない</rt></ruby>夕差す日</p><p>窓に反射して</p><p>八月のヴィスビー　<ruby>潮騒<rt>しおさい</rt></ruby></p><p>待ちぼうけ　海風一つで</p><hr /><p>夏泳いだ花の白さ、<ruby>宵<rt>よい</rt></ruby>の雨</p><p>流れる夜に溺れ</p><p>誰も褪せないような花一つ</p><p>どうか、どうか、どうか胸の内側に挿して</p><hr /><p>ずっとおかしいんだ</p><p>生き方一つを教えてほしいだけ</p><p>払えるものなんて僕にはもうないけど</p><p>何も答えられないなら言葉一つでもいいよ</p><p>わからないよ</p><p>本当にわからないんだよ</p><hr /><p>さぁ<ruby>揺蕩<rt>たゆた</rt></ruby>うように雨流れ</p><p>僕らに<ruby>嵐<rt>あら</rt></ruby>す花に溺れ</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないように書く詩を</p><p>どうか、どうか、どうか今も忘れないように</p><p>また一つ夏が終わって、花一つを胸に抱いて、</p><p>流れる<ruby>目蓋<rt>まぶた</rt></ruby>の裏で</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないようにこの詩を</p><p>どうか、どうか君が溢れないように</p><hr />]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神様のダンス - ヨルシカ</title>
    <link href="/2024/12/27/%E7%A5%9E%E6%A7%98%E3%81%AE%E3%83%80%E3%83%B3%E3%82%B9%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/12/27/%E7%A5%9E%E6%A7%98%E3%81%AE%E3%83%80%E3%83%B3%E3%82%B9%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>神様のダンス - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>忘れるなんて酷いだろ</p><p>幸せになんてなるものか</p><p>色のない何かが咲いた</p><p>君のいない夏に咲いた</p><hr /><p>人に笑われたくないから</p><p>怯えるように下を向く</p><p>心より大事な何かが</p><p>あってたまるものか</p><hr /><p>暮れない夕に茜追い付いて</p><p>君を染め抜いた</p><p>見えないように僕を追い越して</p><p>行かないで</p><hr /><p>僕たち神様なんて知らん顔</p><p>どこまでだって行ける</p><p>なぁ、心まで醜い僕らだ</p><p>世界は僕らのものだ</p><hr /><p>音楽だけでいいんだろ</p><p>他人に合わせて歩くなよ</p><p>教えてくれたのはあんたじゃないか</p><hr /><p>どうだっていいよ、このまま遠くへ</p><p>誰も知らない場所で月明かりを探すのだ</p><hr /><p>名もない花が綺麗のだ</p><p>どうでもいいことばっかだ</p><p>君の口癖が感染ってる</p><p>喉の真下には君がいる</p><hr /><p>言葉も生活も愛想も</p><p>全て捨ててこそ音楽だ</p><p>その価値も知らないあんたに</p><p>わかって堪るものか</p><hr /><p>暮れない夕に茜追い付いて</p><p>僕を染め抜いた</p><p>いつか時間が全て追い抜いて</p><p>消えないで</p><hr /><p>僕たち神様なんて知らん顔</p><p>世界の全部が欲しい</p><p>なぁ心まで醜いあんたの、想い出全部をくれよ</p><p>価値観だって自由なら</p><p>人を傷付けていいだろ</p><p>教えなかったのはあんたじゃないか</p><hr /><p>どうだっていいよ、このまま遠くへ</p><p>誰も見てない場所で生きる真似をしてるのさ</p><p>酷い顔で踊るのさ</p><p>胸も痛いままで</p><hr /><p>神様僕たちなんて知らん顔</p><p>どこまでだって行ける</p><p>なぁ、言葉が世界だと云うなら、世界は僕らのものだ</p><p>忘れるなんて酷いだろ</p><p>幸せになんてなれるかよ</p><p>僕を歪めたのはあんたじゃないか</p><hr /><p>そうだった、僕はこのまま遠くへ</p><p>誰も知らない場所で月明かりを探すのだ</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HDLBits刷题笔记</title>
    <link href="/2024/11/28/Verilog/"/>
    <url>/2024/11/28/Verilog/</url>
    
    <content type="html"><![CDATA[<p>最近试了一下Verilog刷题网站HDLBits，感觉还是蛮有意思的。这里记录一下刷题的一些收获。</p><h2 id="bit-slicing的简化语法">Bit slicing的简化语法</h2><p><em><strong>Bit slicing</strong> ("Indexed vector part select", sinceVerilog-2001) has an even more compact syntax.</em></p><p>来源：Circuits-Multiplexers-Mux256to1v</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1023</span>:<span class="hljs-number">0</span>] in,   <span class="hljs-comment">// 1024-bit input</span><br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] sel,      <span class="hljs-comment">// 8-bit select input</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] out      <span class="hljs-comment">// 4-bit output</span><br>);<br><br>    <span class="hljs-keyword">assign</span> out = in[sel*<span class="hljs-number">4</span> +: <span class="hljs-number">4</span>];  <span class="hljs-comment">// Compact syntax for bit slicing</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><code>in[sel*4 +: 4]</code> 是 Verilog-2001 中引入的 “indexed partselect” 语法：<br /><code>sel*4</code> 表示选择从哪个位开始（包含该位）。<br /><code>+: 4</code>表示从 sel*4 开始，选择 4 位宽的数据。<br />这个语法非常简洁，并且可以避免合成工具无法推断切片宽度为常数的问题。</p><p>类似的还有<code>assign out = in[sel*4+3 -: 4];</code></p><h2 id="加法器">加法器</h2><p><em>Create a 100-bit binary adder. The adder adds two 100-bit numbersand a carry-in to produce a 100-bit sum and carry out.</em></p><p><strong>正解：没有必要重新构造全加器模块了，直接使用现有的运算符号。</strong><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br><span class="hljs-keyword">input</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] a,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] b,<br><span class="hljs-keyword">input</span> cin,<br><span class="hljs-keyword">output</span> cout,<br><span class="hljs-keyword">output</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] sum<br>);<br><br><span class="hljs-comment">// The concatenation &#123;cout, sum&#125; is a 101-bit vector.</span><br><span class="hljs-keyword">assign</span> &#123;cout, sum&#125; = a+b+cin;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><h2 id="卡诺图的两种形式">卡诺图的两种形式</h2><p>77.<em>A single-output digital system with four inputs (a,b,c,d)generates a logic-1 when 2, 7, or 15 appears on the inputs, and alogic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The inputconditions for the numbers 3, 8, 11, and 12 never occur in this system.For example, 7 corresponds to a,b,c,d being set to 0,1,1,1,respectively.</em></p><p><em>Determine the output out_sop in minimum SOP form, and the outputout_pos in minimum POS form.</em></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">input</span> c,<br>    <span class="hljs-keyword">input</span> d,<br>    <span class="hljs-keyword">output</span> out_sop,<br>    <span class="hljs-keyword">output</span> out_pos<br>); <br>    <span class="hljs-keyword">assign</span> out_sop = (c&amp;d) | (~a&amp;~b&amp;c&amp;~d);<br>    <span class="hljs-keyword">assign</span> out_pos = c &amp; (~b|d) &amp; (~a|d);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="dff8">Dff8</h2><p><em>Create 8 D flip-flops. All DFFs should be triggered by thepositive edge of clk.</em></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br><span class="hljs-keyword">input</span> clk,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q);<br><br><span class="hljs-comment">// Because q is a vector, this creates multiple DFFs.</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<br>q &lt;= d;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>因为q在这里是一个向量，所以可以一次性创建出8个D触发器。</p><h2 id="异步复位">异步复位</h2><p>异步复位和同步复位相比，唯一的区别在于always的敏感列表中包含了复位信号reset。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br><span class="hljs-keyword">input</span> clk,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br><span class="hljs-keyword">input</span> areset,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q);<br><br><span class="hljs-comment">// The only difference in code compared to synchronous reset is in the sensitivity list.</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk, <span class="hljs-keyword">posedge</span> areset)<br><span class="hljs-keyword">if</span> (areset)<br>q &lt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>q &lt;= d;<br><br><br><span class="hljs-comment">// In Verilog, the sensitivity list looks strange. The FF&#x27;s reset is sensitive to the</span><br><span class="hljs-comment">// *level* of areset, so why does using &quot;posedge areset&quot; work?</span><br><span class="hljs-comment">// To see why it works, consider the truth table for all events that change the input </span><br><span class="hljs-comment">// signals, assuming clk and areset do not switch at precisely the same time:</span><br><br><span class="hljs-comment">//  clkaresetoutput</span><br><span class="hljs-comment">//   x 0-&gt;1q &lt;= 0; (because areset = 1)</span><br><span class="hljs-comment">//   x 1-&gt;0no change (always block not triggered)</span><br><span class="hljs-comment">//  0-&gt;1   0q &lt;= d; (not resetting)</span><br><span class="hljs-comment">//  0-&gt;1   1q &lt;= 0; (still resetting, q was 0 before too)</span><br><span class="hljs-comment">//  1-&gt;0   xno change (always block not triggered)</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="problem-85-dff-with-byte-enabledff16e">Problem 85 : DFF withbyte enable(Dff16e)</h2><p><em>Create 16 D flip-flops. It's sometimes useful to only modifyparts of a group of flip-flops. The byte-enable inputs control whethereach byte of the 16 registers should be written to on that cycle.byteena[1] controls the upper byte d[15:8], while byteena[0] controlsthe lower byte d[7:0].</em></p><p><em>resetn is a synchronous, active-low reset.</em></p><p><em>All DFFs should be triggered by the positive edge ofclk.</em></p><p>这道题的要求是创建一个 16 路D触发器。部分情况下，只需要多路触发器中的一部分触发器工作，此时可以通过ena 使能端进行控制。使能端 ena 信号有效时，触发器在时钟上升沿工作。</p><p><strong>注意：当byteena=2'b11时，两个部分均可被写入，因此要慎重选择if~else的结构</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> resetn,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] byteena,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] d,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] q<br>);<br><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(~resetn)<br>            q &lt;= <span class="hljs-number">16&#x27;b0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(byteena[<span class="hljs-number">1</span>] || byteena[<span class="hljs-number">0</span>] ) <span class="hljs-keyword">begin</span><span class="hljs-comment">//注意这个地方要兼顾2&#x27;b11的情况</span><br>        <span class="hljs-keyword">if</span>(byteena[<span class="hljs-number">1</span>])<br>            q[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>] &lt;= d[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">if</span>(byteena[<span class="hljs-number">0</span>])<br>            q[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] &lt;= d[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>            <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="边沿捕获">边沿捕获</h2><p>96.当reset信号为高时，强制输出为低电平；当输入信号in出现下降沿时，输出out保持为1，也就是说只有reset能将out拉低。</p><p><img src="https://i.imgur.com/0iKObkG.png" /></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out<br>);<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] temp;<br>    <br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <br>        temp &lt;= in;<span class="hljs-comment">//record the previous state.</span><br>        <br>        <span class="hljs-keyword">if</span>(reset)<br>            out &lt;= <span class="hljs-number">32&#x27;b0</span>;<br>        <span class="hljs-keyword">else</span><br>            out = (temp &amp; ~in) | (out);<span class="hljs-comment">//这里是关键，|out 保证了原来是1的位仍保持为1</span><br>    <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="双边沿触发器">双边沿触发器</h2><p>Verilog的always语句块的敏感变量列表不能同时支持posedge和negedge，自己单独搭建电路实现双边沿触发的功能。</p><p>时序图如下：</p><p><img src="https://i.imgur.com/iMKGS2u.png" /></p><p>利用二选一数据选择器的实现思路：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> d,<br>    <span class="hljs-keyword">output</span> q<br>);<br>    <span class="hljs-keyword">reg</span> q1, q2;<br>    <span class="hljs-comment">//这里来实现clk的上升沿与下降沿</span><br>    <span class="hljs-keyword">assign</span> q = clk?q1:q2;<br><br>    <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk)<br>        <span class="hljs-keyword">begin</span><br>            q1 &lt;= d;<br>        <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">negedge</span> clk)<br>        <span class="hljs-keyword">begin</span><br>           q2 &lt;= d; <br>        <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="暂停计数器">暂停计数器</h2><p>Problem 101 Slow decade counter</p><p>在时钟上升沿对0~9递增计数，高电平复位，当slowena为低时暂停计数。</p><p><img src="https://i.imgur.com/tBfNOqY.png" /></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> slowena,<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] q);<br>   <br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(reset)<br>            q &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slowena)<span class="hljs-comment">//the counter can increment only when slowena is &#x27;1&#x27;</span><br>            <span class="hljs-keyword">begin</span><br>                <span class="hljs-keyword">if</span> (q == <span class="hljs-number">4&#x27;d9</span>)   <span class="hljs-comment">//counter overflow</span><br>                    q &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>                <span class="hljs-keyword">else</span>             <span class="hljs-comment">//normal counting</span><br>                    q &lt;= q + <span class="hljs-number">1&#x27;b1</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="problem-104-4-digit-decimal-counter">Problem 104 4-digit decimalcounter</h2><p><em>Build a 4-digit BCD (binary-coded decimal) counter. Each decimaldigit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is thetens digit, etc. For digits [3:1], also output an enable signalindicating when each of the upper three digits should beincremented.</em></p><p><em>You may want to instantiate or modify some one-digit decadecounters.</em></p><p>这道题要求我们设计一个四位BCD码计数器。由于每一位BCD码要用4位二进制数表示，因此输出为16位二进制数。基本思路是先建立一个一位BCD码计数器的基本单元，再实例化得到4位的。</p><p>个人觉得这里比较难搞的地方是怎么处理进位。在组合逻辑电路中，4位BCD码加法器的进位只需要把低位端的进位输出连接到高位的进位输入即可。对于时序逻辑来说，进位也可以理解为<strong>使能</strong>，计数可以理解为<strong>翻转</strong>，只有当计数溢出时才使能一次高位，使高位在时钟信号到来的时候翻转一次。</p><p>以T触发器构成的计数器为例，T触发器有以下特征：</p><ul><li>当使能信号T=1时，每次触发会使输出翻转；</li><li>当使能信号T=0时，输出保持不变；</li></ul><p>计数器在递增计数的过程中，计数值的变化体现为位的翻转，低位对高位的影响体现在只有当低位全为1时高位才可翻转（进位），用激励方程来描述就是</p><p><img src="https://i.imgur.com/TKEXS3Q.png" /></p><p>对应的硬件电路为</p><p><img src="https://i.imgur.com/TToOypW.png" /></p><p>对于BCD计数器来说也是一样的道理。4位BCD计数器由4个BCD技术单元组成，每一个单元都有使能端，以最高位为例，只有当四位BCD的低三位全为<code>4'b1001</code>时，最高位才被使能，这只需要用与门就可以实现，类似上图中的G1,G2,G3。用Verilog来描述的话，可以是<code>.ena(q[11:8] == 4'd9 &amp;&amp; q[7:4] == 4'd9 &amp;&amp; q[3:0] == 4'd9),</code>或者直接写为<code>.ena(q[11:0] == 12'h999),</code>，二者是等价的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset,   <span class="hljs-comment">// Synchronous active-high reset</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">1</span>] ena,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] q);<br><br>    BCDadd counter0 (<br>        <span class="hljs-variable">.reset</span>(reset),<br>        <span class="hljs-variable">.ena</span>(<span class="hljs-number">1&#x27;b1</span>),<br>        <span class="hljs-variable">.clk</span>(clk),<br>        <span class="hljs-variable">.q</span>(q[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>])<br>    );<br>    BCDadd counter1 (<br>        <span class="hljs-variable">.reset</span>(reset),<br>        <span class="hljs-variable">.ena</span>(q[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">4&#x27;b1001</span>),<br>        <span class="hljs-variable">.clk</span>(clk),<br>        <span class="hljs-variable">.q</span>(q[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>])<br>    );    <br>    BCDadd counter2 (<br>        <span class="hljs-variable">.reset</span>(reset),<br>        <span class="hljs-variable">.ena</span>(q[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">8&#x27;h99</span>),<br>        <span class="hljs-variable">.clk</span>(clk),<br>        <span class="hljs-variable">.q</span>(q[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>])<br>    );    <br>    BCDadd counter3 (<br>        <span class="hljs-variable">.reset</span>(reset),<br>        <span class="hljs-variable">.ena</span>(q[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">12&#x27;h999</span>),<br>        <span class="hljs-variable">.clk</span>(clk),<br>        <span class="hljs-variable">.q</span>(q[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>])<br>    );        <br>    <br>    <span class="hljs-keyword">assign</span> ena[<span class="hljs-number">3</span>:<span class="hljs-number">1</span>] = &#123;q[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]==<span class="hljs-number">12&#x27;h999</span>, q[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">8&#x27;h99</span>, q[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">4&#x27;b1001</span>&#125;;<br>   <br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> BCDadd (<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">input</span> ena,<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] q<br>);<br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (reset)<br>            q &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ena) <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">if</span> (q == <span class="hljs-number">4&#x27;b1001</span>)<br>                q &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>            <span class="hljs-keyword">else</span> <br>                q &lt;= q + <span class="hljs-number">1&#x27;b1</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h2 id="lfsr">LFSR</h2><p>Linear-feedback shift register，线性反馈移位寄存器 未完待续</p><p><img src="https://i.imgur.com/yZmHE3W.png" /></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br><span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] SW,      <span class="hljs-comment">// R</span><br><span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] KEY,     <span class="hljs-comment">// L and clk</span><br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] LEDR<br>    );  <span class="hljs-comment">// Q</span><br><br>    <span class="hljs-keyword">wire</span> clk = KEY[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">wire</span> l = KEY[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] d = l ? SW : &#123;LEDR[<span class="hljs-number">1</span>]^LEDR[<span class="hljs-number">2</span>],LEDR[<span class="hljs-number">0</span>],LEDR[<span class="hljs-number">2</span>]&#125;;<br>    <br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>            LEDR &lt;= d;<br>    <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="rule-90">Rule 90</h2><p>Rule90是一种一维“元胞自动机”（cellularautomaton），在每个时间步骤，每个细胞的下一个状态是它两个当前邻居的异或（XOR）值。</p><p><em>In this circuit, create a 512-cell system (q[511:0]), and advanceby one time step each clock cycle. The load input indicates the state ofthe system should be loaded with data[511:0]. Assume the boundaries(q[-1] and q[512]) are both zero (off).</em></p><p>官方解答：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br><span class="hljs-keyword">input</span> clk,<br><span class="hljs-keyword">input</span> load,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">511</span>:<span class="hljs-number">0</span>] data,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">511</span>:<span class="hljs-number">0</span>] q);<br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span> (load)<br>q &lt;= data;<span class="hljs-comment">// 给D触发器赋值</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br><span class="hljs-comment">// 在每个时钟周期，D触发器储存的值变成它的左右邻居的异或值</span><br><span class="hljs-comment">// 因此对每一位进行的操作是相同的</span><br><span class="hljs-comment">// 这可以用数组很简单地表达出来</span><br><span class="hljs-comment">// 使用部分选择和连接符描述移位操作</span><br>q &lt;= &#123;<span class="hljs-number">1&#x27;b0</span>,q[<span class="hljs-number">511</span>:<span class="hljs-number">1</span>]&#125; ^ &#123;q[<span class="hljs-number">510</span>:<span class="hljs-number">0</span>], <span class="hljs-number">1&#x27;b0</span>&#125; ;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>0</th><th>q[511]</th><th>q[510]</th><th>…</th><th>q[2]</th><th>q[1]</th></tr></thead><tbody><tr><td>q[510]</td><td>q[509]</td><td>q[508]</td><td>…</td><td>q[0]</td><td>0</td></tr></tbody></table><p>可以看出每来一个时钟沿，q的每一位都会变成相邻两位的异或。</p>]]></content>
    
    
    <categories>
      
      <category>EE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>レプリカント - ヨルシカ</title>
    <link href="/2024/11/25/%E3%83%AC%E3%83%97%E3%83%AA%E3%82%AB%E3%83%B3%E3%83%88%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/11/25/%E3%83%AC%E3%83%97%E3%83%AA%E3%82%AB%E3%83%B3%E3%83%88%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>レプリカント - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><p>君は映画をずっと観ている<br />在空无一人的劇場之中</p><p>誰一人もない劇場で<br />你一个人独自看着電影</p><p>今思えばチープなセットで<br />那是部現在看来布景廉价</p><p>人のよく死ぬSF映画<br />常有人死去的科幻電影</p><p>いつか世界が真面になって<br />如果将来世界能變得積極美好</p><p>人の寿命さえ随分伸びて<br />人的寿命也无限延長</p><p>死ねない世界になればいいのにね<br />可以不用經歷死亡就好了</p><p>そしたら心以外は偽物だ<br />這樣一来 除了真心其余皆是虚假的</p><p>言葉以外は偽物だ<br />除了話語其余皆是虚假的</p><p>神様だって作品なんだから<br />因為神明也不過是个作品罷了</p><p>僕ら皆レプリカだ<br />我們全都是複製品</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>冷たくなって年老いて<br />天气轉冷 年華逝去</p><p>その時に<br />届時</p><hr /><p>僕は映画をずっと観ている<br />我一直在看着一部電影</p><p>つまらないほどに薄い映画<br />一部庸俗到无聊的電影</p><p>席を立ってからやっと気付く<br />起身离席時我才終于發現</p><p>これは僕を描いたドラマだ<br />劇情所講述的正是我自己的故事啊</p><p>いつか僕らは大人になって<br />我們終将長大成人</p><p>手に入れるものも大きくなった<br />所獲之物也日益重大</p><p>次は愛でも買えればいいのにね<br />接下来要是連愛也能買到就好了呢</p><p>あんたの価値観なんて偽物だ<br />你的価値観全都是虚假的</p><p>思い出だって偽物だ<br />連回憶也全都是虚假的</p><p>心は腦の信号なんだから<br />因為心思不過是大腦傳輸的信号罷了</p><p>愛も皆レプリカだ<br />所有的愛也全都是複製品</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>思い出ばかりが募って<br />只有回憶靜靜堆積</p><p>その時に<br />届時</p><hr /><p>満たされるならそれで良かった<br />只要能感到滿足就好</p><p>歌を歌うのに理由も無いは<br />歌唱并不需要理由</p><p>他人の為に生きられない<br />我不会為他人而活</p><p>さよなら以外全部塵<br />离别以外 全部如塵</p><p>人を呪う歌を描きたい<br />想譜寫出詛咒他人的歌</p><p>それで誰かを殺せればいいぜ<br />若是能借此取人性命就好了</p><p>夏の匂いに胸が詰まっていた<br />夏日的气息郁結滿懷</p><p>僕らの心以外は偽物だ<br />除了我們的心其余皆是虚假的</p><p>言葉以外は偽物だ<br />除了話語其余皆是虚假的</p><p>この世の全部は主観なんだから<br />因為世界全凭主觀而存在啊</p><p>君も皆レプリカだ<br />你也同樣是複製品</p><p>さよならだって投げ出して<br />豁出一切道别离开</p><p>このまま遠く逃げ出して<br />就這樣逃向遠方</p><p>言葉で全部表して<br />用語言来表述一切</p><p>心も愛も書き足して<br />添注上真心与愛</p><p>それでも空は酷く青いんだから<br />因為即便如此 天空仍是无可比擬的蔚藍</p><p>それはきっと魔法だから<br />那一定是魔法</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>冷たくなって年老いて<br />天气轉冷 年華逝去</p><p>その時にやっとわかる<br />届時才終于明白</p><p>僕もその青さがわかる<br />我也懂得那份蔚藍</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>锁相环CD4046使用心得</title>
    <link href="/2024/11/23/%E9%94%81%E7%9B%B8%E7%8E%AFCD4046%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/2024/11/23/%E9%94%81%E7%9B%B8%E7%8E%AFCD4046%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<figure><img src="https://i.imgur.com/ZpUo6qu.jpg" alt="成品" /><figcaption aria-hidden="true">成品</figcaption></figure><h1 id="前言">前言</h1><p>最近在忙着做校队招新的题目，要求是用锁相环CD4046B做一个倍频器，倍频系数为1，2，4，8，16，32，64。这个题最烦人的地方在于覆盖的频率范围很大，输入信号范围是1kHz~100kHz，这样来算输出最大要达到6.4MHz，然而以CD4046B来说这根本不可能，因为这款锁相环上集成的VCO的输出频率最大也就1MHz左右：</p><p><img src="https://i.imgur.com/51pBwa3.png" /></p><p>如你所见，输出最大频率的典型值为<strong>1.4MHz</strong>，这也基本符合我实测的结果。总之这题做满100kHz的64倍频基本是没戏了，但是听说有个组做到了7MHz？搞不懂是什么情况。（再吐槽一句，TI的CD4046B的数据手册真的太古老了啊，赶紧更新一下吧）</p><h1 id="引脚说明">引脚说明</h1><p><img src="https://i.imgur.com/Z91APjn.png" /></p><p>见上图。</p><ul><li>3；鉴相器输入</li><li>4：VCO输出</li><li>6、7之间的<spanclass="math inline">\(C_1\)</span>是VCO的起振电容</li><li>12脚<spanclass="math inline">\(R_2\)</span>决定了输出频率是否叠加一个偏置。如果不接，那么输出无偏置，频率就可以达到比较低的范围；如果接上电阻，频率范围整体会往上移动。</li><li>11脚<spanclass="math inline">\(R_1\)</span>也影响了输出频率·范围，R1越小输出频率越大，我这里取的是10k欧。</li><li>5脚禁止端，低电平使能器件。</li><li>13，鉴相器2的输出，它接入环路滤波器的输入端。</li><li>9，VCO的输入，这个输入电压应当尽可能平稳，这样VCO才会有稳定的输出。</li></ul><p>我这次在调试电路过程中动的最多的就是C1和引脚，4。通过调整C1的值来获得不同的频率输出范围；将3、4直接连接来测试锁相环的功能；确定锁相环能正常工作后再把3、4断开，接入分频器。</p><h1 id="频率范围">频率范围</h1><p>CD4046B的输出频率与供电电压有关，供电电压越大，能够输出的频率也越大，但是不能超过15V。根据我的测试，在5V供电，R2不接，R1=10k欧，C1=100pF的情况下，VCO的输出频率最多只有大约700kHZ。想达到1MHz以上的频率必须增大电压到10V，但是这又会产生一问题：锁相环是10V电平输入输出，而分频器是5V电平，两种电平并不互容，必须进行<strong>电平转换</strong>。这是我们组在昨天得到的结论，然后今天我自己花了半个上午的时间才总算是调好了。为了能够覆盖从1kHz~1MHz的频率范围，我切换了三个电容：</p><table><thead><tr><th>100pF</th><th>4.7nF</th><th>3.3nF</th></tr></thead><tbody><tr><td>41k~1.2M</td><td>2k~40k</td><td>1k~29k</td></tr></tbody></table><p>注意这里的频率应当是<strong>倍频后最终输出的频率</strong>。</p><h1 id="电平转换">电平转换</h1><p>这里的电平转换，具体来说：</p><ul><li>锁相环VCO输出的10V方波要被转换为5V方波</li><li>分频器输出的5V方波要被转换为10V方波</li></ul><p>LTspice仿真结果如下：</p><p><img src="https://i.imgur.com/3vQpjKX.png" /></p><p>高电平转低电平用的是左边那个电路，其实就是一个反相器。需要注意的是上拉电阻R1不要取得太大，不然上升沿过于缓慢，适应不了1MHz。而且这个电路实际测试的时候输出在下降沿的振铃非常大，大概是杂散电容和寄生电感的影响（毕竟是焊接到洞洞板上的）。</p><p>低电平转高电平用的是右边的电路，因为左边的电路这时候就不能用了。</p><h1 id="环路滤波器">环路滤波器</h1><p>这是锁相环相当重要的一环。环路滤波器的职责就是将鉴相器输出的高频分量尽可能地滤干净。网上关于环路滤波器的设计方法资料并不是很多，可以参见该博客：<ahref="https://www.cnblogs.com/qm1412/p/18222379">锁相环学习---CD4046</a></p><p>环路滤波器有专用的设计软件，但是非常古老，必须再下载一个XP系统的虚拟机，非常麻烦，所以我就直接使用博客里设计好的电路了：</p><p><img src="https://i.imgur.com/yCQpeqy.jpg" /></p><p>LTspice仿真得到其幅频响应和相频响应如下：</p><p><img src="https://i.imgur.com/LWBPZIo.png" /></p><p>实测这个滤波器可以用于1kHz~1MHz的范围。</p><h1 id="对vco输出进行整形">对VCO输出进行整形</h1><p>这一步其实并不是必要的，但是我还是使用告诉比较器把输出波形整成好看一点的方波，这主要是因为我所用的10V转5V的电平转换电路上升沿非常慢，以至于方波几乎已经变成锯齿波了，非常难受。</p><p><img src="https://i.imgur.com/NrkVsnV.png" /></p><p>注意我最终电路中VIN是经过电容之后才送入比较器，这样隔离直流分量，比较器容易产生正确的结果。另外R1可以稍微取得大一些，比如500欧，对噪声的抑制能力也会强一些。这个比较器的输出为3.3V、0V，可以直接送入单片机的外部时钟输入引脚用来测量频率。</p><h1 id="总结">总结</h1><p>最后实现的效果如图（输入信号与输出信号稳定同频显示不漂移）只拍了N=1的情况，N=64也能非常稳</p><p><img src="https://i.imgur.com/PvEWWA3.jpg" /></p><p>这次与锁相环有关的电路基本都是我负责的，焊接在一大块洞洞板上，焊锡丝的助焊剂快熏死我了。。。不过好在最后的成品表现非常不错，最大能锁定到1.2MHz的频率，已经接近CD4046B的极限了。另外队友也买了一大堆CD4046B，过几天我想用这些多余的芯片测试一下锁相环的FM解调功能。</p>]]></content>
    
    
    <categories>
      
      <category>电子设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日語中的「くの字点」</title>
    <link href="/2024/10/30/%E6%97%A5%E8%AA%9E%E4%B8%AD%E7%9A%84%E3%80%8C%E3%81%8F%E3%81%AE%E5%AD%97%E7%82%B9%E3%80%8D/"/>
    <url>/2024/10/30/%E6%97%A5%E8%AA%9E%E4%B8%AD%E7%9A%84%E3%80%8C%E3%81%8F%E3%81%AE%E5%AD%97%E7%82%B9%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>最近在青空文庫上閲讀日語圖書的時候發現了這樣一段文字：</p><blockquote><p>表記について<br />このファイルは W3C 勧告 XHTML1.1 にそった形式で作成されています。<br />「くの字点」は「／＼」で表しました。</p></blockquote><p>即：此文件是根据W3C推荐的XHTML1.1格式制作的。'くの字点'用'／＼'表示。</p><p>「くの字点」是什麽？</p><p>我找到了這樣一篇解釋文章：<ahref="https://www.canon-its.co.jp/files/topics/2560_ext_06_0.pdf">https://www.canon-its.co.jp/files/topics/2560_ext_06_0.pdf</a></p><p>所謂'くの字点'，就是在重复两个字以上的假名，或漢字与假名時使用的標記符號。如果在重複時漢字的讀音變爲濁音，那麽くの字点也要相應地加上濁音符號。一個くの字点要占用兩個字節的位置。以下圖爲例：</p><p><img src="https://i.imgur.com/7NyGuQV.png" /></p><p>まあまあー＞まあ／＼ 大致，還算過得去<br />しかじかー＞しか／"＼　云云，等等<br />見る見るー＞見る／＼　眼看著，轉眼間<br />離れ離れー＞離れ／＼　失散</p><p>由於日語文章經常按照縱向排列，因此青空文庫就使用“／＼”來代替這個符號了。</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LTspice中SW元件的使用</title>
    <link href="/2024/10/14/LTspice%E4%B8%ADSW%E5%85%83%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/10/14/LTspice%E4%B8%ADSW%E5%85%83%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>LTspice不像Multisim那样有现成的手动开关。开关功能可以用<strong>S.Voltage Controlled Switch</strong>（压控开关）实现。</p><p><img src="https://i.imgur.com/1EAGN5i.png" /></p><ol type="1"><li>按P键打开元件库，搜索"SW"，放置在图纸中</li><li>插入指令定义SW元件的行为，例如：<code>.model MYSW SW(Ron=1 Roff=1Meg Vt=.5 Vh=-.4)</code>，其中<code>Ron</code>是导通电阻（<strong>导通电阻不能为0！</strong>），<code>Roff</code>为断开电阻，Vt和Vh决定了开关的阈值电压，在本例中为0.9V和0.1V</li><li>将开关模型的名称改成MYSW</li><li>放置一个电压源用来控制开关，这里用的是Pulse，开关在闭合1s后保持关断状态。</li></ol><p>SW相关的所有参数如下表格：</p><table><thead><tr><th style="text-align: center;">Name</th><th style="text-align: center;">Description</th><th style="text-align: center;">Units</th><th style="text-align: center;">default</th></tr></thead><tbody><tr><td style="text-align: center;">Vt</td><td style="text-align: center;">阈值电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Vh</td><td style="text-align: center;">滞后电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Ron</td><td style="text-align: center;">导通电阻</td><td style="text-align: center;">Ω</td><td style="text-align: center;">1.0</td></tr><tr><td style="text-align: center;">Roff</td><td style="text-align: center;">关断电阻</td><td style="text-align: center;">Ω</td><td style="text-align: center;">1/Gmin</td></tr><tr><td style="text-align: center;">Lser</td><td style="text-align: center;">串联电感</td><td style="text-align: center;">H</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Vser</td><td style="text-align: center;">串联电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Ilimit</td><td style="text-align: center;">限制电流</td><td style="text-align: center;">A</td><td style="text-align: center;">Infin.</td></tr></tbody></table><p><strong>该开关根据滞回电压 Vh的值，具有三种不同的电压控制模式:</strong></p><ul><li>如果 Vh为零，开关将始终完全导通或关断，具体取决于输入电压是否超过阈值电压。</li><li>如果 Vh为正值，开关将表现出滞回现象，就像通过施密特触发器控制一样，触发点为 Vt- Vh 和 Vt + Vh。需要注意的是，Vh是触发点之间电压的一半，这与常见的实验室术语有所不同。</li><li>如果 Vh为负值，开关将在导通和关断阻抗之间平滑过渡。过渡发生在控制电压 Vt - Vh和 Vt + Vh 之间，且平滑过渡遵循开关导通行为的对数的低阶多项式拟合。</li></ul><p>平时设Vh为负值就好。</p><p>参考链接：<br /><ahref="https://www.analog.com/cn/resources/technical-articles/ltspiceiv-voltage-controlled-switches.html#:~:text=To%20insert%20and%20configure%20a%20switch%20in%20LTspice%E2%80%A6,this%20example%3A.model%20MYSW%20SW%20%28Ron%3D1%20Roff%3D1Meg%20Vt%3D.5%20Vh%3D-.4%29">LTspice:Voltage Controlled Switches</a></p>]]></content>
    
    
    <categories>
      
      <category>EE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为Fluid主题首页的副标题添加淡入效果</title>
    <link href="/2024/10/04/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E7%9A%84%E5%89%AF%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%B7%A1%E5%85%A5%E6%95%88%E6%9E%9C/"/>
    <url>/2024/10/04/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E7%9A%84%E5%89%AF%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%B7%A1%E5%85%A5%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近又折腾了一下博客的美化。默认Fluid主题的首页副标题用的是打字机特效，不过我不太喜欢，于是琢磨了一下淡入效果。我并没有学过前端，一下代码主要靠chatgpt和其他网友得到。</p><h1 id="过程">过程</h1><p>使用F12打开开发者模式，定位副标题：<br /><img src="https://i.imgur.com/mgjRfJ2.jpg" alt="Imgur" />目标对应的元素为<code>.h2 #subtitle</code>，在外部CSS文件中加入下列代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Si Yuan&quot;</span>;<br>    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;../fonts/Si Yuan.otf&quot;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;truetype&quot;</span>);<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">400</span>;<br>  &#125;<br><br><span class="hljs-selector-class">.h2</span> <span class="hljs-selector-id">#subtitle</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Si Yuan&#x27;</span>, sans-serif; <span class="hljs-comment">/* 替换为你想要的字体 */</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32px</span>; <span class="hljs-comment">/* 调整字体大小 */</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>; <span class="hljs-comment">/* 设置字体颜色 */</span><br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 初始透明度为0，隐藏 */</span><br>    <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">1.5s</span> linear; <span class="hljs-comment">/* 设置过渡效果 */</span><br>  &#125;<br><br><span class="hljs-selector-class">.h2</span> <span class="hljs-selector-id">#subtitle</span><span class="hljs-selector-class">.visible</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 完全可见 */</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>由于这里我使用的是思源宋体，并非系统自带的字体，因此额外使用<code>@font-face</code>引入外来字体。</p><p>另外，注意文章页的标题和首页的标题用的是同一个元素，二者会同时发生变更。</p><p>再向外部js文件中加入下列代码： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> subtitle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;subtitle&#x27;</span>);<br>    subtitle.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;visible&#x27;</span>); <span class="hljs-comment">// 页面加载后添加 visible 类</span><br>&#125;);<br></code></pre></td></tr></table></figure> 完成。</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>雪酷字幕组的特效注释字幕分析</title>
    <link href="/2024/10/02/%E9%9B%AA%E9%85%B7%E5%AD%97%E5%B9%95%E7%BB%84%E7%9A%84%E7%89%B9%E6%95%88%E6%B3%A8%E9%87%8A%E5%AD%97%E5%B9%95%E5%88%86%E6%9E%90/"/>
    <url>/2024/10/02/%E9%9B%AA%E9%85%B7%E5%AD%97%E5%B9%95%E7%BB%84%E7%9A%84%E7%89%B9%E6%95%88%E6%B3%A8%E9%87%8A%E5%AD%97%E5%B9%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>雪酷字幕组在2011至2012年期间与曙光字幕组合作完成了《命运石之门》的翻译工作，这也是我最早看的一个版本，翻译非常贴切自然，并且动漫中出现的流行词汇也都附上了详尽的注释。可惜在2014年之后雪酷字幕组就突然失踪了……这里我想分析一下他们在为《命运石之门》做字幕注释时用到的特效方案，从中窥视那个时代的字幕组对待字幕工作是何等敬业。</p><span id="more"></span><p>以繁体版第10集3:46处的注释为例，ass文件代码如下：</p><pre><code class="hljs">3:46.19~3:51.20     &#123;\move(15,20,15,10,0,200)\pos(15,10)\fad(300, 300)&#125;Blood Tune3:45.90~3:51.41   &#123;\fscx0\pos(15,20)\t(0,200,1,\fscx100)\t(5300,0,1,\fscx0)&#125;————3:46.19~3:51.20   &#123;\move(15,20,15,50,0,200)\pos(15,50)\fad(300, 300)&#125;（架空）ＴＶ動畫『BLOOD TUNE THE ANIMATION』。\N原作是漫畫，隨著多元媒體化的風潮終於在去年動畫化。\N作品被製作成為全２６話的作品，受到了動漫愛好者們的廣泛關注，\N特別是女主角『星來Orujeru』的PVC模型擁有相當高的人氣。</code></pre><p>上面一共用了三段字幕来完成对【BloodTune】的注释。而且，三段字幕分别使用了三种不同大小的字体（在1080p清晰度下）：</p><ol type="1"><li>neta1-微软雅黑，用于注释对象的名称，字号26，边框2，阴影0</li><li>neta2-微软雅黑，用于创造分界线，字号40，边框2，阴影0</li><li>neta3-微软雅黑，用于注释的具体内容，字号28，边框2，阴影0</li></ol><p>实现的效果如图 <imgsrc="https://media.giphy.com/media/EuIDh9scyssnZXBT39/giphy.gif" /></p><p>下面对这三段代码进行逐行分析。</p><h1 id="平滑的文本展示效果">平滑的文本展示效果</h1><p><code>\move</code>用于设置文本的<strong>移动轨迹</strong>，其基本语法是<code>\move(x1,y1,x2,y2,start_time,end_time)</code>，其中<code>(x1,y1)</code>是起始位置，<code>(x2,y2)</code>是结束位置，<code>start_time</code>和<code>end_time</code>定义动画的开始和结束时间（单位：毫秒）。</p><p><code>\pos</code>用于设置文本的<strong>绝对位置</strong>，其语法是(x,y)，其中 x 和 y是屏幕坐标。这个命令将文本固定在指定的位置，不随时间变化。</p><p><code>\fad</code>用于设置文本的<strong>淡入淡出</strong>效果，其基本语法是<code>\fad(fade_in_time, fade_out_time)</code>，其中<code>fade_in_time</code>是淡入持续的时间（毫秒），<code>fade_out_time</code>是淡出持续的时间（毫秒）。</p><p><code>&#123;\move(15,20,15,10,0,200)\pos(15,10)\fad(300, 300)&#125;Blood Tune</code>是一串复合代码，综合以上三点，其作用为：- 文本从屏幕坐标<code>(15, 20)</code>移动到<code>(15, 10)</code>，在 0毫秒时开始，200 毫秒时结束。 -文本运动到<code>(15,10)</code>后会被固定到这个位置。 -在文本开始移动的同时，会附加一个300毫秒的淡入效果，在文本消失时则有300毫秒的淡出效果。</p><h1 id="动态的分界线">动态的分界线</h1><p><code>\fscx</code>用于设置文本的<strong>水平缩放</strong>(<strong>f</strong>ront<strong>sc</strong>ale<strong>x</strong>)，其基本语法是<code>\fscx&lt;value&gt;</code>，其中<code>&lt;value&gt;</code>是缩放的百分比值。例如：</p><ul><li><code>\fscx100</code>表示正常大小</li><li><code>\fscx50</code>表示正常大小的一半</li></ul><p><code>\t</code>用于创建<strong>动画效果</strong>（transformation），从一个样式动画渐变到另外一个。Aegisub手册给出的语法如下：</p><pre><code class="hljs">\t(&lt;style modifiers&gt;)\t(&lt;accel&gt;,&lt;style modifiers&gt;)\t(&lt;t1&gt;,&lt;t2&gt;,&lt;style modifiers&gt;)\t(&lt;t1&gt;,&lt;t2&gt;,&lt;accel&gt;,&lt;style modifiers&gt;)</code></pre><p>本例使用的是第四个。其中<code>&lt;style modifiers&gt;</code>参数是特效标签，<code>accel</code>参数可以让动画效果不再是匀速的，而是满足一条指数曲线。该参数为1时，运动速度是恒定的。参数在0和1之间时，运动速度逐渐变慢。参数大于1时，运动速度越来越快。</p><p>整个代码的运行逻辑可以用下图概括：<br /><img src="https://i.imgur.com/r6Rsdn7.png" /></p>]]></content>
    
    
    <categories>
      
      <category>字幕</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid主题渲染LaTeX数学公式的问题总结</title>
    <link href="/2024/09/15/Hexo%20Fluid%E4%B8%BB%E9%A2%98%E6%B8%B2%E6%9F%93LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2024/09/15/Hexo%20Fluid%E4%B8%BB%E9%A2%98%E6%B8%B2%E6%9F%93LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>在Fluid的<ahref="https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">官方指南文档</a>中已经做了详尽的说明，一步一步跟着做就没问题。值得注意的是，在主题配置的代码</p><pre><code class="hljs">post:math:enable: truespecific: falseengine: mathjax</code></pre><p>中，要想使用数学公式，<code>enable</code>一项必须是<code>true</code>才行，否则会出现渲染错误，比如像下面这样：</p><p><imgsrc="https://github.com/banyee19/blog_images/blob/main/%E4%B8%8D%E5%90%AF%E7%94%A8.jpg?raw=true" /></p><p>同样的公式渲染了一次之后又重复了一次。</p><p>另外，Hexo中无法使用换行符<code>\\</code>，原因是<code>\</code>在Markdown属于特殊字符，用于字符转义，所以两个<code>\</code>经过Markdown引擎处理为html后，只剩下一个，等到LaTex渲染引擎处理时，实际上只看到一个<code>\</code>，渲染引擎把它当作LaTeX 中的空格。</p><p>在不改动现有代码的情况下，我的解决方法是直接改变公式的写法。比如下边这个公式</p><pre><code class="hljs">$$a_11=b_11 \\a_22=b_22+c_22$$</code></pre><p>改为</p><pre><code class="hljs">$$\begin&#123;aligned&#125;a_&#123;11&#125;&amp; =b_&#123;11&#125;\\a_&#123;22&#125;&amp; =b_&#123;22&#125;+c_&#123;22&#125;\end&#123;aligned&#125;$$</code></pre><p>渲染效果如下： <span class="math display">\[\begin{aligned}a_{11}&amp; =b_{11}\\a_{22}&amp; =b_{22}+c_{22}\end{aligned}\]</span> 更复杂的公式同理： <span class="math display">\[\begin{aligned}    F_x&#39;&amp;=\gamma\{q[\frac{-i\gamma}{c}(u_t&#39;+i\betau_x&#39;)E_x+u_y&#39;B_z-u_z&#39;B_y]    +i\beta\frac{iq}{c}[\gamma(u_x&#39;-i\betau_t&#39;)E_x+u_y&#39;E_y+u_z&#39;E_z] \}\\    &amp;=\frac{-iq\gamma^2}{c}(1-\beta^2)E_xu_t&#39;-q\gamma(B_y+\frac{\beta}{c}E_z)u_z&#39;+q\gamma(B_z-\frac{\beta}{c}E_y)u_y&#39;\end{aligned}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序章-新博客的诞生</title>
    <link href="/2024/09/13/hello-world/"/>
    <url>/2024/09/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>新博客建成祝贺！ <span id="more"></span>经过两天的配置，，终于成功用Github把博客搭建出来了！</p><p>其实之前我一直是在博客园上面写博客的（虽然也才刚写了几个月），但是最近博客园的运营情况令人堪忧，可能再过几个月就要被收购了，嘛这样的话到时候博客园大概率要植入广告了，所以索性自己创建一个博客好了。另一方面，我写博客的目的是把自己的想法记录下来，或者分享自己的知识，所以博客园那种类似于论坛式的模式其实并不是很适合我。只要把博文发出来，我就达到目的了，就算没有人看也没关系。</p><p>不出意外的话这个博客应该会长期更新下去。毕竟是自己费了好大的功夫才建出来的嘛（笑）我在生活中并不喜欢和别人交流，周围能和我一起交流喜欢的事物的人几乎没有，但是我还是希望把自己思考的东西分享出来。那干脆就借助博客好了。以后这个博客上会发布各种我感兴趣的内容。</p><p>总之，我宣布，Banyee's Blog从今天开始正式成立了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>初次见面</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
