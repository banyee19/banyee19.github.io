<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MyBatis-缓存</title>
    <link href="/2025/05/20/MyBatis-%E7%BC%93%E5%AD%98/"/>
    <url>/2025/05/20/MyBatis-%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="mybatis的缓存">MyBatis的缓存</h1><p>参考链接：</p><p><ahref="https://tech.meituan.com/2018/01/19/mybatis-cache.html">聊聊MyBatis缓存机制-美团技术团队</a></p><p><ahref="https://itmyhome.com/mybatis-pdf/MyBatis-3-User-Guide-Simplified-Chinese.pdf">MyBatis用户指南</a></p><p><ahref="https://www.cnblogs.com/gavincoder/p/13977037.html">Mybatis深入浅出之缓存机制</a></p><h2 id="一级缓存">一级缓存</h2><h3 id="使用">使用</h3><p>一级缓存默认开启，是sqlSession级别的。同一个 sqlSession对象在执行查询时，如果执行过相同的 SQL 且参数也一样，MyBatis会将结果缓存起来，后续再查相同内容时直接从缓存中取，而不是再访问数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><br><span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> session.selectOne(<span class="hljs-string">&quot;getUserById&quot;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> session.selectOne(<span class="hljs-string">&quot;getUserById&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><code>u1</code>正常查询数据库，<code>u2</code>直接从一级缓存中读取查询过的数据。</p><figure><img src="https://s21.ax1x.com/2025/05/20/pExKhgx.png"alt="一级缓存流程图" /><figcaption aria-hidden="true">一级缓存流程图</figcaption></figure><p>每个SqlSession中持有Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在LocalCache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入LocalCache，最后返回结果给用户。</p><!-- ![一级缓存时序图](https://s21.ax1x.com/2025/05/20/pExKIKK.jpg) --><h3 id="失效">失效</h3><p>一级缓存不是永久有效的，它在以下几种情况下会失效：</p><ol type="1"><li>不同的sqlSession。<strong>每个sqlSession都有自己的一级缓存</strong>，互不影响，不同的session不会共享缓存。</li><li>执行了增删改操作。这些操作可能会修改数据，为了保证数据的一致性，MyBatis会清除缓存。不管是否真的改动了数据库、也不管是否提交事务，一级缓存都会被清除。</li><li>手动清除缓存，调用<code>session.clearCache()</code>清除一级缓存。</li><li>同一条SQL但是查询参数不同。</li></ol><p><strong>手动清除缓存测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> userMapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(student);<br>    sqlSession.clearCache();<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> userMapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(student2);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: SELECT * FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: id, class_id, name, gender, score<br>TRACE [main] - &lt;==        Row: 1, 1, 小明, F, 100<br>DEBUG [main] - &lt;==      Total: 1<br>Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br>DEBUG [main] - ==&gt;  Preparing: SELECT * FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: id, class_id, name, gender, score<br>TRACE [main] - &lt;==        Row: 1, 1, 小明, F, 100<br>DEBUG [main] - &lt;==      Total: 1<br>Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br></code></pre></td></tr></table></figure><p>因为两次查询之间手动清除了缓存，所以第二次查询的时候仍然要连接数据库，发送sql语句至数据库进行查询。</p><p><strong>增删改清除缓存测试</strong></p><p>单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> userMapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;第一次查询：&quot;</span> + student);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.deleteStudentById(<span class="hljs-number">12</span>);<br><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> userMapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;第二次查询：&quot;</span> + student2);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: SELECT * FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: id, class_id, name, gender, score<br>TRACE [main] - &lt;==        Row: 1, 1, 小明, F, 100<br>DEBUG [main] - &lt;==      Total: 1<br>第一次查询：Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br>DEBUG [main] - ==&gt;  Preparing: DELETE FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 12(Integer)<br>DEBUG [main] - &lt;==    Updates: 1<br>DEBUG [main] - ==&gt;  Preparing: SELECT * FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: id, class_id, name, gender, score<br>TRACE [main] - &lt;==        Row: 1, 1, 小明, F, 100<br>DEBUG [main] - &lt;==      Total: 1<br>第二次查询：Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br></code></pre></td></tr></table></figure><p>可以清楚地看到，虽然删除操作并没有被提交，但是第二次查询还是要重新连接数据库。</p><h2 id="二级缓存">二级缓存</h2><p>一级缓存是 <strong>SqlSession</strong> 级别的缓存，每个 SqlSession拥有自己的缓存。</p><p>二级缓存是 <strong>namespace</strong>级别的缓存，<strong>它是可以被多个 SqlSession共享的缓存</strong>。因为一个Mapper映射配置文件往往对应一个namespace，所以也可以说它是 <strong>Mapper</strong> 级别的缓存。</p><figure><img src="https://s21.ax1x.com/2025/05/20/pExM3GR.png"alt="二级缓存流程图" /><figcaption aria-hidden="true">二级缓存流程图</figcaption></figure><p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</p><p>当开启二级缓存后，数据的查询执行的流程就是<code>二级缓存 -&gt; 一级缓存 -&gt; 数据库</code>，更新执行顺序：<code>数据库-&gt;一级缓存-&gt;二级缓存</code>。</p><h3 id="二级缓存配置">二级缓存配置</h3><p>MyBatis默认情况下只开启局部的session 缓存，二级缓存需要手动开启。</p><ol type="1"><li>在<code>&lt;setting&gt;</code>标签中设置<code>cacheEnabled</code>属性的值为<code>true</code>;</li><li>在MyBatis的映射XML中配置cache：<code>&lt;cache/&gt;</code>;</li><li>二级缓存必须在sqlSession关闭或提交后才有效；</li><li>查询数据所转换的实体数据类型必须实现序列化接口<code>Serializable</code>。</li></ol><p>完成上述配置之后，查询语句会默认使用缓存。效果如下：</p><ul><li>XML映射语句文件中的所有<code>select</code>都会被缓存，所有增删改关键字都会刷新缓存。</li><li>缓存会使用<ahref="https://leetcode.cn/problems/lru-cache/">LRU算法</a>来收回。</li><li>缓存没有刷新间隔，不会根据时间自动刷新。</li></ul><p>二级缓存依赖于一级缓存，<code>sqlSession.close()</code>执行完，Mybatis会将一级缓存对象拷贝存储到二级缓存，然后二级缓存才会起作用。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1. 加载配置</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br><br>    <span class="hljs-comment">// 2. 创建两个 sqlSession 进行数据库操作</span><br><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession1</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession2</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><br>    <span class="hljs-type">CacheMapper</span> <span class="hljs-variable">sqlSession1Mapper</span> <span class="hljs-operator">=</span> sqlSession1.getMapper(CacheMapper.class);<br>    <span class="hljs-type">CacheMapper</span> <span class="hljs-variable">sqlSession2Mapper</span> <span class="hljs-operator">=</span> sqlSession2.getMapper(CacheMapper.class);<br><br>    <span class="hljs-comment">// 第一次查询</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> sqlSession1Mapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(s1);<br>    <span class="hljs-comment">// 关闭一级缓存,将数据从内存存储到硬盘</span><br>    sqlSession1.close();<br>    <span class="hljs-comment">// 第二次查询，相同 namespace 下查询，二级缓存命中</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> sqlSession2Mapper.getStudentById(<span class="hljs-number">1</span>);<br>    System.out.println(s2);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - Cache Hit Ratio [com.kzn.mapper.CacheMapper]: 0.0<br>DEBUG [main] - ==&gt;  Preparing: SELECT * FROM students WHERE id = ?;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: id, class_id, name, gender, score<br>TRACE [main] - &lt;==        Row: 1, 1, 小明, F, 100<br>DEBUG [main] - &lt;==      Total: 1<br>Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br> WARN [main] - As you are using functionality that deserializes object streams, it is recommended to define the JEP-290 serial filter. Please refer to https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;id=GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66<br>DEBUG [main] - Cache Hit Ratio [com.kzn.mapper.CacheMapper]: 0.5<br>Student&#123;id=1, class_id=1, name=&#x27;小明&#x27;, gender=&#x27;F&#x27;, score=100&#125;<br></code></pre></td></tr></table></figure><p>第二次查询使用了缓存，缓存命中率0.5.</p><p>注意：</p><ul><li><strong>二级缓存依赖于一级缓存写入</strong>，不关闭sqlSession1，不会写入当前namespace的二级缓存，造成二级缓存失效。</li><li>Mybatis二级缓存对象存储在<strong>硬盘</strong>中，因此需要namespace下实体对象序列化，如果不序列话运行会报错。</li></ul>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-结果映射（resultMap）详解</title>
    <link href="/2025/05/18/MyBatis-%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/"/>
    <url>/2025/05/18/MyBatis-%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1id="mybatis-结果映射resultmap详解">MyBatis-结果映射（resultMap）详解</h1><h2 id="前言">前言</h2><p>看MyBatis网课的时候这一部分把我听红温了，遂自己梳理。</p><p>resultMap的作用是什么？如果JavaBean的属性名和数据库中的列名（字段名）刚好一一对应并且名字也相同，那么就不需要什么映射关系了，可以直接通过SQL查询出表中的所有信息。但是事实往往没那么理想，很多情况下这两个的名字并不相同，甚至不存在一一对应的关系；而且我们可能并不满足于仅查询一张表，而是要把两张表的关键信息合在一起。不管是那种情况，都需要手动处理映射关系。</p><h2 id="目录">目录</h2><ol type="1"><li><ahref="#mybatis的结果映射resultmap详解">MyBatis的结果映射（resultMap）详解</a><ol type="1"><li><a href="#前言">前言</a></li><li><a href="#目录">目录</a></li><li><a href="#resultmap">resultMap</a></li><li><a href="#id和result">id和result</a></li><li><a href="#constructor">constructor</a><ol type="1"><li><a href="#为什么需要构造方法">为什么需要构造方法</a></li><li><a href="#用法">用法</a></li></ol></li><li><a href="#association">association</a><ol type="1"><li><a href="#嵌套-select-查询按需加载">嵌套 Select 查询（按需加载）</a><ol type="1"><li><a href="#概念">概念</a></li><li><a href="#实战">实战</a></li><li><a href="#反思">反思</a></li></ol></li><li><a href="#嵌套结果映射">嵌套结果映射</a></li></ol></li><li><a href="#resultset">resultSet</a></li></ol></li></ol><h2 id="resultmap">resultMap</h2><p>一个映射关系由<code>&lt;resultMap&gt;</code>标签包裹，而这个标签本身也有它的属性：</p><ul><li><code>id</code>: <code>resultMap</code>标签的唯一标识。</li><li><code>type</code>: 返回值的 Java全限定类名，或类型别名（在已经处理好别名的情况下）。</li><li><code>autoMapping</code>: MyBatis 用来控制是否自动映射数据库字段到Java 对象属性的开关。<code>autoMapping="true"</code>时，MyBatis会自动匹配列名与属性名相同的字段。匹配规则：<ul><li>数据库的列名与 Java的属性名匹配（忽略大小写、支持下划线转驼峰）；</li><li>没有被<code>&lt;result&gt;</code>明确指定</li><li>必须依赖<code>&lt;setting&gt;</code>中的全局配置项：<code>&lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;</code></li></ul></li></ul><h2 id="id和result">id和result</h2><blockquote><p>id 和 result 元素都将一个列的值映射到一个简单数据类型（String, int,double, Date 等）的属性或字段。</p></blockquote><p>两个元素的常用属性有：</p><ul><li><code>property</code>: 映射到列结果的字段或属性。如果 JavaBean有这个名字的属性（property），会先使用该属性。可以理解为“Java的实体类的属性”。<ul><li><code>id</code>元素的<code>property</code>往往取表中的主键对应的Java1实体类的属性名，例如<code>&lt;id property="id" column="user_id" /&gt;</code>意思就是表的主键名字是<code>user_id</code>，与之对应的Java属性名为<code>id</code>。</li><li><code>result</code>元素的<code>property</code>用来定义其他普通元素和表中的列的一一对应的映射关系。</li></ul></li><li><code>column</code>：已经存在的数据库中的列名，如果有别名的话也可以是别名。</li><li><code>javaType</code>:Java类的全限定名，对于内置的类型别名，如<code>java.lang.String</code>，可以写为<code>String</code>。如果映射到一个JavaBean，MyBatis 通常可以推断类型，此项忽略不写。</li></ul><p>简而言之，<code>id</code>用于设置主键字段与领域模型属性的映射关系，<code>result</code>用于设置普通字段与领域模型属性的映射关系。</p><h2 id="constructor">constructor</h2><h3 id="为什么需要构造方法">为什么需要构造方法</h3><p>首先明确一点，当我们执行查询操作的时候，MyBatis不会直接返回数据库原始数据，它会把查询结果“映射”成<strong>Java对象</strong>返回给你。例如，<code>SELECT id, name FROM user;</code>这一sql语句，如果在MySQL中直接运行，返回的是一张表格，但你总不能让Java 返回原始的 SQL 表格吧？你希望得到的是<strong>Java对象</strong>，对应下面的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = userMapper.selectAll();<br></code></pre></td></tr></table></figure><p>MyBatis 会把那张表的每一行构造成一个 User 对象，然后放到 List里返回。</p><p>对于一般的可变对象，JavaBean会提供一个<code>setter</code>方法，有了这个方法之后事情就很好办了，只需要这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>u.setId(<span class="hljs-number">1</span>);<br>u.setName(<span class="hljs-string">&quot;Alice&quot;</span>);<br></code></pre></td></tr></table></figure><p>MyBatis 先通过空参构造器构建一个<code>User</code>对象，然后通过setter 为这个对象一一赋值。</p><p>但是，有时我们希望一个类的对象一旦创建就不能更改（即不可变类），例如用户的id ，名字和年龄在特定时间段内是固定不变的，那么 JavaBean 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 全参构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, String username, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-comment">// 没有 setter 方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这时想给对象的属性赋值，最直接的一种方式就是使用构造函数，在初始化的时候就赋好值。</p><p>因为 MyBatis 不能像原来一样调用 setter来赋值，所以需要使用构造函数赋值。顺便一提，“赋值”这个操作也被称为<strong>注入</strong>(injection)，比如官方文档是这样说的：</p><blockquote><p>MyBatis 也支持私有属性和私有 JavaBean属性来完成注入，但有一些人更青睐于通过构造方法进行注入。</p></blockquote><p>这谁看得懂啊？这句话的意思其实就是：<em>MyBatis也可以通过反射直接修改私有字段的值，但这不总是最好的做法。很多程序员更喜欢只允许通过构造函数设置属性值</em>。</p><p>上面提到，MyBatis也可以通过反射直接注入私有字段，不过有些程序员还是喜欢使用构造方法达成目的，而<code>constructor</code>就是为此而生的。</p><h3 id="用法">用法</h3><p>假设我们的数据库中的字段为：user_id, user_name, user_age。</p><p>先把<code>User</code>需要用到的方法补充完整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-type">int</span> id,</span><br><span class="hljs-params">                <span class="hljs-meta">@Param(&quot;username&quot;)</span> String username,</span><br><span class="hljs-params">                <span class="hljs-meta">@Param(&quot;age&quot;)</span> <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// getter 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> id; &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> username; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> age; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mapper接口：<code>User selectUserById(int id);</code></p><p>然后为上面那个<code>User</code>写一个XML映射吧：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 构造器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">idArg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_age&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    SELECT user_id, user_name, user_age FROM users WHERE user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>column=数据库字段名</code><br /></li><li><code>name=构造器参数名</code></li><li><code>idArg</code>是主键，<code>arg</code>是普通字段</li><li>因为我们在接口中使用<code>@Param</code>显式为参数起名，所以<code>&lt;constructor&gt;</code>内部的顺序可以是任意的。</li></ul><h2 id="association">association</h2><p>关联（association）元素处理一对一类型的关系。MyBatis有两种不同的方式加载关联：</p><h3 id="嵌套-select-查询按需加载">嵌套 Select 查询（按需加载）</h3><h4 id="概念">概念</h4><ul><li>嵌套 Select查询：也叫<strong>延迟加载</strong>、<strong>按需加载</strong>。它是通过调用另一个SQL 映射语句，来加载关联对象的。</li></ul><p><strong>嵌套Select查询的特点</strong>：按需加载，也就是“懒汉式”；执行效率稍慢。</p><p>假如我们现在有两个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">users(id, name, dept_id)<br>departments(id, dept_name)<br></code></pre></td></tr></table></figure><p>Java对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    Department dept;  <span class="hljs-comment">// 关联属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假如我们定义一个<code>selectAllById</code>方法<code>User selectAllById(Integer id)</code>，User的前两个属性都是基本数据类型，查询起来很简单。但是<code>dept</code>属于引用类型，<strong>MyBatis不会自动填充这种关联字段</strong>，除非我显式地配置了关联查询。</p><p>按照嵌套 Select查询的思路，我们可以在映射关系中将<code>dept</code>属性和<code>selectDeptById</code>方法关联起来，需要查询时就调用<code>selectDeptById</code>部门查询语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 定义映射关系 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Department&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectDeptById&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 部门查询语句 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDeptById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Department&quot;</span>&gt;</span><br>  SELECT id, dept_name AS deptName<br>  FROM departments<br>  WHERE id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>javaType</code>用于修饰<code>dept</code>属性，指定该属性的数据类型；</li><li><code>select</code>指定关联的是查询方法，且方法名为<code>selectDeptById</code>，意思就是<code>dept</code>这个属性是靠这个查询语句查出来的。</li><li><code>column</code>为数据库中的列名，这里表示将数据库中的这一字段作为参数<strong>传递</strong>给<code>selectDeptById</code>语句，由<code>#&#123;id&#125;</code>接收。<code>column</code>往往是多个表共有的列。</li></ul><p>然后利用<code>resultMap</code>定义查询语句就OK：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>SELECT * FROM users WHERE id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样依赖调用<code>selectAllById</code>就能获取用户的所有信息了。</p><h4 id="实战">实战</h4><p>好了下面是实战环节🥰</p><p>现在我的数据库中有两张表：</p><ul><li>sys_user</li></ul><table><thead><tr><th>uid</th><th>username</th><th>user_pwd</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>114411</td></tr><tr><td>2</td><td>测试</td><td>111</td></tr><tr><td>3</td><td>CowBoy</td><td>2233</td></tr></tbody></table><ul><li>sys_schedule</li></ul><table><thead><tr><th>id</th><th>uid</th><th>title</th><th>completed</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>学习Java</td><td>0</td></tr><tr><td>2</td><td>2</td><td>吃饭</td><td>1</td></tr></tbody></table><p>目标：写一个查询语句，能够把所有用户本身的属性及其对应的事务一次性查询出来。</p><p>根据两张表的字段名，定义两个Java类：</p><ul><li><code>User.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer uid;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String user_pwd;<br><br>    <span class="hljs-keyword">private</span> Schedule schedule;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(Integer uid, String username, String user_pwd)</span> &#123;<br>        <span class="hljs-built_in">this</span>.uid = uid;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.user_pwd = user_pwd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, String user_pwd)</span> &#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.user_pwd = user_pwd;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;uid=&quot;</span> + uid +<br>                <span class="hljs-string">&quot;, username=&#x27;&quot;</span> + username + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, user_pwd=&#x27;&quot;</span> + user_pwd + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, schedule=&quot;</span> + schedule +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>schedule.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Schedule</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer sid;<br>    <span class="hljs-keyword">private</span> Integer uid;<br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> Integer completed;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Schedule</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Schedule&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;sid=&quot;</span> + sid +<br>                <span class="hljs-string">&quot;, uid=&quot;</span> + uid +<br>                <span class="hljs-string">&quot;, title=&#x27;&quot;</span> + title + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, completed=&quot;</span> + completed +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面开始考虑接口。</p><p><code>sys_user</code>记录了每一个用户的信息，<code>sys_schedule</code>记录了用户的事务，两张表通过主键<code>uid</code>关联起来。现在的目标是：写一个查询语句，能够把所有用户的所有自带属性及其对应的事务一次性查询出来。编写接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 打印所有的用户及其对应的日程</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 包含所有属性的用户实体类</span><br><span class="hljs-comment"> */</span><br>List&lt;User&gt; <span class="hljs-title function_">getAllUserAndSchedule</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>既然要查询日程，那就少不了查询日程的方法，所以在<code>ScheduleMapper.java</code>添加接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduleMapper</span> &#123;<br>    <span class="hljs-comment">// 根据uid查询用户的事务</span><br>    Schedule <span class="hljs-title function_">getScheduleByUid</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;uid&quot;)</span> Integer uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>OK下面可以配置XML了。先从最简单的日程的查询开始，在<code>ScheduleMapper.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Schedule getScheduleByUid(Integer uid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getScheduleByUid&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Schedule&quot;</span>&gt;</span><br>    SELECT *<br>    FROM sys_schedule<br>    WHERE uid = #&#123;uid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是很简单的根据<code>uid</code>查询指定日程的sql语句。</p><p>接下来在<code>UserMapper.xml</code>配置映射关系和查询语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--获取所有的用户及其实体类，测试associate标签--&gt;</span><br><span class="hljs-comment">&lt;!--  User getAllUserAndSchedule();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ScheduleAndUser&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;schedule&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.kzn.mapper.ScheduleMapper.getScheduleByUid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserAndSchedule&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;ScheduleAndUser&quot;</span>&gt;</span><br>    SELECT * FROM sys_user LIMIT 3<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：因为在映射关系中引用的<code>getScheduleByUid</code>方法的XML配置位于另一个XML文件中，所以这里对该方法的引用要使用<code>全类名.方法名</code>的形式。</p><p>所有的代码都准备完毕之后就可以测试了。准备单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetUserAndSchedule</span><span class="hljs-params">()</span> &#123;<br>    List&lt;User&gt; allUserAndSchedule = userMapper.getAllUserAndSchedule();<br>    allUserAndSchedule.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果（附带日志功能，这里我手动加了空行方便阅读）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: SELECT * FROM sys_user LIMIT 3<br>DEBUG [main] - ==&gt; Parameters: <br>TRACE [main] - &lt;==    Columns: uid, username, user_pwd<br>TRACE [main] - &lt;==        Row: 1, zhangsan, 114411<br>DEBUG [main] - ====&gt;  Preparing: SELECT * FROM sys_schedule WHERE uid = ?<br>DEBUG [main] - ====&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;====    Columns: sid, uid, title, completed<br>TRACE [main] - &lt;====        Row: 1, 1, 学习Java, 0<br>DEBUG [main] - &lt;====      Total: 1<br><br>TRACE [main] - &lt;==        Row: 2, 测试, 111<br>DEBUG [main] - ====&gt;  Preparing: SELECT * FROM sys_schedule WHERE uid = ?<br>DEBUG [main] - ====&gt; Parameters: 2(Integer)<br>TRACE [main] - &lt;====    Columns: sid, uid, title, completed<br>TRACE [main] - &lt;====        Row: 2, 2, 吃饭, 1<br>DEBUG [main] - &lt;====      Total: 1<br><br>TRACE [main] - &lt;==        Row: 3, CowBoy, 2233<br>DEBUG [main] - ====&gt;  Preparing: SELECT * FROM sys_schedule WHERE uid = ?<br>DEBUG [main] - ====&gt; Parameters: 3(Integer)<br>DEBUG [main] - &lt;====      Total: 0<br>DEBUG [main] - &lt;==      Total: 3<br><br>User&#123;uid=1, username=&#x27;zhangsan&#x27;, user_pwd=&#x27;114411&#x27;, schedule=Schedule&#123;sid=1, uid=1, title=&#x27;学习Java&#x27;, completed=0&#125;&#125;<br>User&#123;uid=2, username=&#x27;测试&#x27;, user_pwd=&#x27;111&#x27;, schedule=Schedule&#123;sid=2, uid=2, title=&#x27;吃饭&#x27;, completed=1&#125;&#125;<br>User&#123;uid=3, username=&#x27;CowBoy&#x27;, user_pwd=&#x27;2233&#x27;, schedule=null&#125;<br></code></pre></td></tr></table></figure><p>从日志中可以直观地发现一共执行了4次查询操作（每一组<code>==&gt;</code>都对应一次查询请求）。</p><h4 id="反思">反思</h4><p>嵌套 Select的复用性更很好，结构也很清晰，方便维护，但是它会导致所谓的<strong>N+1查询问题</strong>，结合上面的例子就很好说明：</p><ul><li><code>1</code>，指的是操作者调用了一次查询语句<code>getAllUserAndSchedule</code>，操作者期望一次返回所有的用户及其日程</li><li><code>N</code>，为了完成<code>getAllUserAndSchedule</code>的查询命令，对于N个用户，MyBatis一共需要调用N次<code>getScheduleByUid</code>查询语句以获取日程信息。</li></ul><p>宏观调用的一次加上MyBatis内部调用的N次，合起来就是N+1次。显然，这个问题会导致成百上千的SQL 语句被执行，效率是非常低下的。</p><blockquote><p>好消息是，MyBatis能够对这样的查询进行<strong>延迟加载</strong>，因此可以将大量语句同时运行的开销分散开来。然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。</p></blockquote><p>所以还有另外一种方法——<strong>嵌套结果映射</strong>。</p><h3 id="嵌套结果映射">嵌套结果映射</h3><ul><li>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。</li></ul><p>嵌套结果映射的查询方式本质上还是MySQL的<ahref="/2025/05/06/MySQL基本使用/#多表查询联结表">多表查询</a>。仍然以上面的情况为例，要把用户的基本信息和日程放在一起并且保证用户的信息一个不少，那不就是外部链接查询吗：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.uid, user.Username, schedule.title<br><span class="hljs-keyword">FROM</span> sys_user <span class="hljs-keyword">AS</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> sys_schedule <span class="hljs-keyword">AS</span> schedule<br><span class="hljs-keyword">ON</span> schedule.uid <span class="hljs-operator">=</span> user.uid<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.uid<br>LIMIT <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>（这是利用ORDER BY是因为不这样做的话输出会乱序）</p><p>所以只要把剩下的xml配置做好就行了，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--嵌套映射方式--&gt;</span><br><span class="hljs-comment">&lt;!--List&lt;User&gt; getAllUserAndSchedule_mapping();--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ScheduleAndUserMapping&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--第三列使用映射解决--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;schedule&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--把表中的title字段映射到Schedule的title属性--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;title&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllUserAndSchedule_mapping&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;ScheduleAndUserMapping&quot;</span>&gt;</span><br>    SELECT user.uid, user.Username, schedule.title<br>    FROM sys_user AS user<br>    LEFT JOIN sys_schedule AS schedule<br>    ON schedule.uid = user.uid<br>    ORDER BY user.uid<br>    LIMIT 3<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: SELECT user.uid, user.Username, schedule.title FROM sys_user AS user LEFT JOIN sys_schedule AS schedule ON schedule.uid = user.uid ORDER BY user.uid LIMIT 3<br>DEBUG [main] - ==&gt; Parameters: <br>TRACE [main] - &lt;==    Columns: uid, Username, title<br>TRACE [main] - &lt;==        Row: 1, zhangsan, 学习Java<br>TRACE [main] - &lt;==        Row: 2, 测试, 吃饭<br>TRACE [main] - &lt;==        Row: 3, CowBoy, null<br>DEBUG [main] - &lt;==      Total: 3<br><br>User&#123;uid=1, username=&#x27;zhangsan&#x27;, user_pwd=&#x27;null&#x27;, schedule=Schedule&#123;sid=null, uid=null, title=&#x27;学习Java&#x27;, completed=null&#125;&#125;<br>User&#123;uid=2, username=&#x27;测试&#x27;, user_pwd=&#x27;null&#x27;, schedule=Schedule&#123;sid=null, uid=null, title=&#x27;吃饭&#x27;, completed=null&#125;&#125;<br>User&#123;uid=3, username=&#x27;CowBoy&#x27;, user_pwd=&#x27;null&#x27;, schedule=null&#125;<br></code></pre></td></tr></table></figure><p>查询出的数据只有三列：uid, username,title，没有查询的数据均显示为null，这样只查询了必要的数据。</p><p>而且，从日志可以发现全程只执行了一次查询操作，大大提高执行的效率。</p><h2 id="resultset">resultSet</h2><div class="note note-secondary">            <p>某些数据库允许存储过程返回多个结果集(resultSet)，或一次性执行多个语句，每个语句返回一个结果集。我们可以利用这个特性，在不使用连接的情况下，只访问数据库一次就能获得相关数据。</p>          </div><p>比如，下面这个存储过程一次性执行了用户基本信息的查询和日程的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> get_student_by_id (<br>    <span class="hljs-keyword">IN</span> p_uid <span class="hljs-type">INT</span><br>)<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys_user <span class="hljs-keyword">WHERE</span> uid <span class="hljs-operator">=</span> p_uid;<br>    <span class="hljs-keyword">SELECT</span> uid, title, completed <span class="hljs-keyword">FROM</span> sys_schedule <span class="hljs-keyword">WHERE</span> uid <span class="hljs-operator">=</span> p_uid;<br><span class="hljs-keyword">END</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>在DBeaver中调用这个存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&#123; <span class="hljs-keyword">CALL</span> schedule_system.get_student_by_id(<span class="hljs-number">1</span>) &#125;<br></code></pre></td></tr></table></figure><p>得到下面的结果：</p><figure><img src="https://s21.ax1x.com/2025/05/19/pEvL4Cq.png" alt="第一张表" /><figcaption aria-hidden="true">第一张表</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/05/19/pEvLbb4.png" alt="第二张表" /><figcaption aria-hidden="true">第二张表</figcaption></figure><p>这是两张独立的表，也就是两个<strong>结果集</strong>。</p><p>我们要考虑的是如何用MyBatis完成对存储过程的调用，以及调用完成之后如何使用这两个结果集。这样做的目的是<strong>避免使用连接查询</strong>，改用“多个独立结果集”，来减少数据库的负担。</p><hr /><p>定义以下接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">getUserByResultSet</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;uid&quot;)</span> Integer uid)</span>;<br></code></pre></td></tr></table></figure><p>数据库中已经有存储过程<code>get_student_by_id(IN p_uid INT)</code>，想要使用这个存储过程，映射语句如下；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--通过结果集查询--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByResultSet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--定义第一个结果集--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;user_pwd&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_pwd&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--定义第二个结果集--&gt;</span><br>    <span class="hljs-comment">&lt;!--column 表示第一个结果集中的字段（通常是主表字段），</span><br><span class="hljs-comment">         foreignColumn 表示第二个结果集中的字段（通常是子表字段）。--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;schedule&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Schedule&quot;</span> <span class="hljs-attr">resultSet</span>=<span class="hljs-string">&quot;resultSet2&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">foreignColumn</span>=<span class="hljs-string">&quot;uid&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--这里必须和存储过程的第二个语句完全对应--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;title&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;completed&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;completed&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--getUserByResultSet--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByResultSet&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;selectByResultSet&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;CALLABLE&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">resultSets</span>=<span class="hljs-string">&quot;resultSet1,resultSet2&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--#&#123;传入参数名, jdbcType=类型, mode=模式&#125;--&gt;</span><br>    &#123;CALL get_student_by_id(#&#123;uid, jdbcType=INTEGER, mode=IN&#125;)&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>几个注意点：</p><ul><li><code>association</code>的<code>column</code>表示<strong>主结果集</strong>（父结果集，也就是第一个结果集<code>sys_user</code>表）中的字段，<code>foreignColumn</code>表示<strong>关联结果集</strong>（子结果集，比如<code>sys_schedule</code>表）中的字段匹配。</li><li><code>resultSets</code>结果集的命名默认为<code>resultSet1, resultSet2, ...</code>，这里没有起别名，直接用默认的了</li></ul><p>然后测试输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: &#123;CALL get_student_by_id(?)&#125;<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: uid, username, user_pwd<br>TRACE [main] - &lt;==        Row: 1, zhangsan, 114411<br>DEBUG [main] - &lt;==      Total: 1<br>TRACE [main] - &lt;==    Columns: uid, title, completed<br>TRACE [main] - &lt;==        Row: 1, 学习Java, 0<br>DEBUG [main] - &lt;==      Total: 1<br>DEBUG [main] - &lt;==    Updates: 0<br>User&#123;uid=1, username=&#x27;zhangsan&#x27;, user_pwd=&#x27;114411&#x27;, schedule=Schedule&#123;sid=null, uid=1, title=&#x27;学习Java&#x27;, completed=0&#125;&#125;<br></code></pre></td></tr></table></figure><p>因为这里没有查询<code>sid</code>，所以显示为null。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb开发（二）</title>
    <link href="/2025/05/14/Tomcat2/"/>
    <url>/2025/05/14/Tomcat2/</url>
    
    <content type="html"><![CDATA[<p>完结篇？</p><h1 id="mvc-架构模式">MVC 架构模式</h1><p>MVC(Model ViewController)是一种软件架构模式，将软件系统分为模型、视图和控制器三个部分，对应业务逻辑、数据和显示界面。</p><figure><img src="https://s21.ax1x.com/2025/05/10/pEOh3j0.png"alt="MVC的含义" /><figcaption aria-hidden="true">MVC的含义</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/05/11/pEOvr7j.png" alt="MVC实例" /><figcaption aria-hidden="true">MVC实例</figcaption></figure><p><strong>DAO</strong>（Data AccessObject）层又称“持久层”或“数据访问层”，作用是封装所有对数据库的访问逻辑、将数据库操作（增删改查）与业务逻辑彻底分离提供一组接口，让上层（Service层）只需调用接口方法，无需关心底层如何与数据库交互。<strong>DAO层一般需要定义接口和实现类</strong>。</p><p><strong>POJO</strong>是 Plain Old Java Object 的缩写，意思是“普通的Java对象”。它通常指不依赖任何框架或特殊类继承/注解的、只包含属性、构造方法、Getter/Setter、toString()等基本方法的实体类。</p><p>POJO的实体类的基本要求：</p><ol type="1"><li>类名和表格名称应该对应</li><li>类的字段名和表格的列名应该对应</li><li>每个字段必须是私有的</li><li>每个属性都应该具备 getter setter</li><li>必须具备无参构造器</li><li>应该事先序列化接口（缓存、分布式项目数据传递，可能会将对象序列化）</li><li>应该重写类的<code>hashcode</code>和<code>equals</code> 方法</li><li><code>toString</code> 是否重写都可</li></ol><h2 id="lombok">lombok</h2><p>一个小工具，可以通过注解的形式把 getter setterhashcode等模板方法直接补全。详见<ahref="https://objectcomputing.com/resources/publications/sett/january-2010-reducing-boilerplate-code-with-project-lombok">lombok官方指南</a>。</p><p><strong>数据类相关：</strong></p><table><thead><tr><th>注解</th><th>功能</th></tr></thead><tbody><tr><td><code>@Getter</code></td><td>自动为所有字段生成 <code>getXxx()</code> 方法</td></tr><tr><td><code>@Setter</code></td><td>自动为所有字段生成 <code>setXxx()</code> 方法</td></tr><tr><td><code>@ToString</code></td><td>自动生成 <code>toString()</code> 方法</td></tr><tr><td><code>@EqualsAndHashCode</code></td><td>自动生成 <code>equals()</code> 和 <code>hashCode()</code> 方法</td></tr><tr><td><code>@Data</code></td><td>综合注解，包含<code>@Getter</code>、<code>@Setter</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code>和 <code>@RequiredArgsConstructor</code>（对于 <code>final</code>字段）</td></tr></tbody></table><p><strong>构造器相关：</strong></p><table><thead><tr><th>注解</th><th>功能</th></tr></thead><tbody><tr><td><code>@NoArgsConstructor</code></td><td>生成无参构造函数</td></tr><tr><td><code>@AllArgsConstructor</code></td><td>生成包含所有字段的构造函数</td></tr><tr><td><code>@RequiredArgsConstructor</code></td><td>生成包含所有 <code>final</code> 字段或带 <code>@NonNull</code>字段的构造函数</td></tr></tbody></table><p><strong>构建器模式:</strong></p><table><thead><tr><th>注解</th><th>功能</th></tr></thead><tbody><tr><td><code>@Builder</code></td><td>提供链式构建对象方式</td></tr><tr><td><code>@Singular</code></td><td>与 <code>@Builder</code>配合，用于集合字段构建时避免重复添加逻辑</td></tr></tbody></table><p><strong>其他实用注解:</strong></p><table><thead><tr><th>注解</th><th>功能</th></tr></thead><tbody><tr><td><code>@Slf4j</code></td><td>自动为类引入 <code>private static final org.slf4j.Logger log</code>日志对象（也有 <code>@Log4j</code>, <code>@Log</code> 等变种）</td></tr><tr><td><code>@SneakyThrows</code></td><td>自动捕获并抛出 checked 异常（不用写 try-catch）</td></tr><tr><td><code>@NonNull</code></td><td>在方法参数或字段上使用，自动生成空值检查</td></tr><tr><td><code>@Cleanup</code></td><td>自动调用 <code>close()</code>，常用于资源释放（如<code>InputStream</code>）</td></tr></tbody></table><h1 id="会话管理">会话管理</h1><h2 id="概述">概述</h2><p>“会话管理”（SessionManagement）是指：在客户端与服务器之间的交互过程中，服务器如何<strong>识别并保持用户身份和状态信息</strong>。</p><p>为什么需要会话管理？因为 HTTP协议本身是无状态的协议，对于发送的请求和响应都不会进行保存，没有记忆功能。为了实现用户登录状态的记录、购物车、填写表单等具有记忆的功能，需要一种能够记忆用户状态的机制——会话管理。</p><h2 id="cookie">Cookie</h2><h3 id="使用">使用</h3><div class="note note-success">            <p>cookie 是一种客户端会话技术, cookie由服务端产生,它是服务器存放在浏览器的一小份数据,浏览器以后每次访问该服务器的时候都会将这小份数据携带到服务器去。</p>          </div><ul><li><strong>服务端</strong>创建cookie,将cookie放入响应对象中,Tomcat容器将cookie转化为set-cookie响应头,响应给客户端</li><li>客户端在收到服务端发来的cookie的响应头后,在以后每次请求该服务的资源时,会以cookie请求头的形式携带之前收到的Cookie</li><li>cookie是一种键值对格式的数据,从tomcat8.5开始可以保存中文,但是不推荐</li><li>由于cookie是存储于客户端的数据,比较容易暴露,一般不存储一些敏感或者影响安全的数据</li></ul><figure><img src="https://s21.ax1x.com/2025/05/13/pEX78OA.png" alt="原理图" /><figcaption aria-hidden="true">原理图</figcaption></figure><p>创建cookie：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务端创建 cookie</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>);<br><span class="hljs-comment">// 放入响应对象</span><br>resp.addCookie(cookie);<br></code></pre></td></tr></table></figure><p>获取cookie：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取请求中携带的cookie</span><br>Cookie[] cookies = req.getCookies();<br><span class="hljs-comment">// 请求中的多个cookie会进入该数组</span><br><span class="hljs-comment">// 如果没有携带任何cookie，数组为null,无法迭代</span><br><span class="hljs-keyword">if</span>(cookies != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">for</span>(Cookie cookie : cookies) &#123;<br>        System.out.println(cookie.getName() + <span class="hljs-string">&quot;=&quot;</span> + cookie.getValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="时效性">时效性</h3><div class="note note-success">            <p>默认情况下Cookie的有效期是一次会话范围内，关闭浏览器后Cookie就会消失，可以通过cookie的setMaxAge()方法让Cookie持久化保存到浏览器上</p>          </div><p><code>cookie.setMaxAge(int expiry)</code>参数单位是秒，表示cookie的持久化时间，如果设置参数为0，表示将浏览器中保存的该cookie删除。</p><ul><li>servletA设置一个Cookie为持久化cookie</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/servletA&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 创建Cookie</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;c1_message&quot;</span>);<br>        cookie1.setMaxAge(<span class="hljs-number">60</span>);<br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;c2&quot;</span>,<span class="hljs-string">&quot;c2_message&quot;</span>);<br>        <span class="hljs-comment">// 将cookie放入响应对象</span><br>        resp.addCookie(cookie1);<br>        resp.addCookie(cookie2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="限制提交路径">限制提交路径</h3><div class="note note-success">            <p>访问互联网资源时不能每次都需要把所有Cookie带上。访问不同的资源时,可以携带不同的cookie,我们可以通过cookie的setPath(Stringpath) 对cookie的路径进行设置</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 创建Cookie</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;c1_message&quot;</span>);<br>        <span class="hljs-comment">// 设置cookie的提交路径</span><br>        cookie1.setPath(<span class="hljs-string">&quot;/web03_war_exploded/servletB&quot;</span>);<br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;c2&quot;</span>,<span class="hljs-string">&quot;c2_message&quot;</span>);<br>        <span class="hljs-comment">// 将cookie放入响应对象</span><br>        resp.addCookie(cookie1);<br>        resp.addCookie(cookie2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="session">Session</h2><p>HttpSession是一种保留更多信息在服务端的一种技术,服务器会为每一个客户端开辟一块内存空间,即session对象.客户端在发送请求时,都可以使用自己的session.这样服务端就可以通过session来记录某个客户端的状态了。</p><p>和cookie的区别：</p><ul><li>cookie是存储在<strong>客户端</strong>（浏览器）的小块文本数据，又服务器发送并保存在浏览器中，每次请求时浏览器都会自动把它们发送给服务器，用于找回服务器中保存的Session数据。</li><li>session是存储在<strong>服务器</strong>的数据，记录了用户的会话状态，比如登录信息、购物车内容等。</li><li>session的安全性更高，容量没有明确的限制；cookie的安全性低，容量一般不超过4kb。</li></ul><p><strong>Session 和 Cookie 的关系：</strong></p><ul><li>Session 依赖 Cookie 来实现识别用户身份。</li><li>通常，服务器在创建一个 Session 时，会生成一个唯一的 SessionID。</li><li>这个 Session ID 会通过 Set-Cookie响应头被发送到客户端，客户端会把这个 ID 保存在 Cookie 中。</li><li>后续客户端的请求会自动携带这个 Session ID 的Cookie，服务器就可以用这个 ID 找回之前保存的 Session数据，从而识别用户状态。</li></ul><p>Session的原理图：</p><figure><img src="https://s21.ax1x.com/2025/05/14/pEjl0Cn.png"alt="Session的原理图" /><figcaption aria-hidden="true">Session的原理图</figcaption></figure><p>示例：假如有一个表单name属性为<code>username</code>，现在使用ServeletA将表单提交的用户名存入Session：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/servletA&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 获取请求中的参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-comment">// 获取session对象</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>         <span class="hljs-comment">// 获取Session的ID</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jSessionId</span> <span class="hljs-operator">=</span> session.getId();<br>        System.out.println(jSessionId);<br>        <span class="hljs-comment">// 判断session是不是新创建的session</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isNew</span> <span class="hljs-operator">=</span> session.isNew();<br>        System.out.println(isNew);<br>        <span class="hljs-comment">// 向session对象中存入数据</span><br>        session.setAttribute(<span class="hljs-string">&quot;username&quot;</span>,username);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>getSession()</code>方法可以获取当前会话的实例，获取的逻辑如下：</p><figure><img src="https://s21.ax1x.com/2025/05/14/pEjluAH.png"alt="getSession方法的操作逻辑" /><figcaption aria-hidden="true">getSession方法的操作逻辑</figcaption></figure><p>这时返回给客户端的响应中包含一个键为<code>JSESSIONID</code>的cookie。</p><p>然后在另一个ServletB中就可以取出用户名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/servletB&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 获取session对象</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>         <span class="hljs-comment">// 获取Session的ID</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jSessionId</span> <span class="hljs-operator">=</span> session.getId();<br>        System.out.println(jSessionId);<br>        <span class="hljs-comment">// 判断session是不是新创建的session</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isNew</span> <span class="hljs-operator">=</span> session.isNew();<br>        System.out.println(isNew);<br>        <span class="hljs-comment">// 从session中取出数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> (String)session.getAttribute(<span class="hljs-string">&quot;username&quot;</span>);<br>        System.out.println(username);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用servletB时可以看到请求中也携带了一个JSESSIONID的cookie。</p><p><strong>Session的时效性</strong>：</p><p>默认的session最大闲置时间(两次使用同一个session中的间隔时间)在tomcat/conf/web.xml配置为30分钟。</p><p>也可以通过HttpSession的API对最大闲置时间进行<strong>手动设定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置最大闲置时间</span><br>session.setMaxInactiveInterval(<span class="hljs-number">60</span>);<br></code></pre></td></tr></table></figure><p>也可以直接让session<strong>失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 直接让session失效</span><br>session.invalidate();<br></code></pre></td></tr></table></figure><h1 id="域对象">域对象</h1><p>域对象是用于<strong>存储和传递数据</strong>的对象。</p><p>比较重要的域：请求域，会话域，应用域。</p><ul><li>请求域对象：HttpServletRequest，传递数据的范围是一次请求之内和多次转发。</li><li>会话域对象：HttpSession，传递数据的范围是一次会话之内，同一个浏览器发起的请求可以共享该对象，但是换一个浏览器就不可以了。</li><li>应用域：ServletContext，传递数据的范围是本应用之内。</li></ul><figure><img src="https://s21.ax1x.com/2025/05/14/pEjn4II.png" alt="请求域" /><figcaption aria-hidden="true">请求域</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/05/14/pEjnoJP.png" alt="会话域" /><figcaption aria-hidden="true">会话域</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/05/14/pEjnTRf.png" alt="应用域" /><figcaption aria-hidden="true">应用域</figcaption></figure><figure><img src="https://s21.ax1x.com/2025/05/14/pEjn7z8.png"alt="所有域合在一起" /><figcaption aria-hidden="true">所有域合在一起</figcaption></figure><h1 id="过滤器">过滤器</h1><p>过滤器的工作位置：</p><p><img src="https://s21.ax1x.com/2025/05/14/pEjuw6S.png" /></p><h2 id="过滤器的使用">过滤器的使用</h2><h3 id="日志记录">日志记录</h3><p><strong>骨架：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> jakarta.servlet.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-comment">// 请求到达之前先使用该方法。</span><br>    <span class="hljs-comment">// 可以在该方法内直接返回响应</span><br>    <span class="hljs-comment">// 返回响应之前还会调用该方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-comment">// 1. 请求到达目标资源之前的功能代码</span><br>        <span class="hljs-comment">//      判断是否登录；校验权限是否满足等</span><br>        <span class="hljs-comment">// 2. 放行代码  </span><br>        <span class="hljs-comment">// 3. 响应之前 HttpServletResponse 转换为响应消息之前的功能代码      </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>传入参数中的<code>FilterChain</code>是一个接口，内部定义了一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FilterChain</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest var1, ServletResponse var2)</span> <span class="hljs-keyword">throws</span> IOException, ServletException;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这个<code>doFilter</code>和<code>LoggingFilter</code>类重写的<code>doFilter</code>方法不是一个方法，这里没有递归。这里的<code>doFilter</code>方法的作用是：</p><p><strong>在多个 Filter之间传递请求和响应对象，或者最终将请求传递给目标 Servlet</strong>。</p><h3 id="放行代码">放行代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">filterChain.doFilter(servletRequest, servletResponse);<br></code></pre></td></tr></table></figure><p>为什么调用<code>doFilter</code>就是放行了？举个例子，假设我们有这样一条过滤器链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Request --&gt; FilterA --&gt; FilterB --&gt; FilterC --&gt; Servlet<br></code></pre></td></tr></table></figure><p>如果在<code>FilterB</code>中调用了<code>chain.doFilter(request, response);</code>，那么请求才会继续往下传，传到下一个过滤器。反之，如果不调用该方法，那么请求就会卡在过滤器B中，达到了<strong>拦截</strong>的效果。</p><p>通过设计<code>doFilter</code>方法，我们可以在过滤器中处理请求，经过仔细判断之后再决定要不要往下传。调用<code>doFilter</code>，则相当于通过过滤器，传给下一个过滤器或Servlet；不调用则不再往下传递，视为拦截。</p><hr /><p>还有一个问题：<strong>多个过滤器链式调用的时候，它们的先后顺序是怎么确定的</strong>？答案是<code>web.xml</code>中的<code>&lt;filter-mapping&gt;</code>的前后顺序决定执行顺序。</p><p>如果采用 Servlet 3.0+的标准注解形式，那么执行顺序取决于类名在字典中的顺序。在使用 Spring的情况下才可以通过注解明确指定执行顺序。</p><figure><img src="https://s21.ax1x.com/2025/05/14/pEjMCb4.png"alt="过滤器链图解" /><figcaption aria-hidden="true">过滤器链图解</figcaption></figure><h3 id="配置过滤器">配置过滤器</h3><p><strong>方法一</strong>：通过<code>web.xml</code>配置</p><p>初始化过滤器；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LoggingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.kzn.filters.LoggingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LoggingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>Servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;url-pattern&gt;&lt;/url-pattern&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>servlet-name</code>:根据servlet的<code>name</code>属性过滤（这个属性的默认值为<code>""</code>，需要手动配置）</li><li><code>url-pattern</code>:根据请求的资源路径来过滤资源。具体规则：<code>精确路径匹配/servlet, 路径匹配/*, 扩展名匹配*.action,默认匹配 /  优先级依次靠后</code>。如果使用<code>/*</code>，说明所有的请求和响应都会经过这个过滤器。</li></ul><p>两者不能混用，否则会导致同一个过滤器被错误地重复执行。</p><p>简易日志的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-comment">// 获取日期对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">dateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br><br>        <span class="hljs-comment">// 强转，方便获取uri</span><br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> httpRequest.getRequestURI();<br>        <span class="hljs-comment">// 日志的格式：yyyy-MM-dd HH:mm:ss 请求 耗时 xx 毫秒</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">dateTime</span> <span class="hljs-operator">=</span> dateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">beforeLogin</span> <span class="hljs-operator">=</span> dateTime + <span class="hljs-string">&quot; : &quot;</span> +uri + <span class="hljs-string">&quot;was logged in&quot;</span>;<br>        <span class="hljs-comment">// 输出日志</span><br>        System.out.println(beforeLogin);<br><br>        <span class="hljs-comment">// 计时开始</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-comment">// 放行的代码</span><br>        filterChain.doFilter(servletRequest, servletResponse);<br>        System.out.println(<span class="hljs-string">&quot;after filter invoked&quot;</span>);<br><br>        <span class="hljs-comment">// 计时结束</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">afterLogin</span> <span class="hljs-operator">=</span> uri + <span class="hljs-string">&quot; has spent &quot;</span> + (t2 - t1) + <span class="hljs-string">&quot; milliseconds&quot;</span>;<br>        <span class="hljs-comment">// 输出日志</span><br>        System.out.println(afterLogin);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="过滤器的生命周期">过滤器的生命周期</h2><blockquote><p>过滤器作为web项目的组件之一,和Servlet的生命周期类似,略有不同,没有servlet的load-on-startup的配置,默认就是系统启动立刻构造</p></blockquote><table style="width:100%;"><thead><tr><th>阶段</th><th>对应方法</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>创建对象</td><td>构造器</td><td>web应用启动时</td><td>1</td></tr><tr><td>初始化方法</td><td><code>void init(FilterConfig filterConfig)</code></td><td>构造完毕</td><td>1</td></tr><tr><td>过滤请求</td><td><code>void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</code></td><td>每次请求</td><td>多次</td></tr><tr><td>销毁</td><td><code>default void destroy()</code></td><td>web应用关闭时</td><td>1次</td></tr></tbody></table><h1 id="监听器">监听器</h1><p>使用频率不如过滤器。</p><p><strong>监听器</strong>：专门用于对域对象对象身上发生的事件或状态改变进行监听和相应处理的对象。</p><p><strong>监听对象</strong>：域对象发生的事件，例如：域对象的创建、销毁，数据的修改、删除等，当这些事件发生时监听器执行相应的代码。</p><h2 id="application-listener">application listener</h2><p>配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.kzn.Listener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者使用注解：<code>@WebListener</code></p><hr /><p>如果想要监听<strong>应用域的初始化和销毁事件</strong>,需要实现<code>ServletContextListener</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Listener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServletContextListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextInitialized</span><span class="hljs-params">(ServletContextEvent sce)</span> &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> sce.getServletContext();<br>        System.out.println(servletContext.hashCode()+<span class="hljs-string">&quot; contextInitialized&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextDestroyed</span><span class="hljs-params">(ServletContextEvent sce)</span> &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> sce.getServletContext();<br>        System.out.println(servletContext.hashCode()+<span class="hljs-string">&quot; contextDestroyed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在应用启动和销毁时各执行一次.</p><p>如果监听 ServletContext的<strong>参数的变化</strong>,需要实现<code>ServletContextAttributeListener</code>,一共三个抽象方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServletContextAttributeListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventListener</span> &#123;<br>    <span class="hljs-comment">// 属性数量增加</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attributeAdded</span><span class="hljs-params">(ServletContextAttributeEvent scae)</span> &#123;<br>    &#125;<br>    <span class="hljs-comment">// 属性被移除</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attributeRemoved</span><span class="hljs-params">(ServletContextAttributeEvent scae)</span> &#123;<br>    &#125;<br>    <span class="hljs-comment">// 属性被修改</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attributeReplaced</span><span class="hljs-params">(ServletContextAttributeEvent scae)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="会话域和请求域">会话域和请求域</h2><p>和应用域完全类似，只不过调用的方法的<code>ServletContext</code>替换成<code>Session</code>和<code>Request</code>。</p><p><code>Session</code>还有两个特殊的监听器：</p><ul><li><code>HttpSessionBindingListener</code>监听当前监听器对象在Session域中的增加与移除</li><li><code>HttpSessionBindingEvent</code>对象代表属性变化事件</li><li><code>HttpSessionActivationListener</code>监听钝化和活化，将内存中的session序列化变成磁盘中的文件称之为钝化，反序列化变成内存中的对象称之为活化。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis配置过程和基本用法</title>
    <link href="/2025/05/14/MyBatis%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2025/05/14/MyBatis%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-mybatis">什么是 MyBatis</h1><p>MyBatis是一个Java持久化框架，它通过XML描述符或注解把对象与存储过程或SQL语句关联起来，映射成数据库内对应的纪录。<ahref="https://mybatis.org/mybatis-3/zh_CN/index.html">官方文档地址</a></p><p>MyBatis 属于 SSM框架的数据访问层，有了它就不必再写JDBC那种繁琐的操作数据库的代码，更简单易用。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Controller（控制层）       &lt;<span class="hljs-comment">-- SpringMVC</span><br>   ↓<br>Service（业务逻辑层）       &lt;<span class="hljs-comment">-- Spring</span><br>   ↓<br>DAO / Mapper（数据访问层） &lt;<span class="hljs-comment">-- MyBatis</span><br>   ↓<br><span class="hljs-keyword">Database</span>（数据库）<br></code></pre></td></tr></table></figure><h1 id="配置-mybatis">配置 MyBatis</h1><ol type="1"><li>使用IDEA<strong>创建</strong>一个Maven工程，加入mybatis, junit,mysql-connector-j依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>在resources目录下<strong>创建</strong><code>mybatis-config.xml</code>配置文件（参数改成自己的）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 设置实体类的别名，这样以后可以直接使用类名而不用再写全类名了 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kzn.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/schedule_system&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;************&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>在java目录下<strong>创建</strong>pojo包和mapper包，分别存放表对应的实体类和处理映射关系的接口。存在这样的对应关系：<code>表——实体类——mapper接口——映射文件</code>。</li></ol><p>然后创建映射文件。映射文件用于将我们创建的接口和sql语句建立联系。考虑到一个项目中会存在多个接口，因此在resources目录下创建mappers文件夹统一管理<code>.xml</code>文件：</p><figure><img src="https://s21.ax1x.com/2025/05/14/pEj8Phj.png" alt="项目结构" /><figcaption aria-hidden="true">项目结构</figcaption></figure><ol start="4" type="1"><li><strong>MyBatis 面向接口编程的两个一致</strong><ol type="1"><li>映射文件的<code>namespace</code>和对应接口的<strong>全类名</strong>保持一致</li><li>映射文件中sql语句的id和mapper接口中定义的<strong>方法名</strong>一致</li></ol></li></ol><p>以上两点是如何体现的呢？先写<code>UserMapper.xml</code>配置（这里是sql的插入语句）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 命名空间是接口的全类名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kzn.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--这里就可以愉快地写 sql 语句啦--&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里使用动态sql --&gt;</span><br>        insert into sys_user (username, user_pwd)<br>        values (#&#123;username&#125;, #&#123;user_pwd&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面是对应的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向表中插入新用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 新用户的实例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对数据库影响的行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertUser</span><span class="hljs-params">(User user)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>写配置文件时就遵循了这两个原则：</p><ul><li><code>namespace</code>改成对应接口的全类名：<code>com/kzn/mapper/UserMapper</code></li><li><code>mapper</code>标签内部写映射语句，并且映射语句的标签名就是要对数据库进行的操作(<code>insert</code>)；<code>id</code>属性要和接口中定义的方法名(此处为<code>insertUser</code>)保持一致。</li></ul><ol start="5" type="1"><li><strong>向核心配置文件中引入映射文件</strong></li></ol><p><code>mappers</code>标签在刚才复制粘贴的模板中已经存在，只需要修改内容即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>测试功能是否可以正常使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMyBatis</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//加载核心配置文件</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <span class="hljs-comment">// 获取SqlSessionFactoryBuilder （工厂模式）</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-comment">// 获取SqlSessionFactory</span><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> builder.build(is);<br>        <span class="hljs-comment">// 获取SqlSession: Java程序和数据库之间的对话</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> factory.openSession();<br>        <span class="hljs-comment">// 获取mapper接口的实现类的实例对象（底层采用代理模式）</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-comment">// 然后利用接口的实现类对象，调用对应的方法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userMapper.insertUser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Origami&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>));<br>        <span class="hljs-comment">// 提交事务</span><br>        sqlSession.commit();<br>        System.out.println(result);<br><br>        sqlSession.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>factory.openSession();</code>可以传入<code>boolean</code>参数决定是否自动提交，<code>true</code>为开启自动提交，<code>false</code>为关闭自动提交。默认为<code>false</code>。</p><p>获取mapper接口的实现类的实例对象之前的代码对于每个测试都是相同的，不妨把它封装成一个测试类<code>MyBatisUtils.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;初始化SqlSessionFactory失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取 SqlSession（可以自动提交或手动提交）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">(<span class="hljs-type">boolean</span> autoCommit)</span> &#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession(autoCommit);<br>    &#125;<br>    <span class="hljs-comment">// 获取 SqlSession 默认手动提交</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getSqlSession(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了这样一个工具类以后，就可以在测试中直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession()) &#123;<br>    <span class="hljs-comment">// 通过 sqlSession 获取接口的实现类的实例对象</span><br><br>    <span class="hljs-comment">//调用接口中的方法</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="日志的配置">日志的配置</h2><p>Mybatis通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j 2</li><li>Log4j（3.5.9起废弃）</li><li>JDK logging</li></ul><p>这里使用的是 Log4j2 。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.23.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>向<code>log4j2.xml</code>中加入语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://logging.apache.org/log4j/2.0/config&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stdout&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%5level [%t] - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kzn.mapper.UserMapper&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;trace&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> &gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stdout&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中<code>com.kzn.mapper.UserMapper</code>要换成自己接口的全类名。当然也可以将日志的记录方式从接口级别切换到语句级，只需将这一项改为对应方法的名称。<code>level</code>是日志级别，可以自己设置，日志的所有级别如下：</p><p>FATAL&gt;ERROR&gt;WARN&gt;INFO&gt;DUBUG</p><p>这时运行测试代码，得到的输出为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">DEBUG [main] - ==&gt;  Preparing: insert into sys_user (username, user_pwd) values (?, ?)<br>DEBUG [main] - ==&gt; Parameters: xQc(String), 123(String)<br>DEBUG [main] - &lt;==    Updates: 1<br>1<br></code></pre></td></tr></table></figure><h1 id="查询">查询</h1><h2 id="针对已知值的查询">针对已知值的查询</h2><p>目标：实现对<code>sys_user</code>表中的单个用户的查询和所有用户的查询。</p><p>如果查询的数据有多条，必须使用<code>List</code>接收。</p><h3 id="基于-xml-的方式">基于 XML 的方式</h3><h4 id="定义接口中的抽象方法">定义接口中的抽象方法</h4><p>向<code>UserMapper.java</code>接口中添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询单个用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> uid 用户的唯一uid</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 用户类的实例</span><br><span class="hljs-comment"> */</span><br>User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询所有用户，返回用户组成的列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 用户列表</span><br><span class="hljs-comment"> */</span><br>List&lt;User&gt; <span class="hljs-title function_">selectAllUsers</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>查询单个用户直接返回对应用户的<code>User</code>对象，查询所有用户就返回组成的列表。</p><h4 id="xml-映射文件">XML 映射文件</h4><p>在映射文件<code>UserMapper.xml</code>的<code>&lt;mapper&gt;</code>标签内部引入方法的映射：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User selectUserById(int uid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.kzn.pojo.User&quot;</span>&gt;</span><br>    SELECT *<br>    FROM sys_user<br>    WHERE uid = #&#123;uid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--List&lt;User&gt; selectAllUsers();--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.kzn.pojo.User&quot;</span>&gt;</span><br>    SELECT *<br>    FROM sys_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第一个语句名为 selectUserById，接受一个 int（或Integer）类型的参数，并返回一个 User 类型的对象。注意参数符号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">&#123;<span class="hljs-built_in">id</span>&#125;</span><br></code></pre></td></tr></table></figure><p>这就告诉 MyBatis创建一个<strong>预处理语句</strong>（PreparedStatement）参数。这其实相当于JDBC中的预处理语句，当时我们是这样处理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义sql语句，参数值用？替代</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from sys_user where uid=?&quot;</span>;<br><span class="hljs-comment">// 获取PreparedStatement 对象</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br><span class="hljs-comment">// 设置参数值</span><br><span class="hljs-comment">// 第一个参数是编号，从 1 开始。第二个参数是赋值</span><br>preparedStatement.setInt(<span class="hljs-number">1</span>, uid);<br></code></pre></td></tr></table></figure><p><code>select</code>元素允许你配置很多属性来配置每条语句的行为细节。这里用到的属性有：</p><ul><li><code>id</code>: 在命名空间中唯一的标识符，一般写成方法名</li><li><code>parameterType</code>:将会传入这条语句的<strong>参数的类全限定名或别名</strong>。这个属性是<strong>可选</strong>的，因为MyBatis可以根据语句中实际传入的参数计算出应该使用的类型处理器（TypeHandler），默认值为未设置（unset）。</li><li><code>resultType</code>:期望从这条语句中<strong>返回结果的类全限定名或别名</strong>。注意，如果返回的是集合，那应该设置为<strong>集合包含的类型</strong>（这里为<code>com.kzn.pojo.User</code>），而不是集合本身的类型。<code>resultType</code>和<code>resultMap</code>之间只能同时使用一个。<ul><li>MyBatis中设置了默认的类型别名，例如<code>int</code>或<code>_int</code>都可正确地对应<code>Integer</code>。</li></ul></li></ul><h4 id="测试">测试</h4><p>得益于我们对<code>MyBatisUtils</code>工具类的封装，现在的测试代码会简洁很多：</p><p>对了，为了保证<code>userList.forEach(System.out::println);</code>能正确打印出用户所有字段的信息而不是具体的地址，在运行之前有必要重写<code>User</code>类的<code>toString()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectAllUsers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession()) &#123;<br><br>        <span class="hljs-comment">// 获取mapper接口的实现类的实例对象（底层采用代理模式）</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br><br>        List&lt;User&gt; userList = mapper.selectAllUsers();<br>        userList.forEach(System.out::println);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: SELECT * FROM sys_user WHERE uid = ?<br>DEBUG [main] - ==&gt; Parameters: 1(Integer)<br>TRACE [main] - &lt;==    Columns: uid, username, user_pwd<br>TRACE [main] - &lt;==        Row: 1, zhangsan, 114411<br>DEBUG [main] - &lt;==      Total: 1<br>User&#123;uid=1, username=&#x27;zhangsan&#x27;, user_pwd=&#x27;114411&#x27;&#125;<br>DEBUG [main] - ==&gt;  Preparing: SELECT * FROM sys_user<br>DEBUG [main] - ==&gt; Parameters: <br>TRACE [main] - &lt;==    Columns: uid, username, user_pwd<br>TRACE [main] - &lt;==        Row: 1, zhangsan, 114411<br>TRACE [main] - &lt;==        Row: 2, lisi, 223322<br>TRACE [main] - &lt;==        Row: 3, CowBoy, 2233<br>TRACE [main] - &lt;==        Row: 4, ddd, 1234<br>TRACE [main] - &lt;==        Row: 5, Asuka, 456<br>TRACE [main] - &lt;==        Row: 8, Spike, 123455<br>TRACE [main] - &lt;==        Row: 11, Origami, 123456<br>TRACE [main] - &lt;==        Row: 14, xQc, 123<br>DEBUG [main] - &lt;==      Total: 8<br>User&#123;uid=1, username=&#x27;zhangsan&#x27;, user_pwd=&#x27;114411&#x27;&#125;<br>User&#123;uid=2, username=&#x27;lisi&#x27;, user_pwd=&#x27;223322&#x27;&#125;<br>User&#123;uid=3, username=&#x27;CowBoy&#x27;, user_pwd=&#x27;2233&#x27;&#125;<br>User&#123;uid=4, username=&#x27;ddd&#x27;, user_pwd=&#x27;1234&#x27;&#125;<br>User&#123;uid=5, username=&#x27;Asuka&#x27;, user_pwd=&#x27;456&#x27;&#125;<br>User&#123;uid=8, username=&#x27;Spike&#x27;, user_pwd=&#x27;123455&#x27;&#125;<br>User&#123;uid=11, username=&#x27;Origami&#x27;, user_pwd=&#x27;123456&#x27;&#125;<br>User&#123;uid=14, username=&#x27;xQc&#x27;, user_pwd=&#x27;123&#x27;&#125;<br></code></pre></td></tr></table></figure><p>看起来比较长，这是因为我启用了日志打印功能。</p><h3 id="基于注解的方式">基于注解的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;SELECT id, username, password FROM users WHERE id = #&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-type">int</span> id)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;SELECT id, username, password FROM users&quot;)</span><br>    List&lt;User&gt; <span class="hljs-title function_">selectAllUsers</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现的功能和前面是一样的。</p><h1 id="特殊-sql">特殊 SQL</h1><h2 id="模糊匹配">模糊匹配</h2><p>上述查询操作中的所有操作符都是针对已知值进行过滤的，有时候并不好用，例如，怎样搜索产品名中包含文本anvil的所有产品？用简单的比较操作符肯定不行，必须使用通配符。MySQL中使用<code>LIKE</code>关键字表名接下来要执行模糊匹配，与之对应的通配符有：</p><ul><li>百分号<code>%</code>: 匹配多个字符（包括空字符和空格）</li><li>下划线<code>_</code>: 只匹配单个字符</li></ul><p>在 MyBatis 中写sql语句时，下面这种赋值方式不可取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sys_user <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%#&#123;username&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>因为这里的<code>#&#123;&#125;</code>被当成字符串处理了，无法引用传入的参数。如果把它换成<code>$&#123;&#125;</code>，虽然可以运行，但是不推荐，因为这时存在<strong>SQL注入</strong>的问题。例如当username=<code>"' or '1'='1"</code>时，sql语句实际上变成了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sys_user <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><p>where条件始终成立，这会导致整个表的数据都被返回。正确的做法是使用<code>#&#123;&#125;</code>配合文本处理函数<code>concat</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sys_user <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> concat(<span class="hljs-string">&#x27;%&#x27;</span>, #&#123;username&#125;)<br></code></pre></td></tr></table></figure><p>这也是最常用的方式。</p><h2 id="批量删除">批量删除</h2><p>考虑这样一个情景：用户在邮箱中一次性选中多个文件进行批量删除。用户按下删除按钮后，前端向后端发来被选中的序号构成的数组，后端根据这个数组执行数据库的删除操作。为此可以写出以下接口抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteUsersByIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; ids)</span>;<br></code></pre></td></tr></table></figure><p>这里使用列表而不是数组储存数据，因为列表的话更具通用性。</p><p>重头戏是<code>.xml</code>配置文件。我使用的代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUsersByIds&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    DELETE FROM sys_user<br>    WHERE uid IN<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>关键在于<code>foraeach</code>标签。<code>&lt;foreach&gt;</code>用于生成<strong>动态SQL</strong>，比如构造<code>IN (...)</code>子句，以支持批量操作（插入、删除、更新等）。</p><ul><li><code>collection</code>:指定要遍历的集合名称，也就是传入的集合名<code>ids</code></li><li><code>item</code>:遍历集合中的每个变量时使用的临时变量的名字，类似于增强型 for 循环。</li><li><code>open="xxx"</code>:指定遍历开始前就输出的内容。因为我们要构造的是<code>IN(...)</code>字句，所以开始位置先放上一个左括号</li><li><code>separator="xxx"</code>: 每个元素之间的分隔符</li><li><code>close="xxx"</code>:遍历结束后输出的内容，这里放一个右括号。</li></ul><p>下面结合测试用例看一下效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteUsersByIds</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 删除uid为2，4的记录</span><br>    userMapper.deleteUsersByIds(List.of(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>));<br>    sqlSession.commit();<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于执行<code>DELETE FROM sys_user WHERE uid IN(2, 4)</code>，打印结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">DEBUG [main] - ==&gt;  Preparing: DELETE FROM sys_user WHERE uid IN ( ? , ? )<br>DEBUG [main] - ==&gt; Parameters: 2(Integer), 4(Integer)<br>DEBUG [main] - &lt;==    Updates: 2<br></code></pre></td></tr></table></figure><p>成功删除两条记录。</p><h1 id="mybatis-获取数据值的两种方式">MyBatis 获取数据值的两种方式</h1><h2 id="细节">细节</h2><p>使用<code>#&#123;&#125;</code>参数语法时，MyBatis会创建<code>PreparedStatement</code>参数占位符，并通过占位符安全地设置参数（就像使用<code>?</code>一样）。这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL语句中直接插入一个不转义的字符串，这时候可以使用<code>$&#123;&#125;</code>。</p><div class="note note-secondary">            <p><code>${}</code>的本质就是字符串的拼接<code>str1 + str2</code>，<code>#{}</code>的本质就是占位符赋值。</p>          </div><p><code>$&#123;&#125;</code>的使用情景主要是动态设置表名、列名、ORDER BY动态排序等，例如：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">ORDER</span> <span class="hljs-title">BY</span> $&#123;columnName&#125;<br></code></pre></td></tr></table></figure><p>举个例子，如果你想<code>select</code>一个表任意一列的数据时，可以直接写成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-variable">@Select</span>(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)<br><span class="hljs-keyword">User</span> findByColumn(<span class="hljs-variable">@Param</span>(&quot;column&quot;) String <span class="hljs-keyword">column</span>, <span class="hljs-variable">@Param</span>(&quot;value&quot;) String <span class="hljs-keyword">value</span>);<br></code></pre></td></tr></table></figure><p><code>$&#123;column&#125;</code>引用一个动态的字段名，比如<code>uid</code>，<code>user_pwd</code>。这样就不必为每个字段都单独写一个查询方法了，这也适用于替换表名的情况。</p><p>但是，凡是使用<code>$&#123;&#125;</code>出现的地方都有<strong>SQL注入</strong>的风险，如果要使用这种写法，因此，要么不允许用户输入这些字段，要么自行转义并检验这些参数。</p><hr /><p><code>#&#123;&#125;</code>用于给参数赋值，MyBatis<strong>默认只能识别单个参数</strong>。</p><p>多个参数时，MyBatis会把这些参数放到一个map中，在没有显式命名参数的情况下：</p><ul><li><code>$&#123;&#125;</code>，以<code>param1, param2...</code>为键，参数为值<br /></li><li><code>#&#123;&#125;</code>，以<code>arg0, arg1...</code>为键，参数为值</li></ul><p>此时最好在接口的方法中用<code>@Param</code>为参数<strong>显式命名</strong>，方便在sql语句中引用。这种情况下MyBatis创建的集合中实际上同时存在两种引用方式，默认和自定义都可使用，当然一般都是用自定义的名字。</p><p>对单参数和多参数各举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询单个用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> uid 用户的唯一uid</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 用户类的实例</span><br><span class="hljs-comment"> */</span><br>User <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 检查用户名和密码对应的人是否存在（仅作为测试，实际数据库中不可能存储明文密码）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> password 密码</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 是否存在</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">checkUserExists</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username, <span class="hljs-meta">@Param(&quot;password&quot;)</span> String password)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--User selectUserById(int uid);--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    SELECT *<br>    FROM sys_user<br>    WHERE uid = #&#123;uid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- boolean checkUserExists(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkUserExists&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;boolean&quot;</span>&gt;</span><br>    SELECT COUNT(*) &gt; 0 <span class="hljs-comment">&lt;!--用于检测满足后面的记录是否存在，存在的话就返回true--&gt;</span><br>    FROM sys_user<br>    WHERE username = #&#123;username&#125; AND user_pwd = #&#123;password&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>selectUserById</code>只有一个参数，所以无需显式命名，直接在配置文件中用<code>#&#123;uid&#125;</code>表示（这里的名字可以随便起，不一定是uid）。但是第二个方法传入了两个参数，显式命名为<code>username</code>和<code>password</code>，这样在xml配置文件中就可以使用<code>#&#123;username&#125;</code>和<code>#&#123;password&#125;</code>引用传入的值了。</p><hr /><p>还有一种情况是传入的参数刚好是某个实体类的类型，如果要使用sql访问实体类的属性值，使用<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>都可。之前查询部分的代码就属于这种情况，不再赘述。</p><h2 id="总结">总结</h2><p><strong>获取数据值的两种方式：</strong></p><ul><li><code>$&#123;&#125;</code>: 字符串拼接，不安全，少用</li><li><code>#&#123;&#125;</code>: 占位符赋值，安全，优先使用。</li></ul><p><strong>接口方法中传入的参数也可以分成两大类：</strong></p><ul><li>如果传入的参数是某个实体类的类型，sql语句可以直接使用<code>#&#123;属性名&#125;</code>访问某个实体类的值，如<code>insert into sys_user (username, user_pwd) values (#&#123;username&#125;, #&#123;user_pwd&#125;)</code></li><li>如果传入了一个或多个参数，建议都使用<code>@Param</code>显式命名参数，之后sql语句就可以直接使用别名来引用参数的值</li></ul>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb开发（一）</title>
    <link href="/2025/05/11/JavaWeb1/"/>
    <url>/2025/05/11/JavaWeb1/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s21.ax1x.com/2025/05/05/pEqJr6K.jpg" /></p><h1 id="tomcat简介">Tomcat简介</h1><p>Tomcat是由Apache软件基金会属下Jakarta项目开发的Servlet容器，按照SunMicrosystems提供的技术规范，实现了对Servlet和JavaServerPage（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zh.wikipedia.org/wiki/Apache_Tomcat">[1]</span></a></sup></p><p>Jakarta EE平台是Java EE平台的演进。Tomcat10及以后的版本实现了作为Jakarta EE一部分开发的规范。Tomcat9和更早版本的实现规范是作为Java EE的一部分开发的。</p><p>ApacheTomcat本身完全开源免费，这也是它受到热烈欢迎的原因之一。Tomcat的作用是自己开发的APP，它的运行需要jre。jre是针对JavaSE的，如果需要运行JavaEE的程序就提供更多的支持，Tomcat的作用就是这个。</p><h1 id="web项目的标准结构">Web项目的标准结构</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Web Root<br>     |<br>     ├─── WEB<span class="hljs-literal">-INF</span><br>     │      ├─── web.<span class="hljs-keyword">xml</span><br>     <span class="hljs-title">│      ├─── classes</span><br>     │      └─── lib<br>     │<br>     ├─── Static Resources<br>     │      ├─── HTML Files<br>     │      ├─── CSS Files<br>     │      └─── JavaScript Files<br>     │<br>     ├─── Dynamic Resources<br>     │      ├─── JSP Files<br>     │      └─── Servlet Files<br>     │<br>     └─── Configuration Files<br>            ├─── web.<span class="hljs-keyword">xml</span><br>            <span class="hljs-title">├─── context</span>.<span class="hljs-keyword">xml</span><br>            <span class="hljs-title">└─── log4j</span>.properties      <br></code></pre></td></tr></table></figure><p><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.cnblogs.com/mamamia/p/17748456.html">[2]</span></a></sup>其中<strong>WEB-INF</strong>目录下的资源是被保护的资源，不可以被浏览器访问。用来放第三方jar包，classes，web.xml等。</p><p><strong>JSP 文件</strong>：JavaServer Pages（JSP）文件是用于创建动态Web 内容的文件。它们通常位于 Web 根目录下的某个位置。JSP 文件包含 HTML代码和 Java 代码，用于生成动态内容。当 JSP文件被访问时，它们会被服务器编译成 Servlet类，并由服务器进行处理和执行。</p><p><strong>Servlet 文件</strong>：Servlet 是 Java Web应用程序的核心组件之一，用于处理客户端请求并生成动态内容。Servlet文件通常位于 WEB-INF 目录下的某个位置，可以通过映射 URL 来访问。Servlet文件是 Java 类，实现了 Servlet 接口或扩展了 HttpServlet类，通过重写相应的方法来处理请求和生成响应。</p><h1 id="servlet">Servlet</h1><h2 id="简介">简介</h2><div class="note note-success">            <p>Servlet 是 Java EE（现在称为 Jakarta EE）平台中用于处理 Web请求并生成响应的一种 Java编程技术。不是所有的Java类都能处理客户端的请求，能处理客户端请求并做出响应的一套技术标准就是Servlet。Servlet 是运行在服务器端的，所以必须在 Web 项目中开发并且在Tomcat 这样的服务容器中运行。</p>          </div><ul><li>静态资源：在程序运行之前就写好了的资源，比如hexo静态博客中的js，css，html文件</li><li>动态资源：程序运行时通过代码运行生成的资源，指的不是js创建的动画效果</li></ul><p>Servlet用于接收、处理客户端请求、响应给浏览器的动态资源。是运行在Tomcat的Java小程序，是sum公司提供的一套自定义动态资源规范，从代码层面上讲Servlet 就是一个接口。</p><h2 id="工作流程">工作流程</h2><ol type="1"><li>Tomcat接收到请求以后，会把请求的信息转换成一个<code>HttpServletRequest</code>对象，包含了请求消息中的所有信息。</li><li>Tomcat同时创建了一个<code>HttpServletResponse</code>对象，用来装要响应给客户端的信息，未来这个对象会被转换成响应消息。</li><li>Tomcat 根据提供的路径找到对应的Servlet，实例化，调用<code>service</code>方法，同时传入两个对象：<code>HttpServletRequest</code>和<code>HttpServletResponse</code>。从而获取请求消息；然后根据请求消息生成要响应给客户端的数据，将相应的数据放入<code>HttpServletResponse</code>对象。</li><li>最后<code>HttpServletResponse</code>被转换成响应消息发回客户端。</li></ol><p>我们需要自己定义一个 Servlet类，实现接口<code>Servlet</code>，重写<code>service</code>方法。</p><p><img src="https://s21.ax1x.com/2025/05/06/pEq6res.png" /></p><hr /><p>举个例子，客户端提交一个用户名，如果用户名已经存在，那么返回<code>No</code>。</p><ol type="1"><li>创建一个Java项目，同时把 Tomacat 添加为依赖</li><li>重写<code>protected void service(HttpServletRequest req, HttpServletResponse resp)</code></li><li>在<code>service</code>方法中定义业务处理代码</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置Servlet类，起一个别名--&gt;</span><br><span class="hljs-comment">&lt;!-- servlet-class 用于告知tomcat要实例化的类</span><br><span class="hljs-comment">     name 用于关联请求的路径--&gt;</span><br><span class="hljs-comment">&lt;!--用于告诉容器这个 Servlet 存在，以及它的类在哪。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>userServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>servlet.UserServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--这是 Servlet 的 URL 映射部分，用于告诉服务器：当访问某个 URL 时，要调用哪个 Servlet。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>userServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/absolute<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一个<code>servlet-name</code>可以对应多个<code>url-pattern</code>，但是一个<code>url-pattern</code>只能和一个<code>servlet-name</code>对应。</p><p>使用注解的方式可以完全替代上面复杂的<code>web.xml</code>代码，只需要在自定义的<code>public class UserServlet extends HttpServlet</code>类前加上注解<code>@WebServlet("/自定义")</code>（也可以定义多个url）。这两种方式二选其一，不能重复。</p><h2 id="插曲">插曲</h2><p>servlet-api.jar编码的时候需要，但是服务器内置，所以不参与打包，作用范围是<code>provided</code>。</p><p>响应头中的 Content-Type 显示的是MIME类型，MIME类型用于告诉客户端响应的数据是什么类型的数据。什么是MIME类型？</p><blockquote><p>MIME 类型（Multipurpose Internet Mail Extensions） 是一种在 HTTP通信或邮件传输中标识文件内容类型的标准方式。它告诉浏览器或其他客户端：服务器发送的内容属于哪种格式，应该如何处理。</p></blockquote><p>MIME格式：<code>主类型/子类型</code>，例如<code>text/html</code>指的是HTML文件。</p><p><code>conf/web.xml</code>中记录了几乎所有文件类型对应的MIME类型，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mime-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span>htm<span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mime-type</span>&gt;</span>text/html<span class="hljs-tag">&lt;/<span class="hljs-name">mime-type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mime-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mime-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span>html<span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mime-type</span>&gt;</span>text/html<span class="hljs-tag">&lt;/<span class="hljs-name">mime-type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mime-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>extension</code>指的是文件拓展名。Tomcat 通过这里记录的关系对Content-Type赋值。将相应的数据放入响应体中时可以调用对应的方法手动指定。</p><h2 id="servlet-生命周期">Servlet 生命周期</h2><h3 id="普通-servlet">普通 Servlet</h3><ol type="1"><li>实例化——构造器，第一次请求//服务启动（这个执行阶段可自己指定，关键词<code>loadOnStartUp</code>）</li><li>初始化——init，构造完毕执行一次</li><li>接收请求，处理请求 服务——service，每次请求都执行</li><li>销毁——destroy，关闭服务时请求</li></ol><p><code>Servlet</code>在 Tomcat中是单例的。其中的成员变量在多个线程中是共享的，所以不建议在service方法中修改成员变量，否则会引发线程安全问题。</p><h3 id="defaultservlet">DefaultServlet</h3><p>它被定义在 Tomcat 安装目录下的<code>\conf\web.xml</code>中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- debug=0 调试信息等级0，表示不输出debug信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- listings=false 禁止目录列表浏览功能--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>listings<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 优先级1，表示容器启动时立即加载此 Servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>“<strong>目录列表浏览功能</strong>”：当你在浏览器中访问一个目录路径，如果这个目录下没有默认的首页文件（如<code>index.html</code>或<code>index.jsp</code>），Tomcat会尝试列出这个目录中的所有文件，这个功能就是所谓的目录列表浏览（DirectoryListing）。</p><p>在禁止目录列表浏览功能的情况下，就算找不到默认首页文件，也不会展示目录列表，直接返回403。这样可以防止用户发现敏感文件，不暴露Web应用的内部结构。</p></blockquote><p>它主要处理：</p><ul><li>静态文件（如<code>.html</code>、<code>.css</code>、<code>.js</code>、图片等）请求（最重要）</li><li>找不到匹配的<code>servlet</code>或映射时，作为“兜底”处理请求</li></ul><p>SpringMVC 会导致 DefaultServlet失效，无法访问静态资源，这时需要重新配置 DefaultServlet。</p><h2 id="servlet-接口">Servlet 接口</h2><p>位于包<code>javax.servlet</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Servlet</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException;<br>    ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException;<br>    String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>void init</code>: 初始化 Servlet，只在 Servlet第一次被加载时调用一次。</li><li><code>ServletConfig getServletConfig</code>: 返回 Servlet的配置对象（ServletConfig），包含初始化参数等信息。</li><li><code>void service</code>: 处理客户端请求，是 Servlet的核心方法。</li><li><code>String getServletInfo</code>: 返回一个字符串，用于描述 Servlet的信息。一般用处不大，可以写作者名、版本号等。</li><li><code>void destroy</code>: 在 Servlet被销毁之前调用，用于释放资源。可以用于关闭数据库连接、清理线程池等。</li></ul><h2 id="servlet-实现类">Servlet 实现类</h2><p>这个接口有两个实现类：<code>GenericServlet</code>和<code>HttpServlet</code></p><h3 id="genericservlet">GenericServlet</h3><p>所在包：<code>javax.servlet</code>。GenericServlet是一个抽象类，实现了 Servlet接口的大部分方法，但是没有实现<code>service()</code>，所以还是抽象类。它与协议无关。</p><p>使用它的时候只需要重写<code>service(ServletRequest req, ServletResponse res)</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        res.getWriter().write(<span class="hljs-string">&quot;Hello from GenericServlet&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="httpservlet">HttpServlet</h3><p>所在包：<code>javax.servlet.http</code>，是<code>GenericServlet</code>的子抽象类，专为处理HTTP 请求设计。它为 HTTP 请求方法（GET、POST、PUT等）提供了对应的回调方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericServlet</span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p><strong>关键源码</strong>：这是我们创建自定义类时要重写的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>     <span class="hljs-comment">// 向下转型</span><br>     HttpServletRequest request;<br>     HttpServletResponse response;<br>     <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 捕获强转异常</span><br>         request = (HttpServletRequest)req;<br>         response = (HttpServletResponse)res;<br>     &#125; <span class="hljs-keyword">catch</span> (ClassCastException var6) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(lStrings.getString(<span class="hljs-string">&quot;http.non_http&quot;</span>));<br>     &#125;<br>     <span class="hljs-comment">// 调用这个类中的另一个service方法</span><br>     <span class="hljs-built_in">this</span>.service(request, response);<br> &#125;<br></code></pre></td></tr></table></figure><p>这里的形参列表中的<code>ServletRequest</code>和<code>ServletResponse</code>是实际使用的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>的父类，我们使用的时候自动向下转型。</p><p>这个方法执行到最后会调用另一个被<code>protected</code>的重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">// 获取请求方法名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> req.getMethod();<br>    <span class="hljs-comment">// 处理GET请求</span><br>    <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;GET&quot;</span>)) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getLastModified(req); <span class="hljs-comment">// 获取资源的最后修改时间</span><br>        <span class="hljs-keyword">if</span> (lastModified == -<span class="hljs-number">1L</span>) &#123; <span class="hljs-comment">// -1说明没有使用缓存机制，直接调用 doGet() 处理请求</span><br>            <span class="hljs-built_in">this</span>.doGet(req, resp);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果使用了缓存机制</span><br>            <span class="hljs-type">long</span> ifModifiedSince; <span class="hljs-comment">// 客户端请求中自带 If-Modified-Since 头字段，表示它缓存的时间。</span><br>            <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 获取这个字段</span><br>                ifModifiedSince = req.getDateHeader(<span class="hljs-string">&quot;If-Modified-Since&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException var9) &#123;<br>                <span class="hljs-comment">// 如果解析错误，设置为-1</span><br>                ifModifiedSince = -<span class="hljs-number">1L</span>;<br>            &#125;<br>                <span class="hljs-comment">// 缓存的时间 &lt; 最后修改时间（秒），说明缓存太旧还没来得及更新</span><br>            <span class="hljs-keyword">if</span> (ifModifiedSince &lt; lastModified / <span class="hljs-number">1000L</span> * <span class="hljs-number">1000L</span>) &#123;<br>                <span class="hljs-comment">// 这时候要通知客户端重新设置缓存</span><br>                <span class="hljs-comment">// 设置 Last-Modified 响应头，并调用 doGet() 返回过去新数据。</span><br>                <span class="hljs-built_in">this</span>.maybeSetLastModified(resp, lastModified);<br>                <span class="hljs-built_in">this</span>.doGet(req, resp);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 304 状态码告诉客户端使用本地缓存</span><br>                resp.setStatus(<span class="hljs-number">304</span>);<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">// 处理 HEAD 请求 </span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;HEAD&quot;</span>)) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getLastModified(req);<br>        <span class="hljs-built_in">this</span>.maybeSetLastModified(resp, lastModified);<br>        <span class="hljs-built_in">this</span>.doHead(req, resp);<br>    <span class="hljs-comment">// 处理其他 HTTP 方法</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;<br>        <span class="hljs-built_in">this</span>.doPost(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;PUT&quot;</span>)) &#123;<br>        <span class="hljs-built_in">this</span>.doPut(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;DELETE&quot;</span>)) &#123;<br>        <span class="hljs-built_in">this</span>.doDelete(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;OPTIONS&quot;</span>)) &#123;<br>        <span class="hljs-built_in">this</span>.doOptions(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;TRACE&quot;</span>)) &#123;<br>        <span class="hljs-built_in">this</span>.doTrace(req, resp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果请求使用了不支持的HTTP方法，返回 501 Not Implemented 错误</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">errMsg</span> <span class="hljs-operator">=</span> lStrings.getString(<span class="hljs-string">&quot;http.method_not_implemented&quot;</span>);<br>        Object[] errArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">1</span>];<br>        errArgs[<span class="hljs-number">0</span>] = method;<br>        errMsg = MessageFormat.format(errMsg, errArgs);<br>        resp.sendError(<span class="hljs-number">501</span>, errMsg);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个方法负责根据客户端请求的 HTTP 方法，自动将请求分发到对应的doGet, doPost 等方法。下面来看<code>doGet</code>方法是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> lStrings.getString(<span class="hljs-string">&quot;http.method_get_not_supported&quot;</span>);<br>    <span class="hljs-built_in">this</span>.sendMethodNotAllowed(req, resp, msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>作用是：如果没有重写<code>doGet</code>，当用户发起 GET请求时，就会用英文提示“GET 不被支持”返回 405 错误。</p><p>其他几个请求方法也都是一样的逻辑。只要用户没有重写这些方法，都会返回错误信息。这样保证了需要什么就用什么，用不到的请求方法也不会被意外调用。</p><p>不过，话虽如此，在实际使用中直接重写<code>service</code>也是完全可以使用的，这样也比较方便。</p><p>后续使用 Spring 框架后，就不用再写这些了...</p><h2 id="servletconfig">ServletConfig</h2><p>ServletConfig 是什么？</p><blockquote><p><code>ServletConfig</code>是为Servlet提供初始配置参数的一种对象，每个Servlet都有自己<strong>独立唯一</strong>的ServletConfig对象。</p><p>容器会为每个Servlet实例化一个ServletConfig对象，并通过Servlet的生命周期的init方法传入给Servelt作为属性。</p></blockquote><p><strong>一般配置方式</strong>：</p><p>在<code>web.xml</code>中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>servlet.Servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><br>     <span class="hljs-comment">&lt;!--配置初始参数--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>keya<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>valueA<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>keyb<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>valueB<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><br> <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br> <br> <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servlet1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/s1<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后就可以在 Servlet中读取<code>&lt;init-param&gt;</code>中的参数了，这里提供了两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletConfig</span> <span class="hljs-variable">servletConfig</span> <span class="hljs-operator">=</span> getServletConfig();<br>        <span class="hljs-comment">/*第一种方法*/</span><br>        <span class="hljs-comment">// 获取初始配置信息</span><br>        <span class="hljs-comment">// 根据参数名获取参数值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">a_parameter</span> <span class="hljs-operator">=</span> servletConfig.getInitParameter(<span class="hljs-string">&quot;keya&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;A: &quot;</span> + a_parameter);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b_parameter</span> <span class="hljs-operator">=</span> servletConfig.getInitParameter(<span class="hljs-string">&quot;keyb&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;B: &quot;</span> + b_parameter);<br>        System.out.println();<br><br>        <span class="hljs-comment">/* 第二种方法 */</span><br>        <span class="hljs-comment">// 获取所有的初始参数的名字  迭代器！</span><br>        Enumeration&lt;String&gt; initParameterNames = servletConfig.getInitParameterNames();<br>        <span class="hljs-comment">// 判断有没有下一个参数;</span><br>        <span class="hljs-keyword">while</span> (initParameterNames.hasMoreElements()) &#123;<br>            <span class="hljs-comment">// 取出下一个元素  并向下移动游标（迭代器的指针）</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> initParameterNames.nextElement();<br>            System.out.println(name + <span class="hljs-string">&quot; : &quot;</span> + servletConfig.getInitParameter(name));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注解方式配置</strong></p><p>使用<code>@WebServlet</code>注解可以更简单地完成上述配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(</span><br><span class="hljs-meta">        urlPatterns = &quot;/s1&quot;,</span><br><span class="hljs-meta">        initParams = &#123;@WebInitParam(name=&quot;keya&quot;, value=&quot;valuea&quot;)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletConfig</span> <span class="hljs-variable">servletConfig</span> <span class="hljs-operator">=</span> getServletConfig();<br>        <span class="hljs-comment">/*第一种方法*/</span><br>        <span class="hljs-comment">// 获取初始配置信息</span><br>        <span class="hljs-comment">// 根据参数名获取参数值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">a_parameter</span> <span class="hljs-operator">=</span> servletConfig.getInitParameter(<span class="hljs-string">&quot;keya&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;A: &quot;</span> + a_parameter);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b_parameter</span> <span class="hljs-operator">=</span> servletConfig.getInitParameter(<span class="hljs-string">&quot;keyb&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;B: &quot;</span> + b_parameter);<br>        System.out.println();<br><br>        <span class="hljs-comment">/* 第二种方法 */</span><br>        <span class="hljs-comment">// 获取所有的初始参数的名字  迭代器！</span><br>        Enumeration&lt;String&gt; initParameterNames = servletConfig.getInitParameterNames();<br>        <span class="hljs-comment">// 判断有没有下一个参数;</span><br>        <span class="hljs-keyword">while</span> (initParameterNames.hasMoreElements()) &#123;<br>            <span class="hljs-comment">// 取出下一个元素  并向下移动游标（迭代器的指针）</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> initParameterNames.nextElement();<br>            System.out.println(name + <span class="hljs-string">&quot; : &quot;</span> + servletConfig.getInitParameter(name));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">A: valuea<br>B: null<br><br>keya : valuea<br></code></pre></td></tr></table></figure><p>因为这时没有定义<code>keyb</code>参数，所以第一种方法打印出来B为null，使用迭代的方法没有打印B</p><h2 id="servletcontext">ServletContext</h2><p>与<code>ServletConfig</code>类似，它也可以提供初始化配置参数，但<code>ServletContext</code>是为所有的Servlet对象提供<strong>公共</strong>的参数。</p><p><img src="https://s21.ax1x.com/2025/05/08/pELBgdP.png" /></p><p>ServletContext是一个全局的储存信息的空间，<strong>它被所有客户端共享</strong>，因此Servlet对象之间可以通过ServletContext 对象来实现通讯。</p><p><strong>修改 ServeletContext</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>password<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>获取 ServletContext 对象</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ServletContext <span class="hljs-title function_">getServletContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getServletConfig().getServletContext();<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>servlet对象.getServletContext()</code>来获取 ServletContext对象。</p><p>打印所有<code>ServeletContext</code>的全局参数，也可以使用迭代的方法，同<code>ServletConfig</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> getServletContext();<br>Enumeration&lt;String&gt; initParameterNames = servletContext.getInitParameterNames();<br><span class="hljs-keyword">while</span> (initParameterNames.hasMoreElements()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">initParameterName</span> <span class="hljs-operator">=</span> initParameterNames.nextElement();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">initParameterValue</span> <span class="hljs-operator">=</span> servletContext.getInitParameter(initParameterName);<br>    System.out.println(initParameterName + <span class="hljs-string">&quot;: &quot;</span> + initParameterValue);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是注意：这里调用<code>getInitParameter()</code><strong>获取的是来自web.xml或注解配置的初始化参数，不可变，程序启动后不可改</strong>。如果想要获取程序运行时<strong>动态</strong>修改过的ServletContext 属性，应当使用<code>getAttribute</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;--------- ServletContext init params ---------&quot;</span>);<br>Enumeration&lt;String&gt; initParams = servletContext.getInitParameterNames();<br><span class="hljs-keyword">while</span> (initParams.hasMoreElements()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> initParams.nextElement();<br>    System.out.println(<span class="hljs-string">&quot;init param: &quot;</span> + name + <span class="hljs-string">&quot; = &quot;</span> + servletContext.getInitParameter(name));<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;--------- ServletContext attributes ---------&quot;</span>);<br>Enumeration&lt;String&gt; attrNames = servletContext.getAttributeNames();<br><span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> attrNames.nextElement();<br>    System.out.println(<span class="hljs-string">&quot;attribute: &quot;</span> + name + <span class="hljs-string">&quot; = &quot;</span> + servletContext.getAttribute(name));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取资源真实路径-api">获取资源真实路径 API</h3><p><code>getServletContext().getRealPath("/目录名")</code></p><p><strong>示例</strong>：</p><p>在<code>src/Servlet3.java</code>中写如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(</span><br><span class="hljs-meta">        urlPatterns = &quot;/s3&quot;,</span><br><span class="hljs-meta">        initParams = &#123;@WebInitParam(name = &quot;s3&quot;, value = &quot;sdeddd&quot;)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> getServletContext();<br>        <span class="hljs-comment">// 获取真实路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> servletContext.getRealPath(<span class="hljs-string">&quot;upload&quot;</span>);<br>        System.out.println(path);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">D:\Develop\web-all\out\artifacts\demo03_servletConfig_servletContext_war_exploded\upload<br></code></pre></td></tr></table></figure><hr /><p><strong>作用</strong>：</p><p>获取<strong>项目部署路径</strong>，也叫上下文路径。与手动指定的方式不同的是，这个路径不是写死的，随项目部署位置的改变而自动变化。这样一来，不管该项目实在本地运行还是未来放到服务器中运行，都可以成功找到正确的路径。</p><p>本例中的项目结构为</p><p><img src="https://s21.ax1x.com/2025/05/09/pEOZBV0.png" /></p><p><code>web</code>即项目的访问路径，<code>upload</code>在<strong>开发项目</strong>中的的确切位置为<code>web/upload</code>；在<strong>部署项目</strong>中的位置变成了<code>demo03_servletConfig_servletContext_war_exploded\upload</code>，也就是我们刚才获取的真实路径。</p><h3 id="域对象相关-api">域对象相关 API</h3><p>域对象：即具有<strong>作用域</strong>(Scope)的对象。它们用于<strong>在Web应用中保存和共享数据</strong>。说白了，域对象就是一个放数据的对象，可以通过域对象来存值和取值，不同的域对象的范围不一样，也就限制了哪些类可以访问这个对象，进行值的存储，以达到数据交换的目的。</p><p>刚才提到的<code>ServletContext</code>在一个WebApp中是唯一的，代表了这个应用，也叫<strong>应用域</strong>，是 Web App中最大的域。</p><p><strong>常见的域对象</strong></p><table><thead><tr><th>域对象名称</th><th>接口类型</th><th>常用获取方式</th></tr></thead><tbody><tr><td><strong>request</strong></td><td><code>HttpServletRequest</code></td><td>Servlet 方法参数或 JSP 中隐含对象</td></tr><tr><td><strong>session</strong></td><td><code>HttpSession</code></td><td><code>request.getSession()</code></td></tr><tr><td><strong>application</strong>（即 <code>ServletContext</code>）</td><td><code>ServletContext</code></td><td><code>getServletContext()</code> 或<code>application</code>（JSP）</td></tr><tr><td><strong>page</strong>（只在 JSP 中）</td><td><code>PageContext</code></td><td>JSP 中隐含对象 <code>pageContext</code></td></tr></tbody></table><p><strong>域对象常用 API 方法</strong></p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>setAttribute(String name, Object value)</code></td><td>设置（添加或修改）一个属性（键值对）</td></tr><tr><td><code>getAttribute(String name)</code></td><td>获取指定属性的值</td></tr><tr><td><code>removeAttribute(String name)</code></td><td>移除指定属性</td></tr><tr><td><code>getAttributeNames()</code></td><td>返回所有属性名的枚举（Enumeration 类型）</td></tr></tbody></table><ol type="1"><li><code>setAttribute</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setAttribute</span><span class="hljs-params">(String var1, Object var2)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>var1</code>:相当于哈希表中的<strong>键</strong>，不过必须是字符串类型，不可重复</li><li><code>var2</code>: 相当于哈希表中的值</li></ul><ol start="2" type="1"><li><code>getAttribute(String name): Object</code></li></ol><ul><li>获取键对应的值，但是<code>Object</code>类型，类似于Java的下界通配符，写入安全但是读取受限</li></ul><p>Tomcat 在启动 Web 应用时会把Tomcat内部运行所需的组件、路径、缓存等对象自动放入 ServletContext 的 attribute属性表中，所以如果运行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;--------- ServletContext attributes ---------&quot;</span>);<br>Enumeration&lt;String&gt; attrNames = servletContext.getAttributeNames();<br><span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> attrNames.nextElement();<br>    System.out.println(<span class="hljs-string">&quot;attribute: &quot;</span> + name + <span class="hljs-string">&quot; = &quot;</span> + servletContext.getAttribute(name));<br>&#125;<br></code></pre></td></tr></table></figure><p>会得到包含用户自定义属性在内的非常长的一串输出，但是其中系统自带的属性并不是我们所关心的。因此，如果要查看自己定义的属性，最好使用<code>getAttribute(String name)</code>。</p><h2 id="httpservletrequest">HttpServletRequest</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HttpServletRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServletRequest</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><p>它出现在<code>service</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><p><code>HttpServletRequest</code>提供了一系列可用于处理 HTTP请求的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/s4&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(req.getMethod()); <span class="hljs-comment">// 请求方式</span><br>        System.out.println(req.getScheme()); <span class="hljs-comment">// 协议</span><br>        System.out.println(req.getProtocol()); <span class="hljs-comment">// 协议和版本号</span><br>        System.out.println(req.getRequestURI()); <span class="hljs-comment">// 项目内的资源路径</span><br>        System.out.println(req.getRequestURL()); <span class="hljs-comment">// 项目内资源的完整路径</span><br>        System.out.println(req.getLocalPort()); <span class="hljs-comment">// 本应用所在容器的端口号  8080</span><br>        System.out.println(req.getServerName()); <span class="hljs-comment">// 客户端发请求时用的端口号，因为代理的存在可能和LocalPort不一样</span><br>        System.out.println(req.getRemoteHost()); <span class="hljs-comment">// 客户端软件的端口号</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行一下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">GET<br>http<br>HTTP/1.1<br>/demo03/s4<br>http://localhost:8080/demo03/s4<br>8080<br>localhost<br>0:0:0:0:0:0:0:1<br></code></pre></td></tr></table></figure><p>URI:统一资源标识符。用于<strong>标识某个资源</strong>。只要能唯一地定位资源，就是URI。<br />URL: 统一资源定位符。URI的一种，<strong>不仅标识资源，还指定了获取资源的协议和地址</strong>。<br />即：URL 是 URI 的一个子集，URI 更宽泛，URL 更具体。</p><p><code>0:0:0:0:0:0:0:1</code>是 IPv6 表示形式的本地回环地址，等价于IPv4 的 127.0.0.1。</p><p><strong>获取头</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Enumeration&lt;String&gt; headerNames = req.getHeaderNames();<br><span class="hljs-keyword">while</span> (headerNames.hasMoreElements()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">headerName</span> <span class="hljs-operator">=</span> headerNames.nextElement();<br>    System.out.println(headerName + <span class="hljs-string">&quot;: &quot;</span> + req.getHeader(headerName));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取请求参数</strong></p><p><code>getParameterMap()</code>返回一个<code>Map&lt;String, String[]&gt;</code>的变量，使用<code>forEach</code>遍历所有参数，这种处理方式也适用于多选的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/s5&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet5</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 根据指定的name获取键值对形式的参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>        System.out.println(username + <span class="hljs-string">&quot; &quot;</span> + password);<br><br>        <span class="hljs-comment">// 返回所有 map 的集合（更通用）</span><br>        Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();<br>        parameterMap.forEach((key, value) -&gt; &#123;<br>            System.out.println(key + <span class="hljs-string">&quot; &quot;</span> + Arrays.toString(value));<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>以上API专门用于键值对形式的参数，无论这些参数是在url中还是请求体中</strong>。get请求参数以键值对的形式放在url中，一般约定不放在请求体中。post方式放在请求体中。</p><p>以下API用于读取文本/文件/JSON：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> req.getReader(); <span class="hljs-comment">// 字符流 文本数据</span><br><span class="hljs-type">ServletInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> req.getInputStream(); <span class="hljs-comment">// 字节流 二进制数据</span><br></code></pre></td></tr></table></figure><h2 id="httpservletresponse">HttpServletResponse</h2><p>提供了一系列用于处理响应消息的方法：</p><ul><li><code>setStatus</code>: 设置状态码</li><li><code>setHeader</code>: 设置响应头的字段，传入字段名和字段值</li><li><code>setContentType</code>: 设置 MIME类型，如前所述，作用是告诉客户端响应的数据是什么类型的数据。其实用<code>setHeader</code>也能完成，但是因为太过重要所以单独封装了一个方法</li><li><code>setContentLength</code>:设置传输的内容长度，同样用<code>setHeader</code>也能完成，但是因为太过重要所以单独封装了一个方法</li><li><code>getWriter</code>:获取一个字符输出流<code>PrintWriter</code>，用于设置响应体的内容</li></ul><h1 id="请求转发和响应重定向">请求转发和响应重定向</h1><p>请求转发(Forward)响应重定向(Redirect)<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.cnblogs.com/Qian123/p/5345527.html#!comments">[3]</span></a></sup></p><h2 id="forward-转发">forward 转发</h2><p>服务器内部跳转，浏览器地址栏不变。</p><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/s1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">servlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;servlet1 service&quot;</span>);<br>        <span class="hljs-comment">// getRequestDispatcher 获取一个可以将当前请求转发或包含到指定资源的请求分派器对象</span><br>        <span class="hljs-type">RequestDispatcher</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> req.getRequestDispatcher(<span class="hljs-string">&quot;s2&quot;</span>);<br>        <span class="hljs-comment">// forward 实现请求转发功能，把请求转发给另一个Servlet</span><br>        s2.forward(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端只产生一次请求，服务端只产生一次req和resp，这一对req和resp可以一直传递下去。</p><p>当然，<code>getRequestDispatcher</code>传入的参数不仅仅局限于 Servlet，也可以是一个文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">req.getRequestDispatcher(<span class="hljs-string">&quot;test.html&quot;</span>).forward(req, resp);<br><span class="hljs-comment">// 运行后页面显示为 test.html ，但是地址栏仍然没有发生变化。</span><br></code></pre></td></tr></table></figure><p>就算是 WEB-INF 中的资源也可以通过这种方式被访问，这也是 WEB-INF访问的唯一方式。</p><p>也就是说，目标资源既可以是动态资源，也可以是静态资源，也可以是受保护的资源，但是不能是外部资源。</p><h2 id="redirect-重定向">redirect 重定向</h2><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">resp.sendRedirect(<span class="hljs-string">&quot;test.html&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>通过<code>HttpServeltResponse</code>对象的<code>sendRedirect</code>方法实现</li><li>响应重定向是服务端通过302响应码和<code>location</code>资源路径，告诉客户端让它自己去找其他资源，属于在服务器的提示下的客户端的行为。</li><li>客户端至少发送了两次请求，客户端地址栏是要变化的。</li><li>服务端产生了多对请求和响应对象，且请求和响应对象<strong>不会传递</strong>给下一个资源</li><li>重定向可以是Servlet动态资源，也可以是其他静态资源</li><li>不可以访问WEB-INF下受保护的资源（显然）</li><li>可以重定向到本项目以外的资源。</li></ul><h1 id="参考链接">参考链接</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://zh.wikipedia.org/wiki/Apache_Tomcat<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://www.cnblogs.com/mamamia/p/17748456.html<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://www.cnblogs.com/Qian123/p/5345527.html#!comments<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IP协议</title>
    <link href="/2025/05/11/IP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/05/11/IP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>参考：<ahref="https://www.cnblogs.com/kuangtf/articles/16354512.html">IP协议看这篇就够了</a>、小林coding、<ahref="https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80">wiki</a></p><h1 id="概况">概况</h1><p>TCP模块将网络包委托给 IP 模块才能发送给通信对象。</p><p>IP 协议的特点：IP协议提供<strong>无连接的</strong>、<strong>不可靠的</strong>、<strong>尽力的</strong>数据报投递服务：</p><ul><li>无连接的：通信双方无需像TCP那样建立连接便可直接通信，发送端可以在任何时刻发送数据，接收方永远也不知道自己什么时候会收到数据。</li><li>不可靠的：IP协议既不保证数据包能成功传输给对方，也不会对传输失败做任何检测，更不会通知对方本次传输是否成功。</li><li>尽力的：最大传输单元（MTU）规定了一个网络包的最大长度，以太网中一般为1500字节。对于较长的数据，IP协议会把原始数据分割成一个一个的数据包进行发送。</li></ul><h1 id="多网卡">多网卡</h1><p>当客户端设备有<strong>多个网卡</strong>（每个网卡各自有一个 IP地址），系统在发送 IP包时会根据<strong>路由表</strong>选择合适的网卡和源 IP地址。至于到底选择那个网卡？系统会查找路由表中哪个网络前缀和当前IP的<strong>匹配程度最高</strong>，将这个网卡的IP 作为 IP 包的源地址写入头部。</p><p>什么叫匹配度最高？谁和目标IP的重合度最高，谁最优先。举个例子，假设当前的路由表中有以下路由表</p><table><thead><tr><th>网络地址</th><th>子网掩码</th><th>前缀长度</th><th>接口</th></tr></thead><tbody><tr><td>192.168.1.0</td><td>255.255.255.0</td><td><code>/24</code></td><td>eth0</td></tr><tr><td>192.168.1.128</td><td>255.255.255.128</td><td><code>/25</code></td><td>eth1</td></tr><tr><td>0.0.0.0</td><td>0.0.0.0</td><td><code>default</code></td><td>eth2</td></tr></tbody></table><p>现在我们要访问IP：<code>192.168.1.130</code></p><ul><li><code>192.168.1.0</code>:根据子网掩码，可以计算该网络号可覆盖的的范围是<code>192.168.1.0 - 192.168.1.255</code></li><li><code>192.168.1.128</code>:同样计算网络的范围是<code>192.168.1.128 - 192.168.1.255</code></li><li><code>default</code>: 匹配度为0，当本地IP都不匹配时才使用</li></ul><p>可见路由1和路由2都覆盖了目标IP地址。但是路由2的网络范围比路由1更小，匹配度更高，所以优先选择路由2.</p><p>这就是操作系统和路由器采用的<strong>最长前缀匹配</strong>的机制。</p><p>再举个例子：假设你电脑的IP地址是：<code>192.168.1.100</code>，子网掩码是：<code>255.255.255.0</code>。也就是说你的本地网络号是：<code>192.168.1.0/24</code>。也就是说只能直接访问<code>192.168.1.x</code>的设备。除此之外所有的IP地址都属于外部网络，需要交给默认路由的网关转发给外部网络。</p><p>事实上，两台计算机要通讯，首先要判断的就是是否处于同一个广播域内，即网络地址（网络号）是否相同：</p><ul><li>如果网络地址相同，表明接受方在本网络上（<strong>本地网络主机</strong>），那么可以把数据包直接发送到目标主机，无需转发给其他的网络。</li><li>网络号不相同的主机称之为<strong>远程网络主机</strong>，远程网络中的主机要相互通信必须通过<strong>本地网关</strong>(GateWay)来传递转发数据。</li></ul><p>大多数情况下，当设备需要与本地子网之外的网络（比如互联网）通信时，会使用默认路由。默认路由是路由表中唯一不指定具体目标网络的路由条目，其网络目标是0.0.0.0。任何无法通过更精确匹配找到目标地址的流量都会被引导到默认路由。</p><h1 id="ip-地址">IP 地址</h1><p>常见的IP地址分为IPv4与IPv6两大类，IP地址由一串数字组成。IPv4为<code>32</code>位长，通常书写时以四组十进制数字组成，并以点分隔，如：<code>172.16.254.1</code>；IPv6为<code>128</code>位长，通常书写时以八组十六进制数字组成，以冒号分割，如：<code>2001:db8:0:1234:0:567:8:1</code>。</p><h2 id="ipv4">IPv4</h2><p>1981年，IETF定义了32位IP地址的IPv4。随着互联网的快速成长，IPv4的42亿个地址最终于2011年2月3日用尽。</p><p>IPv4地址可分为A、B、C、D、E五大类，其中E类属于特殊保留地址。</p><table><thead><tr><th>IP 第一段范围</th><th>属于哪一类</th></tr></thead><tbody><tr><td>1 ~ 126</td><td>A 类</td></tr><tr><td>128 ~ 191</td><td>B 类</td></tr><tr><td>192 ~ 223</td><td>C 类</td></tr><tr><td>224 ~ 239</td><td>D 类（组播）</td></tr><tr><td>240 ~ 255</td><td>E 类（实验）</td></tr></tbody></table><p>至于这样划分的原因，看看下面这张图就明白了：</p><p><img src="https://s21.ax1x.com/2025/05/11/pEX9idg.png" /></p><p>其中可以分配给主机使用的是A、B、C类地址。D类用于组播（Multicast），无子网掩码；E类用于实验，也没有子网掩码。</p><p>在A类、B类、C类IP地址中，如果主机号是全1，那么这个地址为<strong>直接广播地址</strong>，代表所有主机，它是用来使路由器将一个分组以广播形式发送给特定网络上的所有主机。</p><p>如果主机号全为0，那么它代表的是某一个网络，不是可分类给主机的网络号。</p><p><strong>受限广播地址</strong>（limited broadcast address）是指 IPv4地址<code>255.255.255.255</code>。它仅用于向当前本地网络中的所有主机发送消息，路由器不会该地址的广播。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP协议</title>
    <link href="/2025/05/10/TCP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/05/10/TCP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>缓慢持续更新ing</p><p>主要参考：wiki 和 小林coding，以及<ahref="https://www.cnblogs.com/jojop/p/14111160.html">这篇博客</a></p><h1 id="tcp-报文头部格式">TCP 报文头部格式</h1><p>一个 TCP 报文（TCP segment） 是 TCP协议在网络中传输的基本单位。它有一个<strong>固定格式的头部</strong>（Header）和一个<strong>可变长度的数据部分</strong>（Payload）。</p><figure><img src="https://s21.ax1x.com/2025/05/10/pEODgrd.png"alt="TCP头部格式" /><figcaption aria-hidden="true">TCP头部格式</figcaption></figure><h2 id="源端口号和目标端口号">源端口号和目标端口号</h2><ul><li><code>Source Port</code>: 16位，源端口号，标识发送端口。</li><li><code>Destination Port</code>: 16位，标识接收端口</li></ul><h2 id="序列号">序列号</h2><ul><li><code>Sequence Number</code>：32位，序号（或者序列号），有双重作用：<ul><li>如果 SYN标志位为1，那么这就是初始序列号。实际的第一个数据字节的序列号以及相应ACK 中的确认号（acknowledged number，也叫ACK号）都等于此序列号加1。</li><li>如果 SYN 标志位为 0，那么这个序列号就是当前会话中的这个 segment中第一个数据的累计字节序号。这主要是因为在 TCP 连接已经建立之后，SYN就不再使用了（为 0）。</li></ul></li></ul><h2 id="数据偏移量">数据偏移量</h2><ul><li><code>Data Offset</code>(DOffset): 4位，数据偏移量，用指定 TCP头的size，以word（32-bit，即4字节）为单位。TCP 头的最小长度是 5words（因为固定部分的 TCP 报文头正好是 5 个 word），最大是 15words，因此最小是 20 字节，最大是 60 字节，报头最多可以容纳 40字节的选项（options）字段。这个字段之所以叫“offset”，是因为它也表示从TCP 段起始处 到 实际数据开始位置(Data) 的偏移量。</li></ul><h2 id="保留位">保留位</h2><ul><li><code>Reserved</code>(Rsrvd): 4 bits, 保留位，供未来使用，应当设置为0.在没有进一步的规范的情况下，发送方不应该设置这些位，接收方也应当忽略他们（就算被不慎设置了）。</li></ul><h2 id="状态位">状态位</h2><ul><li><code>Flags</code>: 8 bits, 8位状态位，包含以下 8 个标志位：<ul><li><code>CWR</code>(Congestion window reduced):<strong>拥塞窗口已减少</strong>标志，由<strong>发送方</strong>设置，以表明它收到了设置了ECE 标志的 TCP段，并且已经根据拥塞控制机制作出了响应。它的作用是：发送方告诉接收方“我知道网络拥塞了，我已经减小了发送窗口”。<strong>有的图解会把<code>CWR</code>归入保留位</strong>。</li><li><code>ECE</code>(ECN-Echo): 1 bit, ECN回显标志具有双重作用，其含义取决于 SYN 标志位：<ul><li>如果 SYN 标志位为1，表示该 TCP peer 支持 ECN 功能</li><li>如果 SYN 标志位为0，则在正常传输期间接收到了 IP标头中设置了拥塞经历标志（<code>ECN=11</code>）的数据包。这告诉 TCP发送方网络已经发生或即将发生拥塞。<strong>有的图解会把<code>ECE</code>归入保留位</strong>。</li></ul></li><li><code>URG</code>, 1 bit, 表示 “紧急指针（UrgentPointer）”字段是有效的。当 URG 标志位置为 1 时，说明当前这个 TCP报文中有“紧急数据”；此时，紧急指针字段告诉接收方：紧急数据在数据段中结束的位置。通常用于telnet 等老旧协议，<strong>现在很少用</strong>。</li><li><code>ACK</code>: 1 bit, 指示确认字段有效。<strong>客户端发送初始SYN数据包之后的所有数据包都应设置此标志</strong>。即，只有客户端请求连接的第一次握手时不用设置ACK标志位，毕竟在此之前客户端还没有收到过信息。</li><li><code>PSH</code>: 1 bit, 表示“推送功能（PushFunction）”，请求将缓冲数据立即推送到接收应用程序。</li><li><code>RST</code>: 1 bit, 重新连接。</li><li><code>SYN</code>: 1 bit,同步序列号。<strong>只有在前两次握手的过程应设置此标志</strong>。一些其他的标志位和字段根据SYN 改变含义，有的只有在SYN为1时有效，有的只有在SYN清空有效。</li><li><code>FIN</code>: 1 bit, 表示发送方的最后一个数据包，<strong>用于TCP 连接的正常关闭</strong>。当一个主机发送带有 FIN=1 的 TCP报文时，它表示主机请求断开连接，然后回进入终止连接的四次挥手进程。</li></ul></li></ul><h2 id="窗口">窗口</h2><ul><li>16位，接收窗口的大小，表示本报文段的<strong>发送方</strong>目前愿意接收的窗口大小单位数。（详见“流量控制”和“窗口缩放”部分）。</li></ul><h2 id="校验和">校验和</h2><p><code>Checksum</code>: 16 bits， 16 位校验和字段用于对 TCP报头、有效载荷(payload)和 IP伪报头(pseudo-header)进行错误校验。伪报头由源 IP 地址、目标 IP 地址、TCP协议号 (6) 以及 TCP报头和有效载荷的长度（以字节为单位）组成。具体见<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Internet_checksum">[1]</span></a></sup></p><p>payload data:有效载荷数据，在计算机网络中，指传输的数据中除去协议头和校验码等控制信息之外的实际数据部分。</p><h2 id="紧急指针">紧急指针</h2><p><code>Urgent Pointer</code>: 16 bits, 如果设置了 URG 标志，则此 16位字段是相对于指示最后一个紧急数据字节的序列号的偏移量。<strong>现代协议几乎不使用URG和紧急指针</strong>。</p><h2 id="选项">选项</h2><p>选项（<code>TCP Option</code>）：长度可变，0–320 位（即 0–40字节），单位是 32 位（4 字节）； 其大小由 TCP 报文头的 Data Offset字段决定，计算公式是： <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Options</span> 字段大小 <span class="hljs-operator">=</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Data</span> <span class="hljs-built_in">Offset</span> <span class="hljs-operator">-</span> <span class="hljs-number">5</span><span class="hljs-punctuation">)</span> × <span class="hljs-number">32</span> 位<br></code></pre></td></tr></table></figure></p><p>如果这个字段存在，数据偏移量将大于 5 words。因为 Data Offset表示的是以 word（32 位）为单位的 TCP头部长度，所以必须通过在末尾添加填充 0，将 TCP 头部长度填充为 4字节的整数倍。</p><h1 id="三次握手">三次握手</h1><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP连接的建立，通常称为<strong>三次握手</strong>。</p><p>先弄清楚几个概念：</p><ul><li><strong>序列号</strong>（SequenceNumber）：是<strong>发送方</strong>为数据流中的字节指定的“标记”，表示它正在发送哪些字节。它告诉接收方“<strong>我准备从这个序列号开始给你发数据</strong>”。</li><li><strong>确认号</strong>（AcknowledgmentNumber）：是<strong>接收方</strong>告诉发送方它已经成功接收到的字节的<strong>下一个序列号</strong>，表示接收方已经收到了所有小于该确认号的字节。它告诉发送方“<strong>接下来我准备接收从这个序列号开始的数据</strong>”。</li></ul><div class="note note-secondary">            <p>在客户端尝试连接服务器之前，服务器必须先绑定并监听某个端口，以便开放连接：这称为<strong>被动开启</strong>(passiveopen)。被动打开建立后，客户端可以通过三次握手(three-way/3-stephandshake)发起<strong>主动开启</strong>(active open)来建立连接。</p>          </div><p>三次握手的步骤如下：</p><ol type="1"><li><strong>SYN</strong>：客户端向服务器发送 SYN 报文（SYN标志位设置为1）主动开启连接。客户端把TCP段的序列号设置为一个随机数A。因为客户端还没有受到过消息，所以这里不用设置确认号，也不包含任何应用层的数据。</li><li><strong>SYN-ACK</strong>：作为回复，服务器响应了一个SYN-ACK报文。该TCP段的确认号被设置为A+1，而序列号被服务器设置为另一个随机数B。到这里客户端已经完成了一发一收，所以处于<code>ESTABLISHED</code>状态。</li><li><strong>ACK</strong>：最后，客户端把 ACK发送给服务器，这时的序列号设置为接收到的确认号，即A+1，而确认号被设置成接收到的序列号加一，即B+1。<strong>这次报文可以携带客户端到服务器的数据</strong>。至此服务器也完成了一发一收，也处于<code>ESTABLISHED</code>状态。</li></ol><p><img src="https://s21.ax1x.com/2025/05/11/pEOHxFf.png" /></p><p>步骤1和2从客户端到服务器的方向建立和确认序列号，步骤2和步骤3从服务器到客户端的方向建立和确认序列号。这些步骤完成之后，客户端和服务器都完成了确认，全双工通信正式建立。</p><p>可见，三次握手目的是保证双方都有发送和接收的能力。</p><h1 id="分割数据">分割数据</h1><p>TCP传输的数据归根结底还是来源于应用程序产生的HTTP请求消息。但是，TCP每个段能传输的数据长度是有最大限制的：</p><ul><li>MTU：一个网络包（IP头+TCP头+数据）的最大长度，以太网中一般为1500字节。</li><li>MSS：除去IP头和TCP头之后，一个网络包所能容纳的TCP数据的最大长度。</li></ul><p>如果数据的长度超过了<code>MSS</code>，则会将数据以<code>MSS</code>的长度为单位进行切分，每一块都会被放进单独的网络包中，加上TCP头部后交给IP模块发送出去。</p><hr /><p>在浏览器中输入网址并回车后，浏览器会向服务器发起 HTTP请求，这是一段纯文本数据，浏览器将这段数据交给操作系统的协议栈，操作系统通过上文讲述的TCP协议建立连接、发送。如果数据的长度超过了<code>MSS</code>，则会将数据以<code>MSS</code>的长度为单位进行切分，每一块都会被放进单独的网络包中，加上TCP头部后交给IP模块发送出去。远程服务器接收到TCP报文后，TCP协议层按照序列号重新组装数据，然后把完整的HTTP请求交给HTTP服务器程序，最后由服务器解析并做出响应，例如返回请求的网页内容。这就是在浏览器输入网址后发生的事情。</p><h1 id="参考链接">参考链接</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://en.wikipedia.org/wiki/Internet_checksum<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Computer Networking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 查缺补漏</title>
    <link href="/2025/05/08/Java%E5%90%8E%E7%BB%AD%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/"/>
    <url>/2025/05/08/Java%E5%90%8E%E7%BB%AD%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="java-scanner">Java Scanner</h1><p><code>java.util.Scanner</code> 是 Java5 的新特征，我们可以通过Scanner 类来获取用户的输入。ACM 模式必备。</p><p><strong>注意</strong>：JUnit的测试方法（如<code>@Test</code>）默认不会连接控制台（<code>System.in</code>），一定要在<code>main()</code>方法中运行。</p><p>Scanner 类的UML 图如下：</p><p><img src="https://s21.ax1x.com/2025/05/07/pELmNqI.png" /></p><p>它实现了<code>AutoCloseable</code>接口，可以使用try-with-resources自动关闭资源。</p><p>创建一个 Scanner 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure><p><strong>接收 String 类型输入</strong>：</p><ul><li><code>next()</code><ul><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，<code>next()</code>方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li><code>next()</code> 不能得到带有空格的字符串。</li></ul></li><li><code>nextLine()</code><ul><li>以Enter为结束符,也就是说<code>nextLine()</code>方法返回的是输入回车之前的所有字符。</li><li>可以获得空白</li></ul></li></ul><p><strong>接收<code>int</code>、<code>long</code>类型的输入</strong>，可以使用<code>nextInt()</code>、<code>nextLong()</code>等。但是有以下几点要注意的地方：</p><ol type="1"><li>这类方法不会消耗回车键产生的换行符，但是<code>nextLine()</code>会读取换行符，所以在二者混用的时候要注意：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannerDemoTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        System.out.print(<span class="hljs-string">&quot;请输入一个数字：&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> scan.nextInt();  <span class="hljs-comment">// 输入：123</span><br><br>        System.out.print(<span class="hljs-string">&quot;请输入一句话：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> scan.nextLine();  <span class="hljs-comment">// 问题出在这里</span><br><br>        System.out.println(<span class="hljs-string">&quot;你输入的数字是：&quot;</span> + num);<br>        System.out.println(<span class="hljs-string">&quot;你输入的话是：&quot;</span> + line);<br><br>        scan.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台打印：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">请输入一个数字：123<br>请输入一句话：你输入的数字是：123<br>你输入的话是：<br></code></pre></td></tr></table></figure><p>解释：输入<code>123</code>，按下回车键的时候，<code>123</code>赋值给了<code>num</code>，与此同时<code>line</code>接收到回车符，因此还没来得及输入一句话程序就结束了。</p><p>解决方法：在<code>int num = scan.nextInt();</code>后面紧跟一个<code>scan.nextLine()</code>，把回车吸收掉。</p><ol start="2" type="1"><li><code>nextInt()</code>等接收特定数据类型<strong>不能接收其他类型的数据</strong>，否则运行时会报异常<code>Exception in thread "main" java.util.InputMismatchException</code>，所以在接收数据之前最好使用<code>hasNextInt()</code>判断输入的数据是否符合要求。</li><li><code>nextInt</code>、<code>next()</code>等都可以把空格作为分隔符，这样方便我们在一行内输入一个数组，比如对于下面这种输入格式</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">3<br>1 4 5 -1<br>1 3 4 -1<br>2 6 -1<br></code></pre></td></tr></table></figure><p>利用<code>nextInt()</code>和适当的条件判断就能搞定。</p><h1 id="测试类的命名">测试类的命名</h1><p>使用单元测试JUnit时，如果测试类的命名不规范，那么IDEA会报警告：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Test class name &#x27;methodTest&#x27; doesn&#x27;t match regex &#x27;[A-Z][A-Za-z\d]*Test(s|Case)?|Test[A-Z][A-Za-z\d]*|IT(.*)|(.*)IT(Case)?&#x27;<br></code></pre></td></tr></table></figure><p>某些测试框架（如 Maven Surefire、JUnit、IDE插件）会用正则表达式来自动识别哪些类是“测试类”。</p><p>上面这个正则表达式规定了测试类必须符合以下格式之一：</p><ul><li>以大写字母开头，并以 Test、Tests 或 TestCase 结尾，如：<ul><li>LoginTest</li><li>CalculatorTests</li><li>NetworkTestCase</li></ul></li><li>或者 以 Test 开头，如：<ul><li>TestLogin</li><li>TestConnectionManager</li></ul></li><li>或者包含 IT（通常代表集成测试）：<ul><li>UserServiceIT</li><li>ITLoginFlow</li></ul></li></ul><h1 id="实用方法">实用方法</h1><h2 id="split">split</h2><p>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] split(String regex) &#123;<br>    <span class="hljs-keyword">return</span> split(regex, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：根据给定的正则表达式分割字符串。</p><ul><li><code>参数</code>：定界正则表达式</li><li><code>返回值</code>：根据给定的正则表达式分割得到的<code>String[]</code>数组</li></ul><p>举例：输入 IP地址和子网掩码，输出网络地址和主机地址。第一步从给定的字符串中提取数字的过程可以用<code>split</code>完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] parse(String str) &#123;<br>    String[] newStr = str.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        result[i] = Integer.parseInt(newStr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以下单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.1.10&quot;</span>;<br>    <span class="hljs-type">int</span>[] result = parse(s);<br>    System.out.println(Arrays.toString(result));<br>    <span class="hljs-comment">// [192, 168, 1, 10]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可见原字符串中的小数点已经被成功去掉，四个数字被转换成整型变量保存在了数组中。</p><p>小数点属于正则表达式中的特殊字符，<code>.</code>用于匹配任意一个字符，想匹配它本身必须在前面加上<code>\\</code>。所以必须用<code>"\\."</code>来表示匹配小数点。类似的特殊字符还有：</p><table><thead><tr><th>字符</th><th>含义</th><th>匹配自身需写作</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意单个字符（除换行）</td><td><code>\\.</code></td></tr><tr><td><code>*</code></td><td>匹配前面的内容零次或多次</td><td><code>\\*</code></td></tr><tr><td><code>+</code></td><td>匹配前面的内容一次或多次</td><td><code>\\+</code></td></tr><tr><td><code>?</code></td><td>匹配前面的内容零次或一次</td><td><code>\\?</code></td></tr><tr><td><code>^</code></td><td>匹配字符串的开头</td><td><code>\\^</code></td></tr><tr><td><code>$</code></td><td>匹配字符串的结尾</td><td><code>\\$</code></td></tr><tr><td><code>[</code></td><td>开始一个字符类</td><td><code>\\[</code></td></tr><tr><td><code>]</code></td><td>结束一个字符类</td><td><code>\\]</code></td></tr><tr><td><code>&#123;</code></td><td>指定匹配次数（如 <code>&#123;3&#125;</code>）</td><td><code>\\&#123;</code></td></tr><tr><td><code>&#125;</code></td><td>结束指定次数</td><td><code>\\&#125;</code></td></tr><tr><td><code>(</code></td><td>开始一个分组</td><td><code>\\(</code></td></tr><tr><td><code>)</code></td><td>结束一个分组</td><td><code>\\)</code></td></tr><tr><td><code>\|</code></td><td>逻辑“或”</td><td><code>\\\|</code></td></tr><tr><td><code>\\</code></td><td>转义符本身</td><td><code>\\\\</code></td></tr></tbody></table><h2 id="replaceall">replaceAll</h2><p>使用场景：<ahref="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a></p><p>序列化，使用<code>StringBuilder</code>得到结果之后，需要删除尾部多余的<code>null</code>，这时可以使用<code>replaceAll</code></p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newString</span> <span class="hljs-operator">=</span> originalString.replaceAll(String regex, String replacement);<br></code></pre></td></tr></table></figure><ul><li><code>regex</code>：要匹配的正则表达式（pattern）</li><li>`replacement：用于替换的字符串</li></ul><p>在这道算法中的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> sb.toString();<br><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> res.replaceAll(<span class="hljs-string">&quot;(null,)+$&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-keyword">if</span>(result.endsWith(<span class="hljs-string">&quot;,&quot;</span>))<br>    result = result.substring(<span class="hljs-number">0</span>, result.length()-<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">return</span> result+<span class="hljs-string">&quot;]&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>正则表达式<code>"(null,)+$"</code><ul><li><code>(null,)+</code>：匹配一个或多个<code>"null,"</code>。<code>+</code>是定位符，表示一个或多个匹配。</li><li><code>$</code>表示从文本的末尾位置开始匹配。</li></ul></li></ul><p>所以该正则的含义就是字符串末尾的连续多个<code>null,</code>。</p><h1 id="substring">substring</h1><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span> &#123;...&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex)</span> &#123;<br>        <span class="hljs-keyword">return</span> substring(beginIndex, length());<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><code>beginIndex</code>：起始索引，包含</li><li><code>endIndex</code>：结束索引，不包含。如果没有该参数，则从起始索引开始截取到末尾（本质上还是调用的第一个方法）</li><li>返回值：指定的子字符串</li></ul><h1 id="栈应该用哪个实现类">栈应该用哪个实现类？</h1><h2 id="先说结论">先说结论</h2><p><code>Stack.java</code>的文档注释中是这样解释的：</p><div class="note note-secondary">            <p>Stack 类表示一个后进先出 (LIFO) 的对象堆栈。它扩展了 Vector类，增加了五个操作，允许将向量视为堆栈。它提供了常见的 push 和 pop操作，以及一个用于查看堆栈顶部元素的方法、一个用于测试堆栈是否为空的方法，以及一个用于在堆栈中搜索元素并确定其距离顶部距离的方法。</p><p>堆栈首次创建时不包含任何元素。</p><p><strong>Deque 接口及其实现提供了一套更完整、更一致的 LIFO堆栈操作，应优先使用此类</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure>          </div><p><code>Deque</code>右两个常用实现类：<code>LinkedList</code>和<code>ArrayDeque</code>。</p><p>在<code>ArrayDeque.java</code>的开头文档注释：</p><div class="note note-secondary">            <p>Deque接口的动态数组实现。数组双端队列没有容量限制；它们会根据需要扩容以支持使用。它们不是线程安全的；在没有外部同步的情况下，它们不支持多线程并发访问。禁止使用Null 元素。<strong>此类用作堆栈时可能比 Stack 更快，用作队列时可能比LinkedList 更快</strong>。</p>          </div><p>所以应该使用<code>ArrayDeque</code>模拟栈和队列。</p><h2 id="为什么不使用stack">为什么不使用Stack</h2><p>Stack 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vector</span>&lt;E&gt; &#123;...&#125;<br></code></pre></td></tr></table></figure><p><code>Stack</code>继承了<code>Vector</code>。<code>Vector</code>是一个线程安全的动态数组，但它使用的是同步方法（<code>synchronized</code>），这在单线程环境下反而造成了不必要的性能开销。查看<code>Vector</code>的源码会发现几乎每一个方法被都加上了<code>synchronized</code>修饰，比如添加和删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addElement</span><span class="hljs-params">(E obj)</span> &#123;<br>    modCount++;<br>    add(obj, elementData, elementCount);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(Object obj)</span> &#123;<br>  modCount++;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexOf(obj);<br>  <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>      removeElementAt(i);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是非常粗暴且不合理的。</p><p><code>Stack</code>作为它的子类也强制使用同步机制，就算是没有线程安全问题也是如此，这样会明显降低性能。</p><h2 id="为什么arraydeque更优">为什么ArrayDeque更优</h2><p><code>ArrayDeque</code>是一个基于<strong>循环数组</strong>实现的双端队列，访问速度非常快。而<code>LinkedList</code>是链表，每次访问的时候都必须从头节点开始往下找，明显慢得多。另一方面，<code>ArrayDeque</code>会自动扩容，而链表的扩容需要频繁创建新的节点对象，垃圾回收负担大。</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基本使用</title>
    <link href="/2025/05/06/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/05/06/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库常识">数据库常识</h1><h2 id="数据库的关系模型">数据库的关系模型</h2><p>什么是关系数据库？</p><blockquote><p>关系数据库是一种用于存储相互关联的数据点并提供数据点访问的数据库。它采用关系模型，直接、直观地在表中展示数据。</p><p>在关系数据库中，表中的每一行都代表一条<strong>记录</strong>，每条记录都具有一个唯一的ID（又被称为<strong>键</strong>），而表中的列则用于存储数据的<strong>属性</strong>——每条记录的每一个属性通常都有一个值。籍此，用户可以轻松在数据点之间建立关联。</p><p>数据库的关系模型（Relational Model）是当前最广泛使用的数据模型，它由IBM 的 E.F. Codd 在 1970年提出。该模型使用<strong>二维表格</strong>来组织数据，具有强大的理论基础和良好的实用性。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.oracle.com/cn/database/what-is-a-relational-database/">[1]</span></a></sup></p></blockquote><p>举个例子：这是用来描述学生信息的关系表：</p><table><thead><tr><th>student_id (PK)</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1001</td><td>Alice</td><td>20</td></tr><tr><td>1002</td><td>Bob</td><td>21</td></tr><tr><td>1003</td><td>Charlie</td><td>19</td></tr></tbody></table><ul><li><code>student_id</code>是学生的<strong>键</strong></li></ul><p>这是可选课程表：</p><table><thead><tr><th>course_id (PK)</th><th>course_name</th><th>credits</th></tr></thead><tbody><tr><td>C001</td><td>Database Systems</td><td>3</td></tr><tr><td>C002</td><td>Operating Systems</td><td>4</td></tr><tr><td>C003</td><td>Networks</td><td>3</td></tr></tbody></table><ul><li><code>course-id</code>是课程的<strong>键</strong></li></ul><p>现在这些学生们需要选课，于是就有了选课表：</p><table><thead><tr><th>student_id (FK)</th><th>course_id (FK)</th><th>grade</th></tr></thead><tbody><tr><td>1001</td><td>C001</td><td>A</td></tr><tr><td>1001</td><td>C002</td><td>B</td></tr><tr><td>1002</td><td>C001</td><td>A-</td></tr><tr><td>1003</td><td>C003</td><td>B+</td></tr></tbody></table><p>通过上表，借由学生id就可以查询到课程id进而查询课程信息，又可以查询到学生信息，这样就建立起了不同关系表之间的映射关系。</p><h2 id="数据类型">数据类型</h2><p>关系数据库支持的数据类型主要包括数值、字符串、日期和时间、布尔、二进制。</p><blockquote><p>通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。</p></blockquote><h2 id="sql">SQL</h2><p>SQL（Structured QueryLanguage），即结构化查询语言，是一种用于<strong>管理关系型数据库</strong>的标准编程语言。不同的数据库都支持SQL，所以使用SQL这一种标准语言就可以操作不同的数据库。</p><p>除了 SQL 标准之外，大部分 SQL数据库程序都拥有它们自己的私有扩展，这些扩展不能用在其他的数据库中。但是如果只使用SQL的核心功能的话，那不会有太大问题，常用的功能是相互兼容的。</p><p>SQL 定义了以下五种语句：</p><table><thead><tr><th>类别</th><th>关键作用</th><th>常见关键字</th></tr></thead><tbody><tr><td>DDL</td><td>定义结构，通常由管理员执行</td><td><code>CREATE</code>, <code>DROP</code>, <code>ALTER</code></td></tr><tr><td>DML</td><td>操作数据，属于应用程序的日常操作</td><td><code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code></td></tr><tr><td>DQL</td><td>查询数据，供用户查询使用，最为频繁</td><td><code>SELECT</code></td></tr><tr><td>DCL</td><td>控制权限</td><td><code>GRANT</code>, <code>REVOKE</code></td></tr><tr><td>TCL</td><td>管理事务</td><td><code>COMMIT</code>, <code>ROLLBACK</code></td></tr></tbody></table><p><img src="https://s21.ax1x.com/2025/05/03/pEbWCOe.png" /></p><p>SQL的关键字不区分大小写，但是对于表名和列名，不同数据库的规定不同，所以最好关键词一律大写。表名和列名一律小写。</p><h1 id="关系模型构成">关系模型构成</h1><p>用于唯一区分不同记录的字段就是主键。不能使用业务相关的字段作为主键。</p><p>将数据与另一张表联系起来的字段称为外键。</p><p>索引：加快查询速度。</p><blockquote><p>在关系数据库中，索引是用于提高查询效率的重要数据结构。索引可以让数据库在查询时不必遍历整个表，而是快速定位到符合条件的记录，从而显著提升检索速度。</p><p>然而，索引也有其局限性。索引的主要缺点是在执行插入、更新和删除操作时，数据库需要同时调整所有相关的索引，这会增加系统开销。索引数量越多，数据修改的速度就越慢。因此，在设计数据库时，必须在查询优化和修改性能之间权衡。</p></blockquote><p>数据库会自动为主键创建索引，<strong>主键索引的查询效率最高</strong>，因为主键保证每条记录的唯一性。</p><p>唯一索引：可以通过命令为需要确保唯一的数据创建唯一索引，或者添加唯一约束。</p><h1 id="基本的查询操作">基本的查询操作</h1><h2 id="基本查询">基本查询</h2><p><code>SELECT &lt;定义列的名字&gt; FROM &lt;表名&gt;</code></p><p>例如：<code>SELECT * FROM students;</code>查询<code>students</code>表中的所有列</p><h2 id="条件查询">条件查询</h2><p><code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</code></p><p>使用<code>WHERE</code>指定搜索条件。条件表达式可以用</p><ul><li><code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2</li><li><code>&lt;条件1&gt; OR &lt;条件2&gt;</code>表示满足条件1或者满足条件2。</li></ul><p>应当注意，<code>AND</code>比<code>OR</code>有更高的运算优先级，某些情况下需要使用圆括号<code>()</code>指明运算先后顺序。</p><p><code>BETWEENT AND</code>：查询位于两个值之间的数据，两边都是闭区间。</p><p><code>IN</code>操作符用来指定条件范围，范围中的每个条件都可以进行匹配。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_id, cust_name<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> cust_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">10001</span>, <span class="hljs-number">10003</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cust_name;<br></code></pre></td></tr></table></figure><p>把 customers 表中的<code>cust_id</code>为 10001 <strong>或</strong>10003的数据查询出来。<code>IN</code>的作用实际上和<code>OR</code>没有差别，它的优点体现在：</p><ul><li>IN操作符的语法更清楚且更直观；</li><li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）；</li><li>IN操作符一般比OR操作符清单执行更快；</li><li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</li></ul><p>还有一个关键字是<code>NOT</code>。WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">1002</span>, <span class="hljs-number">1003</span>)<br></code></pre></td></tr></table></figure><p>筛选所有 vend_id 不是1002或1003的数据。NOT实际上是MySQL的特性：</p><div class="note note-primary">            <p>MySQL支持使用NOT对IN、BETWEEN和EXISTS<strong>子句</strong>取反，这与多数其他DBMS允许使用NOT对各条件取反有很大的差别。</p>          </div><h2 id="排序">排序</h2><p><code>SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</code></p><p><code>DESC</code>表示倒序，默认为<code>ASC</code>即升序。</p><p><code>ORDER BY</code>要放到<code>WHERE</code>的后面。</p><h2 id="分页查询">分页查询</h2><p>在 SQL中，分页查询用于从大型数据集中按页提取一部分数据，以便在应用程序或网页上逐步显示。</p><p>分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序：</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询第1页:</span><br><span class="hljs-keyword">SELECT</span> id, name, gender, score<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">3</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>上面的语句表示：选取<code>students</code>中 id, name, gender,score的列，按照分数从高到低排序，<strong>最多只取</strong>前3条（第1页的3条记录，从第0条开始）。</p><p>所以<code>LIMIT</code>语句其实是一个<strong>截取</strong>的过程，输出的结果在外界看来好像实现了分页效果。</p><ul><li>LIMIT总是设定为pageSize；</li><li>OFFSET计算公式为pageSize * (pageIndex - 1)。</li></ul><p>如果查询结果为空，则会返回<code>Empty set</code>。<code>OFFSET</code>是可选的，默认为0。</p><h2 id="聚合查询">聚合查询</h2><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数（也叫数据处理函数），使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p><h3 id="文本处理函数">文本处理函数</h3><ul><li><code>Trim()</code>:去除文本两端的空格，也有<code>RTrim()</code>去除右边的空格，<code>LTrim()</code>去除左边的空格。</li><li><code>Upper()</code>: 将文本转换为大写。</li><li><code>Left()</code>: 返回串最左边的字符</li><li><code>Length()</code>: 返回串的长度</li><li><code>Locate()</code>: 找出串的第一个字串</li><li><code>Lower()</code>: 将串转换为小写</li><li><code>Ltrim()</code>: 去掉串左边的空格</li><li><code>Right()</code>: 返回串右边的字符</li><li><code>Soundex()</code>: 返回串的SOUNDEX值</li><li><code>SubString()</code>: 返回串的字符</li></ul><h3 id="数据处理函数">数据处理函数</h3><p>MySQL 给出了5个以<code>row</code>为单元运行的聚集函数，如下表：</p><table><thead><tr><th>聚合函数</th><th>说明</th></tr></thead><tbody><tr><td><code>COUNT()</code></td><td>返回指定列的行数</td></tr><tr><td><code>SUM()</code></td><td>返回指定列值之和</td></tr><tr><td><code>AVG()</code></td><td>返回特定数值列的平均值</td></tr><tr><td><code>MAX()</code></td><td>返回指定列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回指定列的最小值</td></tr></tbody></table><blockquote><p>COUNT 有两种使用方式： - 使用 COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值 - 使用COUNT(列名) 对特定列中具有值的行进行计数，忽略 NULL 值。</p></blockquote><p>经常与之结合使用的还有:</p><ul><li><code>CEILING()</code>: 向上取整</li><li><code>FLOOR()</code>: 向下取整</li></ul><p>例如<code>SELECT MAX(score), MIN(score) FROM students;</code>用于计算学生的最高分和最低分。</p><p>使用聚合查询时可以给结果起一个别名，使用<code>AS</code>标记：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num <span class="hljs-keyword">FROM</span> students;<br></code></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">+-----+<br>| num |<br>+-----+<br>|  10 |<br>+-----+<br>1 row in set (0.024 sec)<br></code></pre></td></tr></table></figure><p>聚合查询语句同样可以和条件语句等一起使用。</p><blockquote><p>要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL：</p></blockquote><p>如果在列名的前面加上<code>DISTINCT</code>关键字，那么只会计算不同的数据，相同的数据不会被重复计算。</p><ul><li><code>SELECT COUNT(DISTINCT department_id) FROM employees;</code>统计有多少个不同的<code>department_id</code>。</li></ul><p>但是<code>COUNT(DISTINCT *)</code>是非法的，因为<code>COUNT(*)</code>的计算结果固定为总行数。</p><h1 id="分组">分组</h1><h2 id="group-by">GROUP BY</h2><p>关键词：<code>GROUP BY</code>。分组操作常常需要把分组标准也加入表中，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 第一列是性别，第二列是对应的数量，起一个新名字total</span><br><span class="hljs-keyword">SELECT</span> gender, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> total<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> gender;<br></code></pre></td></tr></table></figure><p>查询结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">+--------+-------+<br>| gender | total |<br>+--------+-------+<br>| M      |     5 |<br>| F      |     5 |<br>+--------+-------+<br>2 rows in set (0.013 sec)<br></code></pre></td></tr></table></figure><p>GROUP BY 子句指示 MySQL分组数据，然后对每个组而不是整个结果集进行聚集。</p><p><strong>注意</strong>：</p><ul><li>除聚集计算语句外，SELECT 语句中的每个列都必须在 GROUP BY子句中给出。</li><li>GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。</li><li>在GROUPBY后面紧接<code>WITH ROLLUP</code>关键字可以在最后一行加上合计。</li></ul><h2 id="having">HAVING</h2><p>HAVING关键字的作用是<strong>对分好的组进行过滤</strong>。之前我们使用 WHERE对表中的行进行过滤，但是WHERE不能用于分组的情况，这时应该使用HAVING。他们的唯一区别是<strong>WHERE过滤行，HAVING过滤组</strong>。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> vend_id, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> products <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> vend_id <span class="hljs-keyword">with</span> <span class="hljs-keyword">rollup</span> <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>将<code>products</code>表中按照 vend_id分组后，只保留行数大于等于3的组别。</p><h2 id="select-子句顺序">SELECT 子句顺序</h2><ol type="1"><li>SELECT</li><li>FROM</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>ORDER BY</li><li>LIMIT</li></ol><h1 id="多表查询联结表">多表查询（联结表）</h1><p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。联结是利用SQL的SELECT 能执行的最重要的操作，很好地理解联结及其语法是学习 SQL的一个极为重要的组成部分。</p><p>关键是，一个表中的相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础。<strong>关系表的设计就是要保证把信息分解成多个表，一类数据一个表</strong>。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</p><p>现在我们手上有两个表格：<strong>班级表</strong></p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>class1</td></tr><tr><td>2</td><td>class2</td></tr><tr><td>3</td><td>class3</td></tr><tr><td>4</td><td>class4</td></tr></tbody></table><p>和<strong>学生表</strong></p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>ming</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>hong</td><td>F</td><td>95</td></tr><tr><td>3</td><td>1</td><td>jun</td><td>M</td><td>88</td></tr><tr><td>4</td><td>1</td><td>mi</td><td>F</td><td>73</td></tr><tr><td>5</td><td>2</td><td>bai</td><td>F</td><td>81</td></tr><tr><td>6</td><td>2</td><td>bing</td><td>M</td><td>55</td></tr><tr><td>7</td><td>2</td><td>ling</td><td>M</td><td>85</td></tr><tr><td>8</td><td>3</td><td>xin</td><td>F</td><td>91</td></tr><tr><td>9</td><td>3</td><td>wang</td><td>M</td><td>89</td></tr><tr><td>10</td><td>3</td><td>li</td><td>F</td><td>85</td></tr></tbody></table><p>这里的外键是<code>class_id</code>，它包含了班级表的主键值</p><p>连接是一种机制，用来在一条SELECT语句中关联表，因此称之为连接(JOIN)。采用连接的查询称之为<strong>SQLJOIN连接查询</strong>。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/68136613">[2]</span></a></sup></p><figure><img src="https://s21.ax1x.com/2025/05/04/pEbjEAP.png"alt="联结的分类" /><figcaption aria-hidden="true">联结的分类</figcaption></figure><h2 id="等值联结">等值联结</h2><p>等值联结基于两个表之间的相等数据进行连接。应当确保所有的联结都有WHERE 子句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> classes.name, students.name <span class="hljs-keyword">from</span> classes, students <span class="hljs-keyword">where</span> classes.id <span class="hljs-operator">=</span> students.class_id;<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://s21.ax1x.com/2025/05/17/pEvKwWt.png" /></p><h2 id="inner-join-内连接">INNER JOIN 内连接</h2><p>对上述sql语句使用不同的语法，也可以实现相同的功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> classes.name, students.name <span class="hljs-keyword">from</span> classes <span class="hljs-keyword">join</span> students <span class="hljs-keyword">on</span> classes.id <span class="hljs-operator">=</span> students.class_id;<br></code></pre></td></tr></table></figure><p>此语句中的SELECT与前面的SELECT语句相同，但FROM子句不同。这里，两个表之间的关系是FROM子句的组成部分，以INNERJOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</p><div class="note note-secondary">            <p>ANSI SQL规范首选INNERJOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。</p>          </div><hr /><p>下面正式给出内连接的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.id, A.name, B.name<br><span class="hljs-keyword">FROM</span> classes A<br><span class="hljs-keyword">JOIN</span> students B<br><span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.class_id;<br></code></pre></td></tr></table></figure><p>当然，内连接也适用于只有一个表的情况。假如已知students表中一个学生的名字为bai，现在要查询和他在同一班级中的其他所有学生的信息，可以使用以下sql语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> p1.class_id, p1.name<br><span class="hljs-keyword">from</span> students <span class="hljs-keyword">as</span> p1 <span class="hljs-keyword">join</span> students <span class="hljs-keyword">as</span> p2<br><span class="hljs-keyword">on</span> p1.class_id <span class="hljs-operator">=</span> p2.class_id<br><span class="hljs-keyword">and</span> p2.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bai&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这里使用的是两个完全相同的表，但是使用了别名。</p><h2 id="outer-join-外部连接">OUTER JOIN 外部连接</h2><p>左连接是<strong>外部连接</strong>的一种，考虑下面的业务情景：我们有一个表<code>customers</code>，其中存储了所有客户的id等基本信息。现在另有一个表<code>orders</code>记录了客户所下的订单信息。现在我们要查询客户的下单情况，包括没有下单的客户也要记录在内。</p><p>这时如果使用内连接，会直接忽略没有下单的用户。解决方法是使用外部联结，保留客户表中的所有记录，即使订单表中没有记录与之匹配。</p><p>与内部联结关联两个表中的行不同的是，<strong>外部连接还包括没有关联行的行</strong>。在使用OUTERJOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTERJOIN右边的表，而LEFT指出的是OUTERJOIN左边的表）。它们之间的唯一差别是所关联的表的顺序不同。</p><p>左连接：获取左表中的<strong>所有记录</strong>，即使在右表没有对应匹配的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 左连接：显示A表所有记录，即使在B表中没有匹配</span><br><span class="hljs-comment">-- 没有匹配的项则以NULL值代替</span><br><span class="hljs-keyword">SELECT</span> A.col1, B.col2<br><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.a_id;<br></code></pre></td></tr></table></figure><p>以学生表和班级表举例：将班级表作为左表，学生表作为右表，统计每个班中的学生情况。sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> classes.name, students.name<br><span class="hljs-keyword">FROM</span> classes<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> students <span class="hljs-keyword">ON</span> classes.id <span class="hljs-operator">=</span> students.class_id;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">+--------+------+<br>| name   | name |<br>+--------+------+<br>| class1 | mi   |<br>| class1 | jun  |<br>| class1 | hong |<br>| class1 | ming |<br>| class2 | ling |<br>| class2 | bing |<br>| class2 | bai  |<br>| class3 | li   |<br>| class3 | wang |<br>| class3 | xin  |<br>| class4 | NULL |<br>+--------+------+<br></code></pre></td></tr></table></figure><p><code>class4</code>没有学生，但是它已经出现在了表格中。这样能够找到没有关联的孤儿数据。</p><hr /><p>右连接的语法如下，和左连接基本相同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 和左连接相反，返回 B 表所有记录，A 表不匹配的显示 NULL。</span><br><span class="hljs-keyword">SELECT</span> A.col1, B.col2<br><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.a_id;<br></code></pre></td></tr></table></figure><h2 id="cross-join-交叉连接">CROSS JOIN 交叉连接</h2><p>每一条 A 表记录都会和 B 表的每一条组合，结果是 A 表记录数 × B表记录数（笛卡尔积），用得不多。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.col1, B.col2<br><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> B;<br></code></pre></td></tr></table></figure><p><strong>MySQL 没有内建的 FULLJOIN（全连接）语法关键词</strong>。想实现全连接，要用<code>LEFT JOIN + RIGHT JOIN + UNION</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 模拟 FULL OUTER JOIN</span><br><span class="hljs-keyword">SELECT</span> A.id, B.id<br><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.id<br><br><span class="hljs-keyword">UNION</span><br><br><span class="hljs-keyword">SELECT</span> A.id, B.id<br><span class="hljs-keyword">FROM</span> A<br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> B <span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.id;<br><br></code></pre></td></tr></table></figure><h1 id="组合查询">组合查询</h1><p>目的：通过操作符将多个 SELECT 查询的结果合并在一起。</p><h2 id="union">UNION</h2><p>UNION的作用相当于包含<code>WHERE...OR...</code>的语句，不过在复杂的情况下写起来更加简洁。使用UNION 查询<code>class_id</code>为 1 或 2的学生，可以使用以下sql语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <br><span class="hljs-keyword">where</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students<br><span class="hljs-keyword">where</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>这里包含了两个select语句，第一个查询所有<code>class_id</code>为1的学生，第二个查询所有为2的学生。<code>union</code>关键词将两次查询的结果直接合并（如果有重复的数据会自动去除）。上述语句相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <br><span class="hljs-keyword">where</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>UNION几乎总是完成与多个WHERE条件相同的工作。它的一种变体是<code>union all</code>，与union 的唯一区别是<code>union all</code>不会自动去重。</p><p>如果确实需要每个条件的匹配行全部出现（包括重复行），则必须使用UNIONALL而不是WHERE。</p><hr /><p><strong>总结</strong>：利用UNION，可把多条查询的结果作为一条组合查询返回，不管它们的结果中包含还是不包含重复。使用UNION可极大地简化复杂的WHERE子句，简化从多个表中检索数据的工作。</p><h1 id="通配符">通配符</h1><p>查询操作中的所有操作符都是针对已知值进行过滤的，有时候并不好用，例如，怎样搜索产品名中包含文本anvil的所有产品？用简单的比较操作符肯定不行，必须使用通配符。</p><div class="note note-info">            <p><strong>通配符</strong>（wildcard）用来匹配值的一部分的特殊字符。</p><p><strong>搜索模式</strong>（search pattern）由字面值、通配符或两者组合构成的搜索条件。</p>          </div><h2 id="like操作符">LIKE操作符</h2><p>LIKE 用于告诉 MySQL 接下来将会使用通配符进行匹配。LIKE一定要搭配通配符使用， 否则 MySQL会认为使用的是完全匹配而非模糊匹配。</p><h3 id="百分号通配符">百分号(%)通配符</h3><p>百分号（%）通配符 ：<strong>用于匹配多个字符</strong>，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;jet%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这样就找出了找出所有以词<code>jet</code>起头的产品:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">+---------+--------------+<br>| prod_id | prod_name    |<br>+---------+--------------+<br>| JP1000  | JetPack 1000 |<br>| JP2000  | JetPack 2000 |<br>+---------+--------------+<br>2 rows in set (0.017 sec)<br></code></pre></td></tr></table></figure><p><code>'jet%'</code>可以这样理解：<code>%</code>代表的其实是一个字符串剩余的其他字符，整个字符串必须以<code>jet</code>开头。类似地，<code>%jet%</code>代表的是包含<code>jet</code>的字符串，因为<code>jet</code>的前后都有字符。注意<code>%</code>匹配的也可以是空字符和空格，但是不能匹配<code>NULL</code>。</p><h3 id="下划线_通配符">下划线(_)通配符</h3><p>下划线的用途与%一样，但下划线只匹配<strong>单个字符</strong>而不是多个字符。</p><hr /><p>通配符虽然使用方便，但是通配符搜索的速度比一般的操作符要慢，所以不可以滥用通配符。在能达到相同目的睇情况下，应该优先使用其他操作符。</p><h1 id="正则表达式">正则表达式</h1><p>正则表达式是用来匹配文本的特殊的串（字符集合），功能非常强大。。MySQL用WHERE子句对正则表达式提供了初步的支持，只是正则表达式的一个很小的子集。</p><p><strong>关键字</strong>：<code>REGEXP</code></p><h2 id="字符匹配">字符匹配</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name REGEXP <span class="hljs-string">&#x27;.000&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br></code></pre></td></tr></table></figure><p>这里使用了正则表达式<code>.000</code>，小数点表示<em>匹配任意一个字符</em>，因此1000 和 2000 都会被匹配。</p><p>正则表达式匹配默认是不区分大小写【1的，如果需要区分，在正则表达式之前加上<code>BINARY</code>，例如<code>REGEXP BINARY 'JetPack .000'</code>。</p><h2 id="or-匹配">OR 匹配</h2><p>搜索两个字符串之一，使用<code>|</code>。例如：<code>REGEXP '1000|2000'</code>匹配所有包含1000 或 2000 的字符串。可以连续使用多个<code>|</code>。</p><h2 id="匹配多个字符之一">匹配多个字符之一</h2><p><code>[]</code>可以匹配中括号中出现的字符之一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name REGEXP <span class="hljs-string">&#x27;[123] Ton&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">+-------------+<br>| prod_name   |<br>+-------------+<br>| 1 ton anvil |<br>| 2 ton anvil |<br>+-------------+<br></code></pre></td></tr></table></figure><p>成功匹配 1 或 2 或 3。这是另一种形式的 OR语句。<code>[^123]</code>可以匹配除了这三个字符以外的任何东西。</p><h2 id="匹配范围">匹配范围</h2><p>属于上一个例子的加强版：<code>[0-9]</code>匹配数字 0 到9，不必把数字一个一个列举出来了。</p><p><code>[a-z]</code>匹配任意英文字母。</p><h2 id="特殊字符">特殊字符</h2><p>匹配任意字符可以用小数点<code>.</code>，那匹配小数点呢？</p><p>对于这种特殊字符，需要在前面加上<code>\\</code>转义(escaping)来匹配它本身，和Java中的处理方法相同。</p><h2 id="字符类">字符类</h2><p>有预先定义待的字符集可供使用：</p><p><img src="https://s21.ax1x.com/2025/05/11/pEXCWg1.png" /></p><h2 id="匹配多个实例">匹配多个实例</h2><p>对匹配的次数加以指定。例如：</p><ul><li><code>'[[:digit:]]&#123;4&#125;'</code> 匹配连在一起的任意4位数字。</li></ul><p><img src="https://s21.ax1x.com/2025/05/11/pEXCIHO.png" /></p><h2 id="定位符">定位符</h2><p>用于匹配特定位置的文本。</p><ul><li>^ 文本的开始</li><li>$ 文本的结尾</li><li>[[:&lt;:]] 词的开始</li><li>[[:&gt;:]] 词的结尾</li></ul><h1 id="修改数据">修改数据</h1><p>CRUD：Create、Retrieve、Update、Delete</p><p>增、删、改、查</p><p>前面的<code>SELECT</code>用于查，增删改对应的操作是：</p><ul><li>INSERT</li><li>UPDATE</li><li>DELETE</li></ul><h2 id="insert">INSERT</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, ...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><p>有默认值的字段在插入的时候可以不屑，自动附上默认值，但是没有默认值的话必须显式赋值。</p><p>可以同时使用多条INSERT语句，这时不同的语句之间用分号隔开。如果每条INSERT语句中的<code>表名(字段1, 字段2...)</code>相同，只需要在后面补充<code>VALUES</code>，并且用逗号隔开，这样可以提高数据库处理的性能，因为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快。</p><h2 id="update">UPDATE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段<span class="hljs-number">1</span><span class="hljs-operator">=</span>值<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2</span>, ... <span class="hljs-keyword">WHERE</span> ...;<br></code></pre></td></tr></table></figure><p><code>WHERE</code>可以涵盖多个对象，同时修改多个对象的值。</p><p>如果不写<code>WHERE</code>条件，整张表的记录都会被修改。</p><h2 id="delete">DELETE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> ...;<br></code></pre></td></tr></table></figure><p>如果不写<code>WHERE</code>条件，整张表的记录都会被删除。</p><h1 id="mysql-引擎">MySQL 引擎</h1><ul><li>InnoDB是一个可靠的事务处理引擎（参见第26章），它不支持全文本搜索，默认使用此引擎；</li><li>MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；</li><li>MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章），但不支持事务处理。</li></ul><h1 id="视图">视图</h1><h2 id="用法">用法</h2><p>在 SQL中，视图（View）是一种<strong>虚拟表</strong>，它并不存储实际数据，而是基于一条SELECT查询语句动态生成的“结果集”。视图就是<strong>可重用</strong>的查询语句结果，它看起来像表，但不真正存储数据。</p><p>例如，现在我们要把每个学生所在班级的名字和学生的姓名放在一起，可以使用以下查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> c.name, s.name<br><span class="hljs-keyword">from</span> classes <span class="hljs-keyword">as</span> c<br><span class="hljs-keyword">join</span> students <span class="hljs-keyword">as</span> s <span class="hljs-keyword">on</span> c.id <span class="hljs-operator">=</span> s.class_id;<br></code></pre></td></tr></table></figure><p>查询结果：</p><table><thead><tr><th>班级</th><th>学生名</th></tr></thead><tbody><tr><td>class1</td><td>小明</td></tr><tr><td>class1</td><td>hong</td></tr><tr><td>class1</td><td>jun</td></tr><tr><td>class1</td><td>mi</td></tr><tr><td>class2</td><td>bai</td></tr><tr><td>class2</td><td>bing</td></tr><tr><td>class2</td><td>ling</td></tr><tr><td>class3</td><td>xin</td></tr><tr><td>class3</td><td>wang</td></tr><tr><td>class3</td><td>li</td></tr><tr><td>class4</td><td>Spike</td></tr><tr><td>class4</td><td>Elma</td></tr><tr><td>class4</td><td>Amy</td></tr></tbody></table><p>现在，假如经常需要这个格式的结果。不必在每次需要时执行连接，只需创建一个视图，每次需要时使用它即可。为把此语句转换为视图，很简单，</p><ul><li>在查询语句开头加上<code>create view 视图名 as</code></li><li>这里有两个 name 字段，分别来自 classes 和 students 表，但列名都叫name。 所以视图就会有两个叫 name 的列，这在 SQL中是不允许的，解决方法是为两个字段分别起一个别名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> class_student <span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> c.name <span class="hljs-keyword">as</span> class_name, s.name <span class="hljs-keyword">as</span> student_name<br><span class="hljs-keyword">from</span> classes <span class="hljs-keyword">as</span> c<br><span class="hljs-keyword">join</span> students <span class="hljs-keyword">as</span> s <span class="hljs-keyword">on</span> c.id <span class="hljs-operator">=</span> s.class_id;<br></code></pre></td></tr></table></figure><p>以后要想查询班级名和学生名构成的表格，只需要调用以下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> class_student;<br></code></pre></td></tr></table></figure><p>这样就完成了对固定连接查询结果的封装和重用。可以看出，视图极大地简化了复杂SQL语句的使用。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。</p><p>除了重用以外，视图还有以下作用：</p><ol type="1"><li>使用表的组成部分而不是整个表;</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限;</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ol><p>最后一点可以举个例子来说明：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(name, <span class="hljs-string">&#x27;(&#x27;</span>, gender, <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">as</span> student<br><span class="hljs-keyword">from</span> students <br><span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;M&#x27;</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><p>上述语句将所有的男性信息按照<code>名字(性别)</code>的格式重建，如下：</p><table><thead><tr><th>student</th></tr></thead><tbody><tr><td>bing (M)</td></tr><tr><td>jun (M)</td></tr><tr><td>ling (M)</td></tr><tr><td>wang (M)</td></tr><tr><td>xQc (M)</td></tr></tbody></table><p>如果需要的话也可以把这个表格封装成一个视图。</p><h2 id="视图的规则和限制">视图的规则和限制</h2><ol type="1"><li>视图必须唯一命名;</li><li>为了创建视图，必须具有足够的访问权限;</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图;</li><li>ORDER BY 可以用在视图中，但如果从该视图检索数据 SELECT 中也含有ORDER BY ，那么该视图中的 ORDER BY 将被覆盖。</li><li>视图不能索引，也不能有关联的触发器或默认值。</li></ol><h2 id="管理视图">管理视图</h2><ul><li>查看创建视图的语句：<code>show create view 视图名</code></li><li>删除视图：<code>drop view 视图名</code></li><li>更新视图时，可以先删除<code>deop</code>再创建<code>create</code>,也可以直接使用<code>create or replace view</code></li></ul><h1 id="存储过程">存储过程</h1><p>在 MySQL 中，存储过程（Stored Procedure）是一种预编译的 SQL语句集合，可以像调用函数一样执行它。它通常用于封装重复执行的操作，比如一组查询、更新或逻辑判断等。</p><p>使用存储过程有3个主要的好处，即简单、安全、高性能。</p><h2 id="创建">创建</h2><p>如果使用的是MySQL命令行，先创建一个存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $$<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> GetNameById(<br>  <span class="hljs-keyword">IN</span> custId <span class="hljs-type">INT</span><br>)<br><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> custId;<br><span class="hljs-keyword">END</span> $$<br><br></code></pre></td></tr></table></figure><ul><li><code>DELIMITER</code>的存在意义是改变 SQL语句的“语句结束符”。考虑不使用<code>DELIMITER</code>的情况：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> demo()<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;world&#x27;</span>;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>每一个语句的结束处都必须有一个分号，其结果就是刚执行完<code>SELECT 'hello';</code>MySQL就认为语句已经结束了，从而报错。解决方法就是使用<code>DELIMITER</code>手动修改结束符，<code>DELIMITER $$</code>将结束符临时修改成<code>$$</code>，最后<code>END $$</code>把结束符改回默认的分号。</p><p>创建完毕之后，执行语句<code>call GetNameById(12);</code>，可以正确得到id为12 的学生的信息。</p><h2 id="参数问题">参数问题</h2><p>SQL 语句支持三种参数类型：</p><table><thead><tr><th>参数类型</th><th>说明</th></tr></thead><tbody><tr><td><code>IN</code></td><td>调用时传入的只读参数</td></tr><tr><td><code>OUT</code></td><td>存储过程执行后返回的输出值</td></tr><tr><td><code>INOUT</code></td><td>可读可写，调用时传入，过程内可以更改，并返回结果</td></tr></tbody></table><p>为了方便对存储过程传入参数或接收输出结果，往往需要定义变量。在MySQL中，所有的变量必须以<code>@</code>开头，定义变量使用<code>SET</code>关键字。</p><p>下面举一个使用了参数的存储过程的例子：根据传入的<code>id</code>输出对应学生的名字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> get_student_by_id (<br><span class="hljs-keyword">in</span> student_id <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">out</span> student_name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)<br>)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">into</span> student_name<br><span class="hljs-keyword">from</span> students<br><span class="hljs-keyword">where</span> students.id <span class="hljs-operator">=</span> student_id;<br><span class="hljs-keyword">end</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>调用该存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-variable">@sname</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span>;<br><br><span class="hljs-keyword">call</span> get_student_by_id(<span class="hljs-number">1</span>, <span class="hljs-variable">@sname</span>);<br><br><span class="hljs-keyword">select</span> <span class="hljs-variable">@sname</span>;<br></code></pre></td></tr></table></figure><h2 id="删除">删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名<br></code></pre></td></tr></table></figure><p>如果指定的存储过程不存在，那么该语句会报错。为了防止报错，可以使用<code>DROP PROCEDURE IF EXISTS</code></p><h1 id="触发器">触发器</h1><p>MySQL 5 添加了对触发器的支持。</p><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：</p><ul><li>DELETE</li><li>INSERT</li><li>UPDATE</li></ul><p>其他sql语句都不支持触发器。</p><h2 id="如何使用">如何使用</h2><p>创建触发器需要给出四条信息：</p><ul><li>唯一的触发器名（MySQL规定每个表中唯一，但是推荐在整个数据库范围内使用唯一的触发器名）；</li><li>触发器关联的表；</li><li>触发器应该响应的事件（DELETE、INSERT或UPDATE）；</li><li>触发器何时执行（处理之前或之后）。</li></ul><p>MySQL规定<strong>触发器中不能有任何返回结果集的行为</strong>，包括：</p><ul><li>SELECT</li><li>CALL 含有 SELECT 的存储过程</li><li>返回游标</li></ul><p>关键字：<code>CREATE TRIGGER</code>。下面的sql脚本创建了一个触发器，每当<code>students</code>表发生插入操作时就会执行，执行的结果是向用于记录日志的表<code>student_insert_log</code>插入一条日志。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> insert_test<br>AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> students<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student_insert_log (student_id)<br>    <span class="hljs-keyword">VALUES</span> (NEW.id);<br><span class="hljs-keyword">END</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>触发器中还有<code>NEW</code>和<code>OLD</code>这两个特殊的关键字：</p><ul><li>在 INSERT触发器中可以通过<code>NEW</code>访问被插入的行，例如<code>NEW.id</code>获取被插入记录的id值。</li><li>在 DELETE 触发器代码内，可以引用<code>OLD</code>访问被删除的行</li><li>在 UPDATE触发器代码内，可以引用<code>OLD</code>引用原来的行，用<code>NEW</code>引用新的行</li></ul><p>BEFORE 和 AFTER 的使用场景：BEFORE用于对插入数据的数据验证，确保插入/更新/删除操作处理的是正确的数据。AFTER用于在操作完成后执行日志记录等。</p><h2 id="总结">总结</h2><ul><li>应该用触发器来保证<strong>数据的一致性</strong>（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。</li><li>触发器的一种非常有意义的使用是创建<strong>审计跟踪</strong>。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。</li><li>MySQL 触发器中<strong>不支持</strong> CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。</li></ul><h1 id="事务处理">事务处理</h1><h2 id="概述">概述</h2><p>事务处理(TransactionProcessing)一共有两个操作：提交(<strong>COMMIT</strong>)和回滚(<strong>ROLLBACK</strong>)。它可以用来维护数据库的完整性，保证成批的MySQL操作要么完全执行，要么完全不执行。</p><p>举个例子：现在我们用一个<code>orders</code>表用来记录客户订单的编号和下单日期，另一个表<code>orders_item</code>用来记录每个订单包含的物品、数量、价格的具体细节，这两个表通过主键<code>order_num</code>关联。显然，当我们收到新订单的时候，需要同时往两个表添加记录。但是如果两次插入操作中有某一个发生了错误，就会导致“空订单”的产生，这是不被允许的。</p><p>解决方法是将一个事务的所有操作统一管理起来。上述收到新订单后添加记录的就是一个事务，它包含两个操作：向<code>orders</code>插入订单编号和日期，向<code>orders_item</code>插入其它细节。</p><p>如果没有错误发生，将整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</p><h2 id="常用术语">常用术语</h2><ul><li>事务（transaction）指一组SQL语句；</li><li>回滚（rollback）指撤销指定SQL语句的过程；</li><li>提交（commit）指将未存储的SQL语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（place-holder），你可以对它发布回滚（与回退整个事务处理不同）。</li></ul><h2 id="控制事务处理">控制事务处理</h2><p>MySQL 使用以下语句表明事务的开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION<br></code></pre></td></tr></table></figure><p>开启事务后，可以在事务处理内部使用ROLLBACK。ROLLBACK 命令用来撤销INSERT, UPDATE, DELETE 语句。CREATE 和 DROP不能被回退。</p><p>在事务处理中，提交不会隐含地进行，必须显式调用COMMIT。看下面的例子：从账户 A 扣 100 元，给账户 B 加 100 元 ——中间任何一步失败都要回滚。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- A账户扣款</span><br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">-- B账户加款</span><br><br><span class="hljs-comment">-- 检查是否都成功执行</span><br><span class="hljs-comment">-- 可加上判断逻辑，比如检查余额 &gt;= 0，再决定是否提交</span><br><br><span class="hljs-keyword">COMMIT</span>;  <span class="hljs-comment">-- 提交事务</span><br><br><span class="hljs-comment">-- 若发生异常，如余额不足</span><br><span class="hljs-comment">-- ROLLBACK;  -- 回滚事务</span><br></code></pre></td></tr></table></figure><p>实际上，如果第一条UPDATE语句成功执行，但是第二条出错，那么整个事务也会被自动撤销。这就保证了最后提交的结果一定是没有错误的。</p><p>当COMMIT或ROLLBACK语句执行后，事务会<strong>自动关闭</strong>（将来的更改会隐含提交）。</p><h2 id="保留点">保留点</h2><p>上面的回滚和提交的操作都针对整个事务。对于更复杂的事务而言，可能需要部分提交或者回滚。</p><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。</p><p>用法：<code>SAVEPOINT 保留点的名称</code></p><p>保留点的名字不可以重复，在回滚时，MySQL根据名字精确判断该回滚到哪个位置。为了回滚到已知的保留点，使用以下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> 保留点的名字<br></code></pre></td></tr></table></figure><p>保留点设置得越多越好，这样可以充分按照自己的意愿进行回退。在事务处理完成以后，所有的保留点会被自动释放。</p><h2 id="更改默认提交行为">更改默认提交行为</h2><p><code>autocommit</code>标志决定是否自动提交更改，0 代表手动提交，1代表自动提交。使用<code>SET</code>修改即可。该标志的作用范围是一个连接内。</p><h1 id="参考链接">参考链接</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.oracle.com/cn/database/what-is-a-relational-database/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/68136613<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XML基础</title>
    <link href="/2025/04/29/XML%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/29/XML%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="xml">XML</h1><p>XML 还没有被淘汰，应用的地方还有不少，比如说 Maven 的 pom.xml文件里就还在用。但是作为一种数据传输格式，它正在被 JSON替代。所以以下简单列举一些XML的基础知识，更深层次的目前没必要去学。</p><h2 id="什么是xml">什么是XML</h2><p>XML(eXtensible MarkupLanguage，可扩展标记语言)，其设计目的就是存储和传输数据。XML也是一种标记语言，类似于HTML，但是HTML只负责显示数据，而且XML的标签不像HTML一样预先被定义。在许多HTML 应用程序中，XML 用于存储或传输数据，而 HTML用于格式化和显示这些数据。</p><p><strong>可扩展性</strong>就体现在，允许用户自定义任何需要的标签，而且即使添加了（或删除了）新数据，大多数XML 应用程序也会按预期工作，输出不受影响。<strong>XML的优势之一，就是可以经常在不中断应用程序的情况进行扩展</strong>。</p><p>和JSON一样，XML以纯文本格式存储数据，这样就避免了在不同的计算机系统上交换数据时的不兼容问题。</p><p>这是博客的站点地图文件<code>sitemap.xml</code>的一部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">urlset</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">loc</span>&gt;</span>https://kznep19.blog/2025/04/27/Maven%E7%9A%84%E4%BD%BF%E7%94%A8/<span class="hljs-tag">&lt;/<span class="hljs-name">loc</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">lastmod</span>&gt;</span>2025-04-28<span class="hljs-tag">&lt;/<span class="hljs-name">lastmod</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">changefreq</span>&gt;</span>monthly<span class="hljs-tag">&lt;/<span class="hljs-name">changefreq</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">priority</span>&gt;</span>0.6<span class="hljs-tag">&lt;/<span class="hljs-name">priority</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">urlset</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>第一行是XML声明</li><li><code>urlset</code>是指定该文档遵循 sitemaps.org 的 Sitemap 0.9标准。，表示这是一个网址列表。<code>xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"</code>指定该文档遵循sitemaps.org 的 Sitemap 0.9 标准。</li><li><code>&lt;loc&gt;</code>:页面URL</li><li><code>&lt;lastmod&gt;</code>:页面的最后修改时间</li><li><code>&lt;changefreq&gt;</code>:建议搜索引擎多久抓取一次</li><li><code>&lt;priority&gt;</code>:页面在站点中的相对重要性(0.0–1.0)</li></ul><h2 id="xml树结构">XML树结构</h2><p>XML 中的元素形成了一种树状结构：</p><p><img src="https://www.w3school.com.cn/i/xml/nodetree.png" /></p><p>从最上面的根元素开始，扩展到枝叶。</p><h2 id="语法">语法</h2><ol type="1"><li>XML 文档必须包含一个根元素，作为其他所有元素的父元素</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">subchild</span>&gt;</span>.....<span class="hljs-tag">&lt;/<span class="hljs-name">subchild</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>XML 标签区分大小写</li><li>一些符号不能直接写在元素中，使用<strong>实体引用</strong></li></ol><table><thead><tr><th>字符</th><th>替代写法</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td><code>&amp;lt;</code>（less than）</td></tr><tr><td><code>&gt;</code></td><td><code>&amp;gt;</code>（greater than）</td></tr><tr><td><code>&amp;</code></td><td><code>&amp;amp;</code>（ampersand）</td></tr><tr><td><code>"</code></td><td><code>&amp;quot;</code>（双引号）</td></tr><tr><td><code>'</code></td><td><code>&amp;apos;</code>（单引号）</td></tr></tbody></table><ol start="4" type="1"><li>多个连续的空格不会被裁剪</li></ol><h2 id="元素">元素</h2><p>类似<code>&lt;lastmod&gt;2025-04-28&lt;/lastmod&gt;</code>被称为一个<strong>元素</strong>。元素的内容可以是文本内容，也可以是其他的子元素。</p><p><strong>空元素</strong>：形如<code>&lt;element&gt;&lt;/element&gt;</code>，可以使用自关闭标签记为<code>&lt;element /&gt;</code>。</p><p>元素的命名约定：</p><table><thead><tr><th>样式</th><th>例子</th><th>描述</th></tr></thead><tbody><tr><td>小写</td><td><code>&lt;firstname&gt;</code></td><td>所有字母小写</td></tr><tr><td>大写</td><td><code>&lt;FIRSTNAME&gt;</code></td><td>所有字母大写</td></tr><tr><td>蛇形</td><td><code>&lt;first_name&gt;</code></td><td>下划线分隔单词（常用于 SQL 数据库）</td></tr><tr><td>帕斯卡</td><td><code>&lt;FirstName&gt;</code></td><td>每个单词的第一个字母大写（C 程序员常用）</td></tr><tr><td>驼峰</td><td><code>&lt;firstName&gt;</code></td><td>除第一个之外的每个单词首字母大写（常用于 JavaScript）</td></tr></tbody></table><h2 id="属性">属性</h2><p><strong>Attribute</strong></p><p>XML属性必须加引号：<code>&lt;person gender="female"&gt;</code>，单双都可。属性的扩展性很差。</p><p>数据本身应当存储为元素，元数据（用于描述数据的信息）应当存储为属性。</p><h2 id="命名空间">命名空间</h2><p><strong>Namespace</strong></p><p>当两个不同的文档使用相同的元素名称时，就会发生<strong>命名冲突</strong>。例如，table既可以作为桌子的名称，也可以作为表格的名称。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>木头餐桌<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>员工工资表<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就很难区分了。解决方法：<strong>名称前缀</strong></p><p>在xml中使用前缀，必须定义命名空间。命名空间可以通过元素开始标记中的<code>xmlns</code>属性来定义，也就是XML Namespace。</p><p><strong>语法</strong>：<code>xmlns:前缀="命名空间的唯一标识符（一般是 URL）"</code></p><p>其中“命名空间的唯一标识符”即为 URI ，最常见的URI是URL(UniformResource Locator)，也就是网址。加上名称前缀之后上面的例子变成:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a:table</span> <span class="hljs-attr">xmlns:a</span>=<span class="hljs-string">&quot;http://example.com/furniture&quot;</span>&gt;</span>木头餐桌<span class="hljs-tag">&lt;/<span class="hljs-name">a:table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">b:table</span> <span class="hljs-attr">xmlns:b</span>=<span class="hljs-string">&quot;http://example.com/database&quot;</span>&gt;</span>员工工资表<span class="hljs-tag">&lt;/<span class="hljs-name">b:table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就能区分开来了。</p><p>然后回到开头的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">urlset</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这似乎不符合命名空间的语法，其实这里用的是<strong>默认命名空间</strong>，意思是：文档中<strong>所有没有前缀的元素</strong>（如<code>&lt;url&gt;</code>、<code>&lt;loc&gt;</code>）<strong>都属于这个命名空间</strong>。</p><h2 id="xmlhttprequest">XMLHttpRequest</h2><div class="note note-secondary">            <p><code>XMLHttpRequest</code>是浏览器中的一个 JavaScript对象，用于在网页与服务器之间交换数据，而无需刷新整个页面。</p>          </div><p><code>XMLHttpRequest</code>是 2000 年代早期的API，不过现在有使用起来更简洁方便的<code>fetch</code>。使用xhr发送GET请求的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建请求对象</span><br><span class="hljs-keyword">var</span> xhttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">//事件处理函数，每当xhr的对象的状态发生变化时调用</span><br>xhttp.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//请求已完成，且返回的状态码为200</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;<br>       <span class="hljs-comment">// 更新网页</span><br>       <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">innerHTML</span> = xhttp.<span class="hljs-property">responseText</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//设置请求方式和请求地址以及是否异步</span><br>xhttp.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">//发送请求</span><br>xhttp.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><p><strong>执行顺序</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">请求已发送<br>（稍后）onreadystatechange 被触发，当状态变为 <span class="hljs-number">4</span> 且 <span class="hljs-built_in">status</span> 为 <span class="hljs-number">200</span> 时执行回调<br></code></pre></td></tr></table></figure><p>由于是异步方式，<code>xhttp.send();</code>一开始就会被执行，浏览器异步地等待响应，期间可以去做别的事情，当xhr状态发生变化的时候才会更新网页。</p><h2 id="xml-解析">XML 解析</h2><h3 id="dom">DOM</h3><p>将 XML 文档转换为XML DOM 对象 - 可通过 JavaScript 操作的对象。</p><p>JS使用<code>DOMParser</code>解析xml字符串实例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> xmlString = <span class="hljs-string">&quot;&lt;note&gt;&lt;to&gt;Alice&lt;/to&gt;&lt;from&gt;Bob&lt;/from&gt;&lt;/note&gt;&quot;</span>;<br><span class="hljs-keyword">const</span> parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOMParser</span>();<br><span class="hljs-keyword">const</span> xmlDoc = parser.<span class="hljs-title function_">parseFromString</span>(xmlString, <span class="hljs-string">&quot;application/xml&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xmlDoc.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;to&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">textContent</span>); <span class="hljs-comment">// 输出 &quot;Alice&quot;</span><br></code></pre></td></tr></table></figure><p>以上代码必须放到浏览器中才能运行。</p><p>上面使用解析器将XML文件转换为XML DOM对象，对于XMLDOM对象也有可用的访问方法。例如<code>getElementsByTagName</code>，<code>getElementById</code>等。因为XMLDOM呈现树状结构，我们从根元素出发一定可以遍历所有子节点，获取这个XML文件的所有信息。</p><h3 id="sax">SAX</h3><p>DOM方式固然省事，但是内存开销太大，因为整个XML文件必须加载到内存中之后才能使用。SAX是另一种解析XML的方式，即<code>Simple API for XML</code>，它是一种基于<strong>事件流</strong>的间隙方式，解析时逐个读取XML文件的元素并触发相应事件。但是使用起来依然很麻烦。</p><h3 id="jackson">Jackson</h3><p>Jackson是一个第三方库，它主要用于Java对象和JSON之间的转化，也可以实现XML到JavaBean的转换。<ahref="https://github.com/FasterXML/jackson">仓库地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven的基本操作</title>
    <link href="/2025/04/27/Maven%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2025/04/27/Maven%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>Maven解决了软件构建的两方面问题：一是软件是如何构建的，二是软件的依赖关系。</p><p>不同于ApacheAnt等早期工具，Maven设定了构建流程的标准，在此之外只需要指定例外情况。XML文件描述了正在构建的软件项目、它对其他外部模块和组件的依赖关系、构建顺序、目录和所需的插件。该文件通常有预设的目标任务，例如代码编译和打包。Maven从一个或多个代码仓库（例如Maven2 CentralRepository）动态地下载Java库与Maven插件，并将其存储在本地缓存区中。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zh.wikipedia.org/wiki/Apache_Maven">[1]</span></a></sup></p><p>GAVP：为每个项目在maven仓库中做一个标识，类似于人的名字。</p><ul><li>Groupid是公司项目:公司项目-业务线</li><li>ArtifactID:产品线名-模块名</li><li>Version:主版本号.次版本号.修订号</li><li>Packaging:打包方式，Java工程打jar包，Web工程打war包，pom代表不会打包，用来做继承的父工程</li></ul><p>创建 Maven项目时，jdk版本最好选择jdk17、jdk21这些长期稳定版本，不要使用最新版，因为很多插件都不支持。</p><p>Maven中的测试类，类名必须以test结尾，测试方法以test开头，否则无法被识别。</p><h1 id="不同阶段">不同阶段</h1><table><thead><tr><th>阶段（Lifecycle）</th><th>作用</th><th>常用命令</th></tr></thead><tbody><tr><td>clean</td><td>清理之前的构建产物，比如 <code>target/</code> 目录</td><td>mvn clean</td></tr><tr><td>validate</td><td>验证项目是否正确，准备编译</td><td>mvn validate</td></tr><tr><td>compile</td><td>编译主代码（src/main/java）</td><td>mvn compile</td></tr><tr><td>test</td><td>编译并运行单元测试（src/test/java）</td><td>mvn test</td></tr><tr><td>package</td><td>打包成 jar/war 文件，输出到 target/</td><td>mvn package</td></tr><tr><td>verify</td><td>验证打包结果，比如执行集成测试</td><td>mvn verify</td></tr><tr><td>install</td><td>安装到本地仓库</td><td>mvn install</td></tr><tr><td>site</td><td>生成项目文档网站（项目依赖、测试报告等）</td><td>mvn site</td></tr><tr><td>deploy</td><td>部署到远程仓库供别人使用</td><td>mvn deploy</td></tr></tbody></table><p>手动引入依赖的格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="依赖范围">依赖范围</h1><p>在pom文件中使用<code>&lt;scope&gt;</code>标签，英语控制该依赖起作用的阶段。一共有三个阶段：编译、测试、运行。</p><ul><li>compile<ul><li>编译、测试、运行阶段都可用</li><li>适用于项目本身需要直接使用的库，比如<code>Spring Boot</code>、<code>Lombok</code></li></ul></li><li>provided<ul><li>编译、测试可用，但是运行不可用，也就是不会被打包</li><li>运行时由服务器等外部环境提供，如<code>Servlet API</code>可以由<code>Tomcat</code>提供，因此属于provided 范围</li></ul></li><li>runtime<ul><li>仅在运行和测试可用，编译不可用</li><li>适用于运行时所需要的库，比如数据库驱动、JDBC 适配器等。</li><li>代码中通常只使用接口（如<code>java.sql.Connection</code>），编译时无需具体的JDBC 实现。</li></ul></li><li>test<ul><li>仅在测试可用，例如 JUnit 等测试框架</li></ul></li><li>system<ul><li>类似<code>provided</code>，但是需要本地手动提供jar包，不会从Maven仓库下载，相比之下不如使用私有Maven 仓库进行管理。不推荐使用</li></ul></li><li>import<ul><li>仅用于<code>dependencyManagement</code>依赖管理，引入一个具体的POM作为依赖版本管理。例如：引入Spring Boot BOM</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="依赖下载失败">依赖下载失败</h1><p>如果引入依赖后没有联网，依赖将下载失败，即使再次联网也不会开始下载，因为本地仓库中已经存在了<code>.lastUpdated</code>后缀的文件。Maven只要检测到这个文件就不会开始下载，需要手动删除。</p><h1 id="build标签">build标签</h1><h2 id="指定打包文件">指定打包文件</h2><p><code>pom.xml</code>文件中的<code>&lt;build&gt;</code>主要用于对构建相关的信息进行配置。</p><div class="note note-primary">            <p>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤</p>          </div><p>如果需要在src/main/java中放入非java文件，并且要求能够被打包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--设置资源所在目录--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--设置包含的资源类型--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以将java目录下的任意<code>.xml</code>文件打包。</p><h2 id="引入插件">引入插件</h2><p>使用标签<code>&lt;plugin&gt;</code></p><h1 id="依赖传递和依赖冲突">依赖传递和依赖冲突</h1><h2 id="传递">传递</h2><p>如果A依赖B，B又依赖C，那么A也间接依赖C，那么在执行项目A时，会自动把其他两个项目下载导入到jar包文件夹中。这就是<strong>依赖的传递性</strong>。</p><p>另一方面，依赖能否成功传递还取决于依赖范围：</p><ul><li><code>&lt;optional&gt;true&lt;/optional&gt;</code>手动终止依赖传递</li><li>非compile范围无法进行依赖传递</li><li>依赖冲突（传递的依赖已经存在）</li></ul><h2 id="冲突">冲突</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">项目A -&gt; 依赖B（B依赖X:1.0）<br>    └──&gt; 依赖C（D依赖X:2.0）<br></code></pre></td></tr></table></figure><p>这里B和C都依赖了X的不同的版本，出现依赖冲突。Maven的自动选择原则如下：</p><ul><li>短路优先（路径最短优先）哪个近用哪个</li><li>路径长度相同的情况下，声明优先，在<code>&lt;dependencies&gt;</code>中先声明的被使用</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span><br>├── <span class="hljs-variable">B</span><br>│    └── <span class="hljs-built_in">C</span><span class="hljs-operator">:</span><span class="hljs-number">1.0</span><br>└── <span class="hljs-built_in">D</span><br>     └── <span class="hljs-built_in">C</span><span class="hljs-operator">:</span><span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p>如果B在D声明之前，则使用C1.0。</p><p>也可以手动排除依赖冲突：<code>&lt;exclusions&gt;</code></p><h1 id="工程继承">工程继承</h1><p>Maven 工程继承指的是在 Maven项目中让一个项目从另一个项目继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。</p><ul><li>对一个大型的项目进行了模块的拆分</li><li>每个项目下面又很多个模块，每一个模块都需要配置自己的依赖信息。</li></ul><p>父工程主要用来做依赖的管理或配置信息的管理，不需要写源代码，编译时父工程中的类不会被打包。对父工程进行的清理、编译等操作也会同步进行到子工程中，可以一键管理。</p><p>子工程应当在父工程目录下被创建，子工程的配置文件中会出现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>表明了父工程的坐标。子工程的GroupId和父工程自动保持一致。</p><p>父工程的<code>&lt;dependencies&gt;</code>会<strong>无条件</strong>地被子工程继承，所以一般在<code>&lt;properties&gt;</code>的下面加上<code>&lt;dependencyManagement&gt;</code>，然后在这个标签内部声明依赖，这样子工程不会默认继承它。如果需要继承，在子工程的配置文件中只需要复制groupId和artifactId就可以使用了，不用写版本号。</p><h1 id="工程聚合">工程聚合</h1><p>聚合是指<strong>将多个项目组织到一个父级项目中</strong>，以便一起构建和管理的机制。聚合可以帮助我们更好地管理一组相关的子项目，同时简化它们的构建和部署的过程。</p><p>目标：<strong>一键操作、一键构建</strong>。</p><p>语法：在GAVP之后加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>子工程的相对路径<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例如，如果子工程就在父工程的目录下，可以直接写<code>maven_son</code></p><h1 id="maven-私服">Maven 私服</h1><h2 id="简介">简介</h2><p>Maven私服是一种特殊的Maven远程仓库，它是架设在<strong>局域网</strong>内的仓库服务，用来代理位于外部的远程仓库。</p><blockquote><p>当然并不是说私服只能建立在局域网，很多公司会把私服直接部署到公网，方便员工居家办公。</p></blockquote><p>建立了Maven私服后，当局域网内的用户需要某个构建时，会按照如下的顺序进行请求和下载：</p><ol type="1"><li>请求本地仓库，若不存在则下一步</li><li>请求Maven私服，将所需构件下载到本地仓库，若不存在则下一步</li><li>请求外部的远程仓库，将所需构件下载并缓存到私服，若不存在则报错</li></ol><p>Maven用户既可以从私服下载构件，也可以上传构件。</p><p><strong>私服的优势</strong>：降低外网带宽压力；下载速度更快；便于部署第三方构件（有些构件无法从第三方仓库获得）；提高项目的稳定性，增强对项目的控制。</p><h2 id="sonatype-nexus">Sonatype Nexus</h2><p>使用最广泛的 Maven 私服产品是<strong>Nexus</strong>。Nexus RepositoryManager（通常简称 Nexus）是由一家叫 Sonatype的公司开发的，它本质上是一个 Maven 仓库管理器。</p><blockquote><p>Sonatype Nexus Repository是一款软件仓库管理器，既有开源许可版本，也有商业许可版本。它能够将多种编程语言的仓库整合在一起，使得可以通过一个服务器作为构建软件时的统一来源。开源版使用的是H2 数据库。<br />Tamás Cservenák 最初在 2005年 开发了Proximity，原因是他当时使用的是较慢的 ADSL互联网连接。 后来，他被Sonatype 公司聘请，开发了一个类似的产品，即Nexus。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Sonatype_Nexus_Repository">[2]</span></a></sup></p></blockquote><p>安装过程比较烦人，先进入https://www.sonatype.com/nexus-repository-oss填写信息下载，下载好之后解压。</p><p>按照网上的方法进入bin目录输入<code>nexus.exe /run</code>，报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">E:\nexus-<span class="hljs-number">3.79</span>.<span class="hljs-number">1</span>-<span class="hljs-number">04</span>-win-x86_64\nexus-<span class="hljs-number">3.79</span>.<span class="hljs-number">1</span>-<span class="hljs-number">04</span>\bin&gt;nexus<span class="hljs-selector-class">.exe</span> /run<br><span class="hljs-selector-attr">[2025-04-28 15:40:49]</span> <span class="hljs-selector-attr">[error]</span> <span class="hljs-selector-attr">[ 1048]</span> Unrecognized cmd <span class="hljs-selector-tag">option</span> /run<br><span class="hljs-selector-attr">[2025-04-28 15:40:49]</span> <span class="hljs-selector-attr">[error]</span> <span class="hljs-selector-attr">[ 1048]</span> Invalid command <span class="hljs-selector-tag">line</span> arguments.<br><span class="hljs-selector-attr">[2025-04-28 15:40:49]</span> <span class="hljs-selector-attr">[error]</span> <span class="hljs-selector-attr">[ 1048]</span> Apache Commons Daemon procrun failed with exit value: <span class="hljs-number">1</span> (failed to parse command <span class="hljs-selector-tag">line</span> arguments).<br></code></pre></td></tr></table></figure><p>说明网上的方法失效了。再看一眼解压后的目录</p><p><img src="https://s21.ax1x.com/2025/04/28/pE7iUJ0.png" /></p><p>看看第一个文件。</p><p>嗯？有点怪，这不是安装脚本嘛。再翻翻官方文档<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://help.sonatype.com/en/sonatype-nexus-repository.html">[3]</span></a></sup></p><p><img src="https://s21.ax1x.com/2025/04/28/pE7AuJ1.png" /></p><div class="note note-primary">            <p>Nexus Repository 在 3.78.0 版本进行了大量构建方式的更改。 3.78.0及以后版本使用了上面列出的 //ES//、//SS//、//DS// 这种新格式。</p>          </div><p>总之很折腾，不建议使用最新版本，最好使用3.78.0之前的。</p><p>从这个链接下载历史版本：https://help.sonatype.com/en/download-archives---repository-manager-3.html</p><p>下载之前记得看一下自己的电脑上有没有对应的jdk版本。</p><p>成功启动之后通过localhost:8081访问。</p><p>后续利用Nexus搭建私服和Maven联动的内容到了后期才会用到，这里先歇一歇。</p><p>放几个参考链接。以后再来看：</p><p>https://www.easyblog.vip/detail/58</p><p>https://www.bilibili.com/video/BV1854y1F7Lt/?spm_id_from=333.337.search-card.all.click&amp;vd_source=918a6909c997fbaf818d1fbc55d65ca9</p><p>https://wiki.eryajf.net/pages/1815.html#_1-%E5%88%9B%E5%BB%BA-blob-%E5%AD%98%E5%82%A8%E3%80%82</p><p>https://www.hangge.com/blog/cache/detail_2844.html</p><h1 id="参考链接">参考链接</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://zh.wikipedia.org/wiki/Apache_Maven<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://en.wikipedia.org/wiki/Sonatype_Nexus_Repository<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://help.sonatype.com/en/sonatype-nexus-repository.html<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid 背景图随日夜模式切换</title>
    <link href="/2025/04/26/%E7%99%BD%E5%A4%A9%E9%BB%91%E5%A4%9C%E8%83%8C%E6%99%AF%E5%9B%BE%E5%88%87%E6%8D%A2/"/>
    <url>/2025/04/26/%E7%99%BD%E5%A4%A9%E9%BB%91%E5%A4%9C%E8%83%8C%E6%99%AF%E5%9B%BE%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://kznep19.blog/2025/04/20/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%962/#%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98">前情提要</a></p><h1 id="获取当前模式">1. 获取当前模式</h1><p>要解决的第一件事是获取当前页面采用的模式。</p><p>按F12打开控制台，很容易发现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_self&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;Color Toggle&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont icon-dark&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;color-toggle-icon&quot;</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;light&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>class="iconfont icon-dark"</code>指的是当前显示的按钮图标，当鼠标悬停在上方时就会发生改变，所以我们需要的不是这个</li><li><code>id="color-toggle-icon"</code>可以通过唯一id获取这个对象</li><li><code>data="light"</code>记录的是当前所在的模式，正是我们需要的</li></ul><p>因此，要获取当前的模式，只需要在自定义js文件<code>backgroundize.js</code>中写入以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#color-toggle-btn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<br>    <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> dataValue = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;color-toggle-icon&#x27;</span>).<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data&#x27;</span>); <span class="hljs-comment">// 获取data属性</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data属性值是：&#x27;</span>, dataValue);<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p>打开控制台看看效果：</p><p><img src="https://s21.ax1x.com/2025/04/26/pETiPpT.png" /></p><p>发现获取的data值和当前页面的实际模式刚好相反，这个问题不大，比较烦人的是每一次点击按钮控制台都会打印出两个完全相同的值。通过检查按钮的属性，发现这个click事件被<strong>重复绑定</strong>两次。</p><p>解决方法：定义一个全局变量作为标记，初始值为<code>undefined</code>，绑定一次之后赋值为<code>true</code>，因此以后不会重复绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监听主题切换按钮点击事件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentMode</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;color-toggle-icon&#x27;</span>).<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 检查是否已初始化</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">_colorToggleInitialized</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleColorToggle</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getCurrentMode</span>());<br>    &#125;<br><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#color-toggle-btn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handleColorToggle);<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">_colorToggleInitialized</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记为已初始化</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改后的效果：</p><figure><img src="https://s21.ax1x.com/2025/04/26/pETibU1.png"alt="backgroundize.js只被绑定一次" /><figcaption aria-hidden="true">backgroundize.js只被绑定一次</figcaption></figure><p>可以看出非用户自定义的文件也有被重复绑定的情况，原因暂时不太清楚。</p><h1 id="替换背景图">2. 替换背景图</h1><p>文章页的背景图：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;web_bg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-image: url(<span class="hljs-symbol">&amp;quot;</span>/img/girl.webp<span class="hljs-symbol">&amp;quot;</span>);position: fixed;width: 100%;height: 100%;z-index: -1;background-size: cover;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首页的背景图：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;web_bg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-image: url(<span class="hljs-symbol">&amp;quot;</span>/img/miku.webp<span class="hljs-symbol">&amp;quot;</span>);position: fixed;width: 100%;height: 100%;z-index: -1;background-size: cover;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意仅从html上已经无法区分这两张图片，而我的目标是只在文章页的时候启用切换。注意到文章页和首页的<code>&lt;head&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;article&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;og:type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;website&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>所以可以从这里下手进行区分。完整的js代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 检查是否已初始化</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">_colorToggleInitialized</span>) &#123;<br><br>    <span class="hljs-comment">//为点击事件绑定切换背景的功能</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#color-toggle-btn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, setBackgroundImage);<br><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">_colorToggleInitialized</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记为已初始化</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取当前日/夜模式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> light:夜，dark:日（刚好反过来）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentMode</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;color-toggle-icon&#x27;</span>).<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置背景图片</span><br><span class="hljs-comment"> * 通过Open Graph meta判断当前页面是不是文章页</span><br><span class="hljs-comment"> * 如果是，则根据当前的模式替换背景图片</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setBackgroundImage</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-keyword">const</span> ogTypeMeta = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;meta[property=&quot;og:type&quot;]&#x27;</span>);<br>    <span class="hljs-keyword">const</span> isPost = ogTypeMeta &amp;&amp; ogTypeMeta.<span class="hljs-property">content</span> === <span class="hljs-string">&#x27;article&#x27;</span>;<br><br>    <span class="hljs-keyword">if</span> (isPost) &#123;<br>        <span class="hljs-keyword">const</span> bgDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;web_bg&#x27;</span>);<br><br>        <span class="hljs-keyword">if</span> (bgDiv) &#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getCurrentMode</span>() === <span class="hljs-string">&#x27;light&#x27;</span>) bgDiv.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&quot;/img/night.webp&quot;)&#x27;</span>;<br><br>            <span class="hljs-keyword">else</span> bgDiv.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&quot;/img/girl.webp&quot;)&#x27;</span>;<br><br>            <span class="hljs-comment">//console.log(&quot;成功替换&quot;);</span><br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 上面的代码只有当点击日夜切换按钮时才生效。</span><br><span class="hljs-comment"> * 如果在首页就切换为黑夜模式，进入文章页后会发现背景仍然是白色的</span><br><span class="hljs-comment"> * 所以这里利用DOMContentLoaded事件，每当一个页面的HTML结构加载完成时判断是否是文章页，是的话就根据模式替换背景</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 通过 Open Graph 协议判断</span><br>    <span class="hljs-keyword">const</span> ogTypeMeta = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;meta[property=&quot;og:type&quot;]&#x27;</span>);<br>    <span class="hljs-keyword">const</span> isPost = ogTypeMeta &amp;&amp; ogTypeMeta.<span class="hljs-property">content</span> === <span class="hljs-string">&#x27;article&#x27;</span>;<br><br>    <span class="hljs-keyword">if</span> (isPost) &#123; <span class="hljs-comment">// 判断进入文章页</span><br><br>        <span class="hljs-keyword">const</span> bgDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;web_bg&#x27;</span>);<br><br>        <span class="hljs-keyword">if</span> (bgDiv) &#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getCurrentMode</span>() === <span class="hljs-string">&#x27;light&#x27;</span>) bgDiv.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&quot;/img/night.webp&quot;)&#x27;</span>;<br><br>            <span class="hljs-keyword">else</span> bgDiv.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&quot;/img/girl.webp&quot;)&#x27;</span>;<br><br>            <span class="hljs-comment">//console.log(&quot;成功替换&quot;);</span><br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后再加入css代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 明暗切换 */</span><br><span class="hljs-selector-id">#web_bg</span> &#123;<br>    <span class="hljs-attribute">transition</span>: background-image <span class="hljs-number">0.5s</span> ease-in-out <span class="hljs-meta">!important</span>;<br>&#125;<br><br><span class="hljs-comment">/* 由黑夜切换为白天的时间会长一点 */</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme</span>: dark) &#123;<br>    <span class="hljs-selector-id">#web_bg</span> &#123;<br>        <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">0.8s</span> <span class="hljs-meta">!important</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这里采用的逻辑是只有检测到加载的页面是文章页时才执行北京替换的逻辑，所以使用了两处替换背景的功能：初次加载页面时、按下日夜切换按钮时。</p><h1 id="遗留问题">遗留问题</h1><p>上面的实现方式有一个缺陷：刚进入文章页时有概率先显示出<code>config.fluid.yml</code>中配置的原背景图，再渐变转换成预期的背景图，看起来比较突兀。因为我之前配置过预加载功能，所以干脆直接把原背景图换成和加载页面相同底色的图了。</p><p>另外，在文章页内第一次点击日夜切换按钮时，因为背景图只有在需要它的时候才会开始加载，所以第一次背景会闪烁一下然后突然出现背景图，后续再次切换模式的时候才会正常。要解决这个问题就要使用预加载，提前加载背景图片，不过我目前并不清楚预加载的具体实现方式，所以暂时就先这样了。</p>]]></content>
    
    
    <categories>
      
      <category>Theme</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础</title>
    <link href="/2025/04/23/JS%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/23/JS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>JS基础知识，先速通一遍，以后再慢慢补充细节</p><span id="more"></span><h1 id="引入方式">引入方式</h1><h2 id="内部脚本">内部脚本</h2><p>将JS代码定义在HTML中。可以在任意地方放置任意数量的js，但是一般会把脚本位于<code>&lt;body&gt;</code>元素的底部，可以改善显示速度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello JavaScript&quot;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="外部脚本">外部脚本</h2><p>定义在外部js文件中，HTML文档通过以下格式引用，不能自闭合。外部js文件不需要<code>&lt;script&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/demo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="基本语法">基本语法</h1><ul><li>每行结尾的分号可有可无（但是建议加上）</li><li>输出语句<ul><li><code>window.alert()</code>弹出窗口（/əˈlɜːrt/ 意思是警示）</li><li><code>document.write()</code>写入HTML文档（开发很少用）</li><li><code>console.log()</code>输出到控制台</li></ul></li></ul><h1 id="变量">变量</h1><p>在 JavaScript 中定义变量的方法有三种，分别是</p><ol type="1"><li><code>let</code>（推荐）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;初音ミク&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>let</code>定义的是可以<strong>更改值</strong>的变量</li><li>代码块内有效</li></ul><ol start="2" type="1"><li><code>const</code>（推荐）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14159</span>;<br></code></pre></td></tr></table></figure><ul><li><code>const</code>定义的是<strong>常量</strong>，<strong>不能重新赋值</strong></li><li>一旦赋值就不能改变</li><li>代码块内有效</li></ul><ol start="3" type="1"><li><code>var</code>⚠️（不推荐）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">16</span>;<br></code></pre></td></tr></table></figure><ul><li>旧语法（ES5之前），写老代码、或者兼容旧浏览器才用</li><li>允许修改</li><li>变量会提升（hoisting），且是函数作用域，容易出 bug</li><li>出代码块还可以访问，属于全局变量</li><li>可以重复定义，前两个都不行。例如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br><span class="hljs-title function_">alert</span>(x);<br></code></pre></td></tr></table></figure><p>不报错。</p><h1 id="数据类型运算符流程控制语句">数据类型、运算符、流程控制语句</h1><h2 id="数据类型">数据类型</h2><ul><li><strong>原始类型（Primitive Types）</strong></li></ul><p>对应Java中的基本数据类型，但是分得没那么细</p><table><thead><tr><th>数据类型</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><code>number</code></td><td><code>42</code>, <code>3.14</code>, <code>NaN</code>,<code>Infinity</code></td><td>数字类型，包含整数和浮点数</td></tr><tr><td><code>string</code></td><td><code>"Hello"</code>, <code>'世界'</code></td><td>字符串，单双引号都可</td></tr><tr><td><code>boolean</code></td><td><code>true</code>, <code>false</code></td><td>布尔值</td></tr><tr><td><code>undefined</code></td><td><code>let x;</code> → <code>x === undefined</code></td><td>声明未赋值时的默认值</td></tr><tr><td><code>null</code></td><td><code>let x = null</code></td><td>表示“无”或“空值”</td></tr><tr><td><code>bigint</code></td><td><code>12345678901234567890n</code></td><td>大整数类型（ES2020+）</td></tr><tr><td><code>symbol</code></td><td><code>Symbol("id")</code></td><td>独一无二的标识符</td></tr></tbody></table><ul><li><strong>引用类型（Reference Types）</strong></li></ul><p>对应Java中的引用数据类型，但是少得多</p><table><thead><tr><th>数据类型</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>object</code></td><td><code>&#123; name: "Miku", age: 16 &#125;</code></td><td>普通对象，键值对结构</td></tr><tr><td><code>array</code></td><td><code>[1, 2, 3, "初音"]</code></td><td>数组，JS 中是一种对象类型</td></tr><tr><td><code>function</code></td><td><code>function greet() &#123;&#125;</code></td><td>函数也是对象</td></tr><tr><td><code>date</code></td><td><code>new Date()</code></td><td>日期对象</td></tr><tr><td><code>regexp</code></td><td><code>/abc/</code>, <code>new RegExp("abc")</code></td><td>正则表达式对象</td></tr></tbody></table><p>使用<code>typeof</code>运算符可以得到数据类型。</p><h2 id="运算符">运算符</h2><p>算术运算符，逻辑运算符同Java。</p><p>比较运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">==    <span class="hljs-comment">// 相等，会进行类型转换</span><br>===   <span class="hljs-comment">// 全等（值和类型都相等），不进行类型转换✅推荐</span><br>!=    <span class="hljs-comment">// 不等</span><br>!==   <span class="hljs-comment">// 全不等（值和类型都不相等）</span><br>&lt; &gt; &lt;= &gt;=<br></code></pre></td></tr></table></figure><p>赋值运算符： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">= **<br>+=   -=   *=   /=   %=   **=<br></code></pre></td></tr></table></figure></p><ul><li><code>**</code>：<strong>指数运算符ExponentiationOperator）</strong>，例如<code>2**3</code>表示2的三次方。它是<strong>左结合</strong>运算符，比如<code>2 ** 3 ** 2</code>的计算顺序是<code>2 ** (3 ** 2)</code>。</li><li><code>**=</code>是<strong>指数赋值运算符（Exponentiation assignmentoperator）</strong>，ES7加入。举个例子：<code>x **= y</code>，意思就是<code>x = x ** y;</code>，意思就是把x的y次方赋给x本身。例如：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;<br>a **= <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>就是把<code>a</code>的3次方赋值给<code>a</code>，结果为8。</p><h3 id="类型转换">类型转换</h3><h4 id="转换成字符串">转换成字符串</h4><p><code>.toString()</code></p><p>Boolean值、数字(number)和字符串(string)都是<strong>伪对象</strong>，它们实际上具有属性和方法，<code>.toString()</code>就是其中一种可供调用的方法。</p><p>另外number类型的<code>toString()</code>方法比较特殊，如果不传入任何参数，那么采用的是<strong>默认模式</strong>，返回的是数字的十进制表示。如果传入参数，即为<strong>基模式</strong>，可以用不同的基(radix)输出数字。</p><p>例如，以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">9</span>;<br><span class="hljs-title function_">alert</span>(x.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>得到的结果为<code>1001</code>，也就是十进制数字9的二进制表示。</p><h4 id="转换成数字">转换成数字</h4><p>转换为整数：<code>parseInt</code>转换为小数：<code>parseFloat()</code></p><p>从开头开始从左到右读取是数字的部分。如果开头就不是数字，则转换失败，返回<code>NaN</code>(Nota Number)。</p><p>字符串中包含的数字字面量会被正确转换为数字，例如"0xA"会被转换成数字10。但是"22.5"会被转换成22，因为小数点被当成无效字符处理了。<code>parseFloat()</code>会把遇到的第一个小数点当成小数点处理。</p><p><code>parseInt()</code>方法也有基模式，定义为<code>parseInt(string: string, radix?: number): number</code>，但是<code>parseFloat()</code>没有。</p><p>相比之下，Java使用<code>Integer.parseInt()</code><code>Float.parseFloat</code> <code>Double.parseDouble()</code><code>Long.parseLong</code>等方法进行转换，如果转换失败会抛出<code>NumberFormatException</code>异常。</p><h3 id="强制类型转换">强制类型转换</h3><p><strong>type casting</strong></p><p class="note note-info">cast有“铸造”之意，很贴合“强制转换”的意思</p><p><strong>ECMAScript 中可用的3种强制类型转换</strong>：</p><ul><li>Boolean(value) - 把给定的值转换成 Boolean 型；空字符串、数字0、undefined 或 null，返回 false。</li><li>Number(value) -把给定的值转换成数字（可以是整数或浮点数）；处理<strong>整个值</strong>。</li><li>String(value) - 把给定的值转换成字符串；</li></ul><h1 id="函数">函数</h1><p>使用<strong>function</strong>进行定义，语法为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">para1, para2,...</span>) &#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>形参不需要类型，因为js弱类型</li><li>返回值也不需要定义类型，有return就说明有返回值</li><li>调用的时候可以传递任意个数的参数</li></ul><p>函数作为形参时，使用lambda表达式会舒服很多。</p><h2 id="闭包closure">*闭包(closure)</h2><h3 id="引入">引入</h3><p>JS比较独特的一个特性。</p><div class="note note-secondary">            <p>JavaScript 变量属于 本地 或 全局 作用域。 全局变量能够通过 闭包实现局部（私有）。</p>          </div><ul><li>在网页中，全局变量属于<code>window</code>对象，全局变量能够被页面中（以及窗口中）的所有脚本使用和修改。</li><li>而局部变量只能用于其被定义的函数内部，对于其他函数和脚本代码来说它是不可见的。</li></ul><p>考虑下面这种情况：我们想做一个计数器用来计数函数被调用的次数。如果使用下面这种方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 初始化计数器</span><br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 递增计数器的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>  counter += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 调用三次 add()</span><br><span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">add</span>();<br><span class="hljs-title function_">add</span>();<br><br><span class="hljs-comment">//此时计数器为3</span><br></code></pre></td></tr></table></figure><p>虽然能实现计数的功能，但是<strong>不够安全</strong>，因为作为全局变量的<code>counter</code>可以被任意函数随意更改。为了防止随意更改，考虑把它声明为局部变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">plus</span>(<span class="hljs-params"></span>) &#123;counter += <span class="hljs-number">1</span>;&#125;<br>    <span class="hljs-title function_">plus</span>();     <br>    <span class="hljs-keyword">return</span> counter; <br>&#125;<br></code></pre></td></tr></table></figure><p>显然仍然存在问题，因为每次调用这个函数时都会给<code>counter</code>重新赋值为0，不能实现计数的功能，我们必须保证初始化函数之被调用一次</p><p>在Java中，我们可以使用权限修饰符<code>private</code>和<code>getter</code>解决安全性问题，但是JS中没有权限修饰符，怎么办？有没有什么东西可以实现类似的功能？</p><p>答案是有的，那就是闭包。</p><hr /><h3 id="使用">使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> counter += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> conterFunc = <span class="hljs-title function_">add</span>(); <span class="hljs-comment">// 获得内层函数</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">conterFunc</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">conterFunc</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">conterFunc</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">conterFunc</span>());<br><br><span class="hljs-comment">//控制台： 1  2  3  4</span><br></code></pre></td></tr></table></figure><ul><li><code>add</code>是外层函数，内部定义了一个内部匿名函数，并且<code>add</code>的返回值就是内部函数的引用，或者说句柄；</li><li><code>const conterFunc = add();</code>调用了一次外层函数，创建一个<code>counter</code>并初始化为0；</li><li>之后每次调用<code>conterFunc()</code>实际上调用的是内层函数，因为<code>counter</code>还是第一次创建好的那个，所以可以正常计数；</li><li>又因为<code>counter</code>是函数内部定义的局部变量，所以不会被外界访问到，足够安全。</li></ul><p><strong>注意</strong>：每次调用<code>add()</code>会生成新的独立包，相互独立互不影响，所以只在开头调用了一次。</p><p>闭包还可以把多参数的函数变成单参数的函数，例如平方和立方的计算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 把x和n分配到外层函数和内层函数即可实现 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">make_pow</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(x, n);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 创建两个新函数:</span><br><span class="hljs-keyword">let</span> pow2 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> pow3 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">pow2</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 25</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">pow3</span>(<span class="hljs-number">7</span>)); <span class="hljs-comment">// 343</span><br></code></pre></td></tr></table></figure><h2 id="生成器generator">生成器(generator)</h2><p>ES6标准引入的新的数据类型。另外，</p><div class="note note-primary">            <p>生成器函数 是一种可以“暂停执行”的函数，通过 function* 定义，用 yield控制流程，返回的是一个 可迭代对象（iterator）。</p>          </div><ul><li><code>yield</code>: 返回一个值给外部，同时暂停函数的执行。</li><li><code>next()</code>: 一旦调用就执行到下一个<code>yield</code></li></ul><p>调用这个函数不会直接执行函数体内部的代码，而是返回一个<strong>生成器对象</strong>（generatorobject）。每次调用它都会重开一个生成器。</p><p>为了让生成器能往下跑，需要采用类似闭包的方法：先获取句柄</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">countUp</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">yield</span> i++; <span class="hljs-comment">// 返回i的值，然后i+1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">countUp</span>(); <span class="hljs-comment">// 先创建一个“可以暂停的执行器” </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 2</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">countUp</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);<span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><h1 id="对象">对象</h1><ul><li>Array</li><li>String</li><li>JSON</li><li>BOM(Browser Object Model, 浏览器对象模型)</li><li>DOM(Document Object Model, 文档对象模型)</li></ul><h2 id="包装类对象">包装类对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123.</span>.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 不报错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123.</span><span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p><strong>别用</strong></p><h2 id="date">Date</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2018</span>, <span class="hljs-number">11</span>, <span class="hljs-number">24</span>, <span class="hljs-number">10</span>, <span class="hljs-number">33</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d);<br><span class="hljs-comment">//控制台输出：Mon Dec 24 2018 10:33:30 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>JavaScript 从 0 到 11 计算月份。 一月是 0。十二月是11。6个数字指定年、月、日、小时、分钟、秒：</p>          </div><h2 id="array">Array</h2><ul><li><strong>定义</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 一般方式</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 简化的方式</span><br><span class="hljs-keyword">var</span> cars = [<span class="hljs-string">&quot;Saab&quot;</span>, <span class="hljs-string">&quot;Volvo&quot;</span>, <span class="hljs-string">&quot;BMW&quot;</span>];<br></code></pre></td></tr></table></figure><ul><li><strong>访问</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">arr[index] = value;<br></code></pre></td></tr></table></figure><ul><li><strong>遍历</strong>：推荐<code>forEach</code>方法（相当于Java中的forEach+lambda表达式）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element);<br>&#125;);<br></code></pre></td></tr></table></figure><p>JS数组长度可变，类型可变，可以存储任意类型的数据。没有赋值的位置记为undefined。</p><p><strong>属性</strong>：<code>length</code>，用法同Java</p><p><strong>方法</strong>：</p><ul><li><code>forEach</code>:遍历<strong>有值</strong>的元素，并调用传入的函数</li><li><code>push()</code>:将新的元素添加到数组的末尾，并返回新的长度</li><li><code>splice(start: number, deleteCount?: number): number[]</code>:从数组中删除元素，左闭右开。问号表示可选参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台：3 4</p><h2 id="string">String</h2><p><strong>创建</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 变量名 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;...&quot;</span>);<br><span class="hljs-keyword">var</span> 变量名 = <span class="hljs-string">&quot;...&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>属性</strong>：<code>length</code></p><p><strong>方法</strong>：</p><ul><li><code>charAt(index)</code>:返回字符串中 指定位置的字符。</li><li><code>indexOf(searchValue, fromIndex?)</code>:从fromIndex开始查找某个子字符串第一次出现的位置，找不到就返回-1。</li><li><code>trim()</code>:去除字符串两边的空格（不包括中间的空格）。</li><li><code>substring(startIndex, endIndex?)</code>:截取字符串的一部分，左闭右开。</li></ul><h3 id="对字符串做一些补充">对字符串做一些补充</h3><ol type="1"><li><strong>多行字符串</strong>：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-string">`这是一个</span><br><span class="hljs-string">多行</span><br><span class="hljs-string">字符串</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure><p>通过反引号的形式声明多行字符串，可以省去换行字符。</p><ol start="2" type="1"><li><strong>模板字符串</strong>：</li></ol><p>要把多个字符串连接起来，可以用+号连接；ES6新增了一种模板字符串，连接字符串更方便：（注意使用反引号包裹）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;sss&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">17</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`名字是：<span class="hljs-subst">$&#123;person.name&#125;</span>, 年龄是<span class="hljs-subst">$&#123;person.age&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h2 id="json">JSON</h2><p>基于 JavaScript 语言的轻量级的数据交换格式（JavaScript ObjectNotation）</p><p>意义：</p><div class="note note-success">            <p>当数据在浏览器与服务器之间进行交换时，这些数据只能是文本。</p><p>JSON 属于文本，并且我们能够把任何 JavaScript 对象转换为 JSON，然后将JSON 发送到服务器。</p><p>我们也能把从服务器接收到的任何 JSON 转换为 JavaScript 对象。</p><p>以这样的方式，我们能够把数据作为 JavaScript对象来处理，无需复杂的解析和转译。</p>          </div><p>虽然名字里有 JavaScript，但它是语言无关的格式，可以被几乎所有语言（如Python、Java、C#）支持。</p><hr /><p>先说说JS自定义对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 对象名 = &#123;<br>    属性名：属性值,<br>    ...<br>    函数名:<span class="hljs-keyword">function</span>(<span class="hljs-params">形参列表</span>)&#123;执行代码&#125;<br>    <span class="hljs-comment">// :function 可以省略</span><br><br>&#125;;<br></code></pre></td></tr></table></figure><hr /><p>如何定义一个JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hưng&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">21</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;languages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Vietnamese&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Japanese&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Chinese&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;isStudent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;details&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Ho Chi Minh&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hobbies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;music&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;anime&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;games&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>把 JSON字符串转为对象</strong>：<code>const obj = JSON.parse(jsonStr);</code></li><li><strong>把对象转为 JSON字符串</strong>：<code>const jsonStr = JSON.stringify(obj);</code></li></ul><h1 id="面向对象编程">面向对象编程</h1><p>参看这位大佬的博客：</p><p><ahref="https://www.cnblogs.com/wangfupeng1988/p/3977924.html">深入理解javascript原型和闭包</a></p><h1 id="bom">BOM</h1><p>浏览器对象模型允许 JavaScript 与浏览器对话。</p><ul><li><code>window</code>:窗口对象，去除占位符后的净宽高为（IE&lt;=8不支持）<ul><li><code>innerWidth</code></li><li><code>innerHeight</code></li></ul></li><li><code>screen</code>:表示屏幕的信息（宽，高，位宽）</li><li><code>location</code>:当前页面的URL信息<ul><li><p><code>location.href</code>:当前页面的URL</p></li><li><p><code>setInterval</code>持续重复执行该函数。</p></li><li><p><code>setTimeout</code>在等待指定的毫秒数后执行函数。</p></li></ul></li></ul><p><strong>Cookie</strong></p><div class="note note-secondary">            <p>浏览器用来存储小块数据（最多约 4KB）的一种机制。它可以在用户浏览网页时，在本地保存数据，并在之后访问时自动携带到服务器。</p>          </div><p>我们登录了一个网站，关闭网页后第二天再来，不用重新登录了，就是因为Cookie。</p><h1 id="dom">DOM</h1><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document ObjectModel）。</p><p>HTML DOM 模型被结构化为对象树：</p><figure><img src="https://www.w3school.com.cn/i/ct_htmltree.gif"alt="https://www.w3school.com.cn/js/js_htmldom.asp" /><figcaptionaria-hidden="true">https://www.w3school.com.cn/js/js_htmldom.asp</figcaption></figure><p>通过<code>document</code>对象的方法可以找到对象树上的节点，常用的有：</p><ul><li><code>getElementById()</code></li><li><code>getElementsByTagName()</code></li></ul><h2 id="更新">更新</h2><p>获取对象后，可以对对象进行操作：</p><ul><li><code>innerHTML</code></li><li><code>innerText</code></li><li><code>textContent</code></li></ul><p>也可以修改css样式（和css的命名方式不一样）</p><ul><li><code>.style.color</code></li><li><code>.style.fontSize</code></li><li><code>.style.paddingTop</code></li></ul><p>格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(id).<span class="hljs-property">style</span>.<span class="hljs-property">property</span> = newstyle<br></code></pre></td></tr></table></figure><h2 id="插入">插入</h2><ul><li><code>appendChild</code></li><li><code>insertBefore</code> ## 删除</li></ul><p>父节点调用<code>removeChild</code>删除子节点</p><h1 id="async">Async</h1><h2 id="回调">回调</h2><p>回调函数（Callback Function），将一个函数作为参数传递给另一个参数</p><h1 id="js事件">JS事件</h1><p>事件绑定的方式：</p><ul><li>通过HTML中的事件属性。例如<code>&lt;button onclick="displayDate()"&gt;试一试&lt;/button&gt;</code></li><li>通过DOM分配事件，例如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myBtn&quot;</span>).<span class="hljs-property">onclick</span> = displayDate;<br>&lt;/script&gt; <br></code></pre></td></tr></table></figure><h2 id="事件监听">*事件监听</h2><div class="note note-secondary">            <p>在 JavaScript 中，事件监听（Event Listener） 是指你为一个 HTML元素绑定一个函数（监听器），当某个事件发生时（比如点击、键盘输入、鼠标悬停等），这个函数就会被自动调用。</p>          </div><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(event, <span class="hljs-keyword">function</span>, useCapture);<br></code></pre></td></tr></table></figure><ul><li>事件类型</li><li>事件发生时调用的函数</li><li>布尔值，指定事件是使用冒泡还是事件捕获，可选参数，默认是冒泡阶段（用得很少）</li></ul><p>可以向一个元素添加多个事件处理程序。</p>]]></content>
    
    
    <categories>
      
      <category>Web Development</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Fluid博客美化记录</title>
    <link href="/2025/04/20/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%962/"/>
    <url>/2025/04/20/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%962/</url>
    
    <content type="html"><![CDATA[<p>简单的博客美化记录 <span id="more"></span></p><h1 id="美化清单">美化清单</h1><ol type="1"><li><a href="#添加博客加载页面">添加博客加载页面</a></li><li><a href="#github状态和活跃曲线">Github状态和活跃曲线</a></li><li><a href="#mac风格代码块">mac风格代码块</a></li><li><a href="#艺术字签名">艺术字签名</a></li><li><a href="#更换图床">更换图床</a></li><li><a href="#遗留问题">遗留问题</a></li></ol><h1 id="添加博客加载页面">添加博客加载页面</h1><p>Fluid主题本身是不支持固定背景图的，强行固定会导致加载页面时明显观察到背景图“瞬移”，而且不适配移动端。</p><p>现在移动端我先不管了，这里通过添加加载页面的方式规避背景图瞬移的问题。</p><p>代码源自该<ahref="https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-loading/fluid-loading/">实例</a></p><p>关于第一步，“在bodyBegin注入元素代码”，即把下面这段代码加到博客目录下的<code>\Blogs\node_modules\hexo-theme-fluid\layout\layout.ejs</code>的<code>&lt;body&gt;</code>开头的部分：</p><p><img src="https://i.imgur.com/SGhKbvj.png" /></p><p>剩下的CSS和js代码分别添加到自定义CSS和js文件中即可。</p><h1 id="github状态和活跃曲线">Github状态和活跃曲线</h1><p>项目地址：</p><ul><li><ahref="https://github.com/anuraghazra/github-readme-stats?tab=readme-ov-file">github-readme-stats</a></li><li><ahref="https://github.com/Ashutosh00710/github-readme-activity-graph">github-readme-activity-graph</a></li></ul><p>复制粘贴到关于页即可。</p><h1 id="mac风格代码块">mac风格代码块</h1><p>参考：<ahref="https://qingshaner.com/HexoFluid%E4%B8%BB%E9%A2%98%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/">HexoFluid主题代码块样式修改</a></p><h1 id="艺术字签名">艺术字签名</h1><p>参考链接</p><ul><li><ahref="https://mrna16.github.io/2024/11/14/%E3%80%90Hexo%E3%80%91Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/#%E6%A0%87%E7%AD%BE%E5%8F%98%E5%8C%96">【Hexo】Fluid主题美化</a></li><li><a href="https://4rozen.github.io/archives/Hexo/38001.html">使用 CSS和 JS 实现博客导航栏线条动画效果</a>（这个的讲解更详细）</li></ul><p>签名动画似乎与加载页面不兼容，我没有看到动画效果，所以把动画部分的代码去掉了。</p><p>对<code>sign.css</code>部分:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.svg</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: auto;<br>  &#125;<br>  <br>  <span class="hljs-selector-class">.svg</span> <span class="hljs-selector-tag">path</span> &#123;<br>    <span class="hljs-attribute">stroke</span>: white;<br>    <span class="hljs-attribute">stroke-width</span>: <span class="hljs-number">3pt</span>;<br>    <span class="hljs-attribute">stroke-linecap</span>: round;<br>    <span class="hljs-attribute">stroke-dasharray</span>: <span class="hljs-built_in">var</span>(--l);<br>    <span class="hljs-attribute">stroke-dashoffset</span>: <span class="hljs-built_in">var</span>(--l);<br>    <span class="hljs-attribute">fill</span>: none;<br>    <span class="hljs-attribute">fill-rule</span>: nonzero;<br>    <span class="hljs-attribute">animation</span>: stroke <span class="hljs-number">25s</span> forwards;<br>    -webkit-<span class="hljs-attribute">animation</span>: stroke <span class="hljs-number">25s</span> forwards;<br>  &#125;<br>  <br>  <span class="hljs-keyword">@keyframes</span> stroke &#123;<br>    <span class="hljs-selector-tag">to</span> &#123;<br>      <span class="hljs-attribute">stroke-dashoffset</span>: <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><code>width</code>和<code>height</code>两个属性可以改为<code>100%</code>和<code>auto</code>，我经过尝试发现影响签名大小的主要还是<ahref="https://danmarshall.github.io/google-font-to-svg-path/">GoogleFont to SvgPath</a>的Size数值，所以不用纠结宽和高到底应该填多少了，直接自适应。这里Size取的是35。</p><p><code>sign.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span>  navbarBrand  =  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.container a&#x27;</span>);<br><br>navbarBrand.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;object type=&quot;image/svg+xml&quot; data=&quot;/img/banyee&#x27;s Blog.svg&quot;&gt;&lt;/object&gt;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-comment">// const  paths  =  document.querySelector(&#x27;.container .navbar-brand .svg .g path&#x27;)</span><br><br><span class="hljs-comment">// const  len  =  paths.getTotalLength()</span><br><br><span class="hljs-comment">// paths.style.setProperty(&#x27;--l&#x27;, len)</span><br></code></pre></td></tr></table></figure><p>动画部分的代码已经被注释。另外，引入<code>.svg</code>文件时可以用上面的这种方法，先把svg文件下载到source目录下的一个img文件夹中，再引用，这样可以让代码看起来简洁一些。</p><h1 id="更换图床">更换图床</h1><p>之前用的一直是imgur，国外的老牌免费图床网站，稳定安全可靠。但是被墙了，至于为什么被墙啊俺也不知道</p><p>鉴于国内用户无法访问托管在imgur上的图片，所以我打算换个图床</p><p>一开始打算打算使用腾讯COS存储，主要是冲着访问速度快+长期稳定去的<spanclass="heimu"title="你知道的太多了">虽然但是腾讯你什么时候死</span>，跟着<ahref="https://cloud.tencent.com/developer/article/1834573">教程</a>走了几步，到了要绑定域名的时候</p><p><img src="https://i.imgur.com/5nHrB3T.png" /></p><p>本来想着来都来了，那就备案啊，然后备案强制实名认证😂</p><p>这时候我才意识到貌似国内的域名都要备案之后才能使用</p><p>然后我又尝试了SM.MS图床，这个图床的来历：</p><figure><img src="https://i.imgur.com/4RJjAug.png"alt="SM.MS诞生于互联网精神" /><figcaption aria-hidden="true">SM.MS诞生于互联网精神</figcaption></figure><p>然后我试着访问了主站</p><p><img src="https://i.imgur.com/BOutTZH.png" /></p><blockquote><p>"Due to network issues, users from China Mainland are unable toaccess SM.MS, we have added an alternate domain name smms.app"</p></blockquote><p>又被大陆墙了😂而且这个图床已经关闭了注册功能</p><p>最后我转向了<ahref="https://imgse.com/page/about">路过图床</a>。这个图床也是蛮幽默的，注册时如果挂着VPN，会马上触发安全机制：</p><figure><img src="https://i.imgur.com/bfFspUp.png" alt="😭" /><figcaption aria-hidden="true">😭</figcaption></figure><p>不过这个图床已经稳定运行了14年，最大支持10M的图片，同时具有全球 CDN加速以确保高速、稳定。暂时就先用着这个好了。</p><p>向路过图床上传图片的时候也要求关闭VPN代理，所以最好的办法就是直接在clash新建规则，检测到imgse关键词就走直连</p><figure><img src="https://s21.ax1x.com/2025/04/21/pE5lxs0.png"alt="顺便一提我之前把adobe直接禁了，因为联网有盗版检测" /><figcaptionaria-hidden="true">顺便一提我之前把adobe直接禁了，因为联网有盗版检测</figcaption></figure><p>老文章的图片就不迁移了，因为懒</p><h1 id="遗留问题">遗留问题</h1><p>我的文章页背景图为亮色，并且启用了毛玻璃效果，这样一来在黑夜模式下会显得很突兀。最理想的解决方法是设置文章页的背景可以随日夜模式动态切换，黑夜模式就切换为：</p><figure><img src="https://i.imgur.com/fmmmG7o.jpg" alt="玉足🥰" /><figcaption aria-hidden="true">玉足🥰</figcaption></figure><p>今天对着这篇博客折腾了很长时间</p><p><a href="https://4rozen.github.io/archives/Hexo/60191.html">fluid全屏背景图随日夜模式切换和正文底页毛玻璃效果</a></p><p>结果失败了。具体体现为：只有在进入博客的一瞬间可以看到白天模式下的背景图，之后马上被黑夜模式的背景图覆盖；模式切换按钮不起作用；而且主页的背景图也被覆盖掉了。这和这个文章的博客的表现完全相同，推测最早这些代码是起作用的，但是现在失效了。</p><p>比较好的例子是<ahref="https://qingshaner.com/">这个博客</a>，具体实现方式不明。这个问题留到以后再解决好了。</p><hr /><p>2025/4/21补充</p><p>今天收到了漫自由发来的邮件： <imgsrc="https://s21.ax1x.com/2025/04/21/pE5ec1f.png" /></p><p>漫自由是我在找漫画资源时发现的网站，也是我见过的为数不多的专门对大陆用户表示欢迎的网站，喜提被墙名单+1</p><p>他现在新开辟了一个域名，大陆可访问，内容和原网址是完全相同的，不知道能坚持多久</p>]]></content>
    
    
    <categories>
      
      <category>Theme</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE-Stream API详解 by AlbertShen</title>
    <link href="/2025/04/18/java11/"/>
    <url>/2025/04/18/java11/</url>
    
    <content type="html"><![CDATA[<p>参考：<ahref="https://www.bilibili.com/video/BV1Vi421C73n/?spm_id_from=333.1387.list.card_archive.click&amp;vd_source=918a6909c997fbaf818d1fbc55d65ca9">Java中的流、并行流</a></p><p>本博文为视频内容的简单梳理。</p><h1 id="目录">目录</h1><h1 id="引入">引入</h1><p>已知一个列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Person&gt; people = List.of(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>检查所有人的信息，找出年龄大于18岁的人。</p><p><strong>命令式编程</strong>，使用for循环依次检查每一个人的信息，将年龄超过十八岁的人添加到新的名单中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    <span class="hljs-comment">//创建新的列表用来存放结果</span><br>    List&lt;Person&gt; adults = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(Person p : people) &#123;<br>        <span class="hljs-keyword">if</span>(p.getAge() &gt; <span class="hljs-number">18</span>) &#123;<br>            adults.add(p);<br>        &#125;<br>    &#125;<br>    System.out.println(adults);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<strong>Stream API</strong>可以实现相同的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    List&lt;Person&gt; adults = people.stream()<br>            .filter(person -&gt; person.getAge() &gt; <span class="hljs-number">18</span>)<br>            .toList();<span class="hljs-comment">//或者.collect(Collectors.toList());</span><br>    System.out.println(adults);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>代码更加简洁。</p><p>Stream本身并不是数据结构，不会处理数据或改变数据源，它仅定义处理方式。不仅能够支持顺序处理，还能进行并行处理。</p><p><strong>Java的Stream只能使用一次</strong>，一旦你调用了终结操作（比如.forEach()、.collect() 等），这个流就被“消费掉”了，不能再用。</p><p><strong>三个步骤</strong>：</p><ul><li><strong>创建流</strong> Stream Creation</li><li><strong>中间操作</strong> Intermediate Operations<ul><li>中间操作是惰性执行的，只有遇到终端操作才会实际执行。</li></ul></li><li><strong>终端操作</strong> Terminal Operations<ul><li>整个流的实际处理部分，他会触发之前所有定义中的中间操作，生成最终结果。</li></ul></li></ul><p><img src="https://i.imgur.com/Pxty23E.png" /></p><p>下面从这三个方面进行分析。</p><h1 id="创建流">创建流</h1><p>对于任何实现了<code>Collection</code>接口的集合，可以通过<code>stream()</code>方法直接创建流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>&#125;;<br>Stream&lt;String&gt; stream = Arrays.stream(array);<br><br>stream.forEach(System.out::println);<br><br>List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>Stream&lt;String&gt; myStream = list.stream();<br>myStream.forEach(System.out::println);<br><br><span class="hljs-comment">//更直接的方法</span><br>Stream&lt;String&gt; stream1 = Stream.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure><hr /><p>采用上述方法创建的stream对象自诞生之初就是写死的，无法修改。想要<strong>动态创建流</strong>，需要使用<code>Stream.Builder</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建对象</span><br>Stream.Builder&lt;String&gt; builder = Stream.builder();<br><span class="hljs-comment">//添加元素</span><br><span class="hljs-comment">//添加后无法删除</span><br>builder.add(<span class="hljs-string">&quot;a&quot;</span>);<br>builder.add(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">//也可根据条件动态添加</span><br><span class="hljs-keyword">if</span>(Math.random()&lt;<span class="hljs-number">0.5</span>)&#123;<br>    builder.add(<span class="hljs-string">&quot;c&quot;</span>);<br>&#125;<br><span class="hljs-comment">//通过build方法来创建stream对象</span><br>Stream&lt;String&gt; stream = builder.build();<br><span class="hljs-comment">//一旦调用了build就不能再添加元素，否则执行时报错</span><br>stream.forEach(System.out::println);<br></code></pre></td></tr></table></figure><hr /><p>使用Stream也可<strong>从文件创建流</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:\\develop\\code\\Practice\\chapter0\\hello_copy.txt&quot;</span>);<br>    <span class="hljs-keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(path))&#123;<br>        lines.forEach(System.out::println);<span class="hljs-comment">//输出到控制台</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>Files.lines(path, StandardCharsets.UTF_8)</code>返回一个惰性读取的Stream，可以逐行读取文本文件内容。</li><li><code>try-with-resources</code>保证资源及时关闭</li></ul><hr /><p>StreamAPI也提供了<code>IntStream</code>等类用来方便地创建<strong>基本数据类型的流</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>);<br><span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">//通过boxed可以把基本数据类型的流转换为对象流：</span><br>Stream&lt;Integer&gt; integerStream = intStream.boxed();<br></code></pre></td></tr></table></figure><hr /><p>Stream.iterate可生成<strong>无限流</strong>（通常用limit限制生成的个数）：</p><p><strong>语法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">iterate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T seed, <span class="hljs-keyword">final</span> UnaryOperator&lt;T&gt; f)</span><br></code></pre></td></tr></table></figure><ul><li><code>seed</code>:初始值</li><li><code>f</code>：作用于初始值的函数</li><li>返回值：一个新的Stream类型的序列</li></ul><p>增强型：<code>public static&lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next)</code>，其中<code>hasNext</code>是终止条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成一个等差数列</span><br>   Stream.iterate(<span class="hljs-number">0</span>, i -&gt; i + <span class="hljs-number">1</span>).limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><hr /><p><strong>并行流</strong>：把数据分成多个部分，并“同时”用多个线程来处理，从而加快处理速度。</p><ul><li>对于集合，调用<code>list.parallelStraem()</code>可以直接得到一个并行流。例如<code>List.of("a", "b", "c", "d", "e", "f").parallelStream().forEach(System.out::println);</code>，输出是<strong>乱序</strong>的</li><li>对于已有的Stream，可以调用<code>.parallel()</code>得到并行流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> &#123;<br>    Stream&lt;Integer&gt; iterateStream = Stream.iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">1</span>).limit(<span class="hljs-number">5</span>);<br>    iterateStream.parallel();<br>    iterateStream.forEach(System.out::println);<br>    <span class="hljs-comment">//这时的打印顺序也是乱的，因为forEach是并发的。</span><br>    <span class="hljs-comment">//forEachOrdered可以保证顺序。</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="中间操作">中间操作</h1><p>中间操作用于对流中的元素进行处理，如筛选、排序等等。根据操作的性质可以分为以下几个类别：</p><ul><li><strong>筛选和切片</strong>(Filtering andSlicing):过滤或缩减流中的元素的数量</li><li><strong>映射</strong>(Mapping):转换流中的元素或提取元素的特定属性</li><li><strong>排序</strong>(Sorting)</li></ul><figure><img src="https://i.imgur.com/naZpiDN.png" alt="中间操作图解" /><figcaption aria-hidden="true">中间操作图解</figcaption></figure><h2 id="筛选和切片">筛选和切片</h2><p>例如开头处提到的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Person&gt; adults = people.stream()<br>        .filter(myperson -&gt; myperson.getAge() &gt; <span class="hljs-number">18</span>)<br>        .toList();<span class="hljs-comment">//或者.collect(Collectors.toList());</span><br></code></pre></td></tr></table></figure><p><strong>过滤器定义</strong>:</p><p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code></p><p>Predicate即<strong>判断条件函数</strong>，用lambda写出，返回布尔值。意思是:<em>给我一个叫myperson 的参数，判断这个人年龄是否大于 18，返回一个 true/false结果</em>。<code>myperson</code>的类型由前文自动推断出，所以省略。</p><p>这里等价于用更简洁的形式实现了<code>Predicate</code>接口的抽象方法<code>boolean test(T t);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;Person&gt; predicate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Person&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Person person)</span> &#123;<br>        <span class="hljs-keyword">return</span> person.getAge() &gt; <span class="hljs-number">18</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr /><p>可以用<code>.distinct()</code>为流中的元素<strong>去重</strong>，底层通过维护一个HashSet实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//</span><br>    Stream.of(<span class="hljs-string">&quot;Origami&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-string">&quot;Kurumi&quot;</span>)<br>            .distinct()<br>            .forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是自定义的类的对象，需要确保正确地重写了<code>equals()``HashCode</code>方法，因为HashSet就是通过这两个方法判断元素是否相等。</p><hr /><p>Stream类中定义的<code>Stream&lt;T&gt; limit(long maxSize);</code>方法返回由此流的元素组成的截断长度不超过maxSize的流。</p><p>同样，<code>Stream&lt;T&gt; skip(long n);</code>跳过前n个元素。</p><p>limit和skip在有序的并行流中使用时可能会使性能变差，此时可以用<code>.unordered()</code> 提高效率；如果顺序必须保留，那最好使用顺序流<code>.sequential()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    Stream&lt;Integer&gt; s1 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br>    s1.limit(<span class="hljs-number">5</span>).forEach(System.out::print);<br><br>    Stream&lt;Integer&gt; s2 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br>    s2.skip(<span class="hljs-number">5</span>).forEach(System.out::print);<br>    <span class="hljs-comment">//打印结果：12345678910</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="映射">映射</h2><p>映射本质上是一个数据转换的过程</p><p><strong>定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, ? extends R&gt; mapper)</span>;<br></code></pre></td></tr></table></figure><p><code>T</code>是Stream中元素的类型，<code>R</code>新的流的元素类型</p><p>map能够通过提供的函数<code>Function</code>将流中的每个元素转换成新的元素，最后生成一个新元素构成的流。</p><p>map接受的是一个<strong>函数式接口</strong>。</p><figure><img src="https://i.imgur.com/Yk5xhTe.png"alt="利用映射层层提取数据的过程" /><figcaption aria-hidden="true">利用映射层层提取数据的过程</figcaption></figure><p>示例：利用映射获得Person列表中所有人的name</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br><br>    Stream&lt;Person&gt; peopleStream = people.stream();<br>    <span class="hljs-comment">//peopleStream.map(myperson -&gt; myperson.getName()).forEach(System.out::println);</span><br>    <span class="hljs-comment">//方法引用的格式：类名或对象名::方法名</span><br>    peopleStream.map(Person::getName).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">Neo<br>Blu<br>Alex<br>Bob<br>Kurumi<br>Kurumi<br></code></pre></td></tr></table></figure><hr /><p><code>map</code>结构适用于<strong>单层结构</strong>的流，进行元素<strong>一对一</strong>的转换。</p><p>对于嵌套的集合，数组等等，适合使用<code>flatMap</code>。</p><p><img src="https://i.imgur.com/sq8UWmE.png" /></p><p><strong>定义</strong>：<code>Stream.java</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; Stream&lt;R&gt; <span class="hljs-title function_">flatMap</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span>;<br></code></pre></td></tr></table></figure><p>示例：将嵌套List转换成的流扁平化为单层流打印出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test7</span><span class="hljs-params">()</span> &#123;<br>    List&lt;List&lt;Person&gt;&gt; peopleGroups = List.of(<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;neo&quot;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Stan&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;USA&quot;</span>)<br>            ),<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Grace&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;UK&quot;</span>),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">17</span>, <span class="hljs-string">&quot;UK&quot;</span>)<br>            ),<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Sebastian&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;FR&quot;</span>)<br>            )<br>    );<br><br>    Stream&lt;List&lt;Person&gt;&gt; peopleGroupStream = peopleGroups.stream();<br>    <span class="hljs-comment">//转换成单层流  扁平化  单一化</span><br>    Stream&lt;Person&gt; personStream = peopleGroupStream.flatMap(people -&gt; people.stream());<br>    personStream.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>流操作返回的是一个新的流，原始流在第一次操作后就会被标记为已操作，不能再次进行操作。实际应用中通常会采用<strong>链式操作</strong>:</p><p><img src="https://i.imgur.com/lZ0Yc3R.png" /></p><p>嵌套流 -&gt; 单层流 -&gt; 提取name属性 -&gt; 打印</p><hr /><p><code>mapToInt</code>可以将对象流转换为基础类型的流<code>IntStream</code>。</p><hr /><h2 id="排序">排序</h2><p>当流中的元素类型实现了<code>Comparable</code>接口时（自然排序），可直接调用<code>sorted()</code>。</p><p>定制排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test10</span><span class="hljs-params">()</span> &#123;<br>    Stream.of(<span class="hljs-string">&quot;blueberry&quot;</span>, <span class="hljs-string">&quot;greenberry&quot;</span>, <span class="hljs-string">&quot;redberry&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>)<br>            .sorted(Comparator.comparingInt(String::length).reversed())<br>            .forEach(System.out::println);<br>            <span class="hljs-comment">//年龄降序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于<code>Comparator.comparingInt(String::length).reversed()</code>:</p><ul><li><code>comparingInt</code>是Comparator的一个方法</li><li>相当于<code>Comparator.comparingInt(p -&gt; p.getAge())</code>，将Age作为排序的标准</li><li><code>comparingInt</code>和<code>reversed()</code>并列定义，但是前者返回的仍然是一个<code>Comparator&lt;T&gt;</code>对象，后者是一个Comparator的默认方法，只要是<code>Comparator&lt;T&gt;</code>的对象就可以调用它。</li></ul><hr /><p>中间操作只是定义了操作的规则，并不会立即执行，常常用变量保存和传递。</p><p>综合练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    List&lt;List&lt;Person&gt;&gt; peopleGroups = List.of(<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;neo&quot;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Stan&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;USA&quot;</span>)<br>            ),<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Grace&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;UK&quot;</span>),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;UK&quot;</span>)<br>            ),<br>            List.of(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Sebastian&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;FR&quot;</span>),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Sebastian&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;FR&quot;</span>)<br>            )<br>    );<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扁平化、去重、年龄大于18、映射到name、按照名字的长度排序</span><br><span class="hljs-comment">     */</span><br>    Stream&lt;String&gt; s= peopleGroups.stream()<br>            .flatMap(List::stream)<br>            .distinct()<br>            .filter(person -&gt; person.getAge() &gt; <span class="hljs-number">18</span>)<span class="hljs-comment">//筛选</span><br>            .map(Person::getName)<br>            .sorted(Comparator.comparing(String::length));<span class="hljs-comment">//映射为字符串类型的名字之后再按照字符串的长度排序;</span><br>    <br>    <span class="hljs-comment">//触发执行操作</span><br>    s.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="终端操作">终端操作</h1><p>终端操作是流处理的最终步骤，实弹发生，流中的元素被消费，流不能再被使用。</p><p>终端操作包括查找与匹配、聚合操作、归约操作、收集操作、迭代操作。</p><p><img src="https://i.imgur.com/mg7OIu4.png" /></p><h2 id="查找与匹配">查找与匹配</h2><p>属于短路操作(Short-circuitingOperations),也就是说这些操作在找到所需的元素后会立即返回结果,不会遍历整个流.</p><ul><li><code>anyMatch</code>:如果流中任意元素满足给定的条件则返回true</li><li><code>noneMatch</code>:与前者相反</li><li><code>allMatch</code>:所有的都满足才会返回true</li></ul><hr /><ul><li><code>Optional&lt;T&gt; findFirst();</code>找到流中的第一个元素,类型为<code>Optional</code>.因为返回的元素可能为空,这样做的话更加安全.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    Optional&lt;Person&gt; optionalPerson = people.stream().findFirst();<br>    <span class="hljs-comment">//ifPresent:如果值存在，就执行括号里的操作，否则什么也不做.</span><br>    optionalPerson.ifPresent(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Person&#123;name=&#x27;Neo&#x27;, age=1, country=&#x27;USA&#x27;&#125;<br></code></pre></td></tr></table></figure><ul><li><code>findAny</code>:返回任意一个元素</li></ul><h2 id="聚合操作">聚合操作</h2><ul><li><code>long count();</code>:计算元素的数量</li><li><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);</code>:返回流中的最大元素,需要提供一个比较器.</li><li>同理还有<code>min</code></li></ul><hr /><ul><li><code>sum()</code>用于求和,只能处理基本数据类型的流,所以使用之前要进行流类型的转换.</li><li><code>average</code>同上</li></ul><p>本质上聚合操作是归约操作的一种特殊形式,适合快速简单的统计任务.归约操作reduce更加通用.</p><h2 id="归约操作">归约操作</h2><p>整型的reduce定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(<span class="hljs-type">int</span> identity, IntBinaryOperator op)</span>;<br></code></pre></td></tr></table></figure><p>Java提供的注解:</p><blockquote><p>对该流的元素执行归约操作，使用提供的标识值（identity）和一个关联的累积函数（accumulationfunction），并返回归约后的结果。其等价于以下代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> identity;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : <span class="hljs-built_in">this</span> stream)<br>    result = accumulator.applyAsInt(result, element)<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure>即,先把 identity的值赋给结果,然后再使用累计函数对结果和流中的元素进行运算.<br />这种归约不一定按顺序执行（即它可以并行处理）。<br />identity必须是一个<strong>恒等元</strong>,也就是说累计函数作用在它身上之后的结果仍然等于它本身.例如:<br />加法的恒等元是0,因为 0 + x = x<br />乘法的恒等元是1,因为1 * x = x<br />此外，累积函数必须是<strong>可结合的</strong>（associative）函数,也就是符合结合律,计算顺序不影响结果.</p></blockquote><p><strong>形参</strong>:</p><ul><li><code>identity</code>:累积函数的恒等元</li><li><code>op</code>:一个可结合的,无副作用(函数在处理值时不应该修改外部状态)的,无状态的函数</li></ul><p><strong>返回值</strong>:归约的结果</p><p>对一个流中的所有元素求和,可以写为<code>int sum = integers.reduce(0, (a, b) -&gt; a+b);</code><br />或者更简洁一点<code>int sum = integers.reduce(0, Integer::sum);</code></p><p>虽然相比于在循环中直接修改一个运行中的总和变量，这种方式看起来有些绕远路，但归约（reduction）操作在并行化时表现得更加优雅，无需额外的同步（synchronization），并且大大降低了数据竞争（dataraces）的风险。</p><hr /><p>例:对流的所有元素的年龄求和,然后输出所有人名字的串接字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    <span class="hljs-comment">//计算年龄的和</span><br>    <span class="hljs-type">IntStream</span> <span class="hljs-variable">doubleStream</span> <span class="hljs-operator">=</span> people.stream().mapToInt(Person::getAge);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> doubleStream.reduce(<span class="hljs-number">0</span>, (a,b) -&gt; (a + b));<br>    System.out.println(sum);<br><br>    <span class="hljs-comment">//将所有人的名字串接起来</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">joinedName</span> <span class="hljs-operator">=</span> people.stream()<br>            .map(Person::getName)<br>            .reduce(<span class="hljs-string">&quot;&quot;</span>, (a, b) -&gt; a + b);<br>    System.out.println(joinedName);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">86<br>NeoBluAlexBobKurumi<br></code></pre></td></tr></table></figure><h2 id="收集操作">收集操作</h2><p>把流处理后的元素汇集到新的数据结构中, 比如列表, map, 集合等等.</p><p><strong>定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R, A&gt; R <span class="hljs-title function_">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-built_in">super</span> T, A, R&gt; collector)</span>;<br></code></pre></td></tr></table></figure><p><code>Collectors.java</code>中提供了丰富的<strong>静态方法</strong>用作collector参数.如<code>toList</code>,<code>toMap</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//收集年龄大于18岁的人</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    List&lt;Person&gt; adults = people.stream()<br>            .filter(person -&gt; person.getAge() &gt; <span class="hljs-number">18</span>)<br>            .collect(Collectors.toList());<span class="hljs-comment">//使用Collectors提供的方法</span><br>    System.out.println(adults);<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p><strong>分组</strong>:<code>Collectors</code>类提供的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;<br> groupingBy(Function&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>&gt; classifier) &#123;<br>     <span class="hljs-keyword">return</span> groupingBy(classifier, toList());<br> &#125;<br></code></pre></td></tr></table></figure><ul><li><code>T</code>:流中元素的类型,例如<code>Person</code></li><li><code>K</code>:用于分组的键的类型</li><li><strong>形参</strong>:<code>classifier</code>,将输入元素映射到键的分类器函数</li><li><strong>返回值</strong>:实现分组操作的收集器,将<code>Stream&lt;T&gt;</code>收集成一个<code>Map&lt;K, List&lt;T&gt;&gt;</code>.<ul><li>key:由classifier生成</li><li>value:分到该组的<code>T</code>元素组成的列表</li></ul></li></ul><p>示例:根据国家分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    Map&lt;String, List&lt;Person&gt;&gt; collect = people.stream()<br>            .collect(Collectors.groupingBy(Person::getCountry));<br>    collect.forEach((k, v) -&gt; System.out.println(k + <span class="hljs-string">&quot; = &quot;</span> + v));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>T</code>在这里即<code>Person</code></li><li>这里的分类器是<code>(Person::getCountry)</code>,所以键的类型是<code>String</code></li><li>最终得到的Map泛型为<code>Map&lt;String, List&lt;Person&gt;&gt;</code></li></ul><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">USA = [Person&#123;name=&#x27;Neo&#x27;, age=1, country=&#x27;USA&#x27;&#125;]<br>Japan = [Person&#123;name=&#x27;Kurumi&#x27;, age=18, country=&#x27;Japan&#x27;&#125;]<br>China = [Person&#123;name=&#x27;Blu&#x27;, age=13, country=&#x27;China&#x27;&#125;]<br>Germany = [Person&#123;name=&#x27;Alex&#x27;, age=29, country=&#x27;Germany&#x27;&#125;, Person&#123;name=&#x27;Bob&#x27;, age=25, country=&#x27;Germany&#x27;&#125;]<br></code></pre></td></tr></table></figure><hr /><p><strong>分区</strong>功能同理,调用<code>Collectors.partitioningBy</code>即可,不过这时传入的是一个条件判断式, map的第一个参数也变成了boolean变量.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Person&gt;&gt; agePartition = people.stream()<br>                .collect(Collectors.partitioningBy(person -&gt; person.getAge() &gt; <span class="hljs-number">18</span>));<br>        agePartition.forEach((k, v) -&gt; System.out.println(k + <span class="hljs-string">&quot; = &quot;</span> + v));<br></code></pre></td></tr></table></figure><hr /><p><code>Collectors</code>也提供了拼接字符串的方法<code>joining</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">joinedName</span> <span class="hljs-operator">=</span> people.stream()<br>        .map(Person::getName)<br>        .collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>System.out.println(joinedName);<br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Neo,Blu,Alex,Bob,Kurumi<br></code></pre></td></tr></table></figure><p>也可以用<code>Collectors.joining</code>连接字符串.</p><hr /><p>使用<code>Collectors.summarizingInt</code>可以<strong>汇总</strong>指定的数据,返回类型为<code>IntSummaryStatistics</code>,使用<code>IntSummaryStatistics</code>的<code>get</code>方法可以快速获取最大值,最小值, 平均值等等.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test7</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    <span class="hljs-type">String</span> <span class="hljs-variable">joinedName</span> <span class="hljs-operator">=</span> people.stream()<br>            .map(Person::getName)<br>            .collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<span class="hljs-comment">//输出合并的字符串</span><br>    System.out.println(joinedName);<br><br>    <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">collect</span> <span class="hljs-operator">=</span> people.stream()<br>            .collect(Collectors.summarizingInt(Person::getAge));<br>    <span class="hljs-comment">//打印collect的所有属性(数量,和,最小值,平均值,最大值)</span><br>    System.out.println(collect);<br>    <span class="hljs-comment">//指定获取最大值</span><br>    System.out.println(collect.getMax());<br>    <span class="hljs-comment">//指定获取最小值</span><br>    System.out.println(collect.getMin());<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p><strong>自定义收集器</strong></p><p><code>Collector.of(...)</code>的五个参数结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Collector.of(<br>    Supplier&lt;R&gt; supplier,                         <span class="hljs-comment">// 创建中间结果容器</span><br>    BiConsumer&lt;R, T&gt; accumulator,                <span class="hljs-comment">// 如何添加元素</span><br>    BinaryOperator&lt;R&gt; combiner,                  <span class="hljs-comment">// 合并两个部分结果</span><br>    Function&lt;R, R&gt; finisher,                     <span class="hljs-comment">// 最终变换结果（可选）</span><br>    Collector.Characteristics... characteristics <span class="hljs-comment">// 特征标记</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customTest</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Person&gt; people = List.of(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Neo&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;USA&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Blu&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;China&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alex&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Germany&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Kurumi&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Japan&quot;</span>)<br>    );<br>    ArrayList&lt;Person&gt; collect = people.stream()<span class="hljs-comment">//.parallel()</span><br>            .collect(Collector.of(<br>                    () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), <span class="hljs-comment">//创建空容器</span><br>                    (list, person) -&gt; &#123;      <span class="hljs-comment">//累加器逻辑把一个 person 添加到当前线程维护的 list 里</span><br>                        System.out.println(<span class="hljs-string">&quot;Accumulator: &quot;</span> + person);<br>                        list.add(person);<br>                    &#125;,<br>                    (left, right) -&gt; &#123;       <span class="hljs-comment">//合并多个线程的中间结果,只在并行流起作用</span><br>                        System.out.println(<span class="hljs-string">&quot;Combiner: &quot;</span> + left);<br>                        left.addAll(right);<br>                        <span class="hljs-keyword">return</span> left;<br>                    &#125;,<br>                    Collector.Characteristics.IDENTITY_FINISH<span class="hljs-comment">//表示不需要变换,中间操作的结果就是最终结果</span><br>            ));<br>    System.out.println(collect);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">Accumulator: Person&#123;name=&#x27;Neo&#x27;, age=1, country=&#x27;USA&#x27;&#125;<br>Accumulator: Person&#123;name=&#x27;Blu&#x27;, age=13, country=&#x27;China&#x27;&#125;<br>Accumulator: Person&#123;name=&#x27;Alex&#x27;, age=29, country=&#x27;Germany&#x27;&#125;<br>Accumulator: Person&#123;name=&#x27;Bob&#x27;, age=25, country=&#x27;Germany&#x27;&#125;<br>Accumulator: Person&#123;name=&#x27;Kurumi&#x27;, age=18, country=&#x27;Japan&#x27;&#125;<br>[Person&#123;name=&#x27;Neo&#x27;, age=1, country=&#x27;USA&#x27;&#125;, Person&#123;name=&#x27;Blu&#x27;, age=13, country=&#x27;China&#x27;&#125;, Person&#123;name=&#x27;Alex&#x27;, age=29, country=&#x27;Germany&#x27;&#125;, Person&#123;name=&#x27;Bob&#x27;, age=25, country=&#x27;Germany&#x27;&#125;, Person&#123;name=&#x27;Kurumi&#x27;, age=18, country=&#x27;Japan&#x27;&#125;]<br><br></code></pre></td></tr></table></figure><p>（这一块没看太懂，先放到这里以后再来看）</p><h1 id="并行流">并行流</h1><p>Parallel Streams</p><p>能够借助<strong>多核处理器</strong>的<strong>并行计算能力</strong>加速数据处理,特别适合大型数据集或计算密集型任务.</p><h2 id="工作原理">工作原理</h2><ul><li>并行流在开始时, Spliterator分割迭代器将数据分割成多个片段,分割过程通常采用递归的方式动态进行, 以此平衡子任务的工作负载,提高资源利用率.</li><li>然后Fork/Join框架将这些数据片段分配到多个线程和处理器核心上进行并行处理.</li><li>处理完成后, 结果将会被汇总合并,其核心是[任务的分解Fork]和[结果的合并Join]</li><li>无论是并行流还是顺序流.二者都提供相同的中间操作和终端操作,也就是说我们可以采用几乎相同的方式进行数据处理和结果收集</li></ul><figure><img src="https://i.imgur.com/MMyKgBt.png" alt="并行流的工作原理" /><figcaption aria-hidden="true">并行流的工作原理</figcaption></figure><h2 id="foreach-foreachordered">forEach &amp; forEachOrdered</h2><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; Example = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>);<br>    Example.parallelStream()  <span class="hljs-comment">//并行流</span><br>            .map(String::toLowerCase)  <span class="hljs-comment">//转换为小写</span><br>            .forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印出的字母是乱序的, 而且每次都不一样.</p><p>不像顺序流的执行是单线程的, 并行流采用多线程并发处理,不保证元素的处理顺序.用<code>forEachOrdered</code>可以保证元素的出现顺序,这归功于Spliterator和Fork/Join框架的协作:</p><ul><li><p>在处理并行流时, 对于有序的数据源,Spliterator会对数据源进行递归分割, 通过划分数据源的索引范围来实现.每次分割都会产生一个新的Spliterator实例,其内部维护了指向原数据的索引范围,这种分割机制可以让数据的出现顺序得以保持.</p></li><li><p>然后, Fork/Join框架接手, 将分配后的数据块分配给不同的子任务执行.对于forEachOrdered操作,框架依据Spliterator维护的顺序信息来调度方法的执行顺序. 所以,就算某个子任务提前完成了, 如果跟它关联的顺序还没到来, 系统将缓存该顺序,并暂停执行该方法, 直到所有前序的任务都已经完成.</p></li><li><p>上述机制确保了即使是并行处理也能保证原始的出现顺序,代价是牺牲了一些并行执行的效率.</p></li><li><p>对于<code>forEach</code>,Fork/Join会<strong>忽略顺序的信息</strong>, 能够提高执行效率.</p></li><li><p>forEach会在不同的线程上独立进行, 所以如果操作的是共享资源,必须确保这些操作是<strong>线程安全</strong>的(同步).所以<code>forEach</code>更适合执行无状态操作或资源独立的场景.</p></li></ul><p>一个关于多线程的测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 并行流的多线程</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>     List&lt;String&gt; Example = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>);<br>     Example.parallelStream().forEach(item -&gt; &#123;<br>         <span class="hljs-comment">//打印正在处理的元素和对应的线程</span><br>         System.out.println(<span class="hljs-string">&quot;Item: &quot;</span> + item + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-string">&quot;Thread: &quot;</span> + Thread.currentThread().getName());<br>     &#125;);<br> &#125;<br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">Item: E-&gt;Thread: main<br>Item: D-&gt;Thread: main<br>Item: G-&gt;Thread: main<br>Item: A-&gt;Thread: main<br>Item: F-&gt;Thread: ForkJoinPool.commonPool-worker-2<br>Item: B-&gt;Thread: ForkJoinPool.commonPool-worker-1<br>Item: C-&gt;Thread: ForkJoinPool.commonPool-worker-2<br></code></pre></td></tr></table></figure><ul><li><code>main</code>:主线程</li><li><code>ForkJoinPool.commonPool-worker-x</code>:后台线程池中的工作线程</li></ul><h2 id="collect收集">collect收集</h2><p>List使用<code>collect</code><strong>收集</strong>输出结果,最终合并得到的列表仍为<strong>有序</strong>(与第一个demo不同)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * List并行流为有序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; collect = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>).parallelStream()<br>            .map(String::toLowerCase)     <span class="hljs-comment">//转换为小写</span><br>            .collect(Collectors.toList());<span class="hljs-comment">//收集不同线程的结果,合并为列表</span><br>    System.out.println();<br>    System.out.println(collect);<span class="hljs-comment">//输出为[a, b, c, d, e, f, g]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用<strong>自定义收集器</strong>演示有序列表<code>List</code>在并行流的情况下合并后仍有序输出的过程:</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; collect = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>).parallelStream()<br>            .map(String::toLowerCase)<br>            .collect(Collector.of(<br>                    () -&gt; &#123;<br>                        System.out.println(<span class="hljs-string">&quot;Supplier: new ArrayList&quot;</span> + <span class="hljs-string">&quot;Thread: &quot;</span> + Thread.currentThread().getName());<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    &#125;,<br>                    (list,item) -&gt; &#123;<br>                        System.out.println(<span class="hljs-string">&quot;Accumulator: &quot;</span> + item + <span class="hljs-string">&quot; Thread: &quot;</span> + Thread.currentThread().getName());<br>                        list.add(item);<br>                    &#125;,<br>                    (left, right) -&gt; &#123;<span class="hljs-comment">//并行流需要有效地合并不同线程的处理结果</span><br>                        System.out.println(<span class="hljs-string">&quot;Combiner: &quot;</span> + left + <span class="hljs-string">&quot; &quot;</span> + right + <span class="hljs-string">&quot; Thread: &quot;</span> + Thread.currentThread().getName());<br>                        left.addAll(right);<br>                        <span class="hljs-keyword">return</span> left;<br>                    &#125;,<br>                    Collector.Characteristics.IDENTITY_FINISH<br>            ));<br>    System.out.println(collect);<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>打印内容:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">Supplier: new ArrayListThread: main<br>Accumulator: c Thread: main<br>Supplier: new ArrayListThread: ForkJoinPool.commonPool-worker-1<br>Accumulator: b Thread: ForkJoinPool.commonPool-worker-1<br>Supplier: new ArrayListThread: ForkJoinPool.commonPool-worker-2<br>Supplier: new ArrayListThread: ForkJoinPool.commonPool-worker-1<br>Accumulator: e Thread: ForkJoinPool.commonPool-worker-2<br>Accumulator: d Thread: ForkJoinPool.commonPool-worker-1<br>Supplier: new ArrayListThread: main<br>Accumulator: a Thread: main<br>Combiner: [d] [e] Thread: ForkJoinPool.commonPool-worker-1<br>Combiner: [a] [b] Thread: main<br>Combiner: [c] [d, e] Thread: ForkJoinPool.commonPool-worker-1<br>Combiner: [a, b] [c, d, e] Thread: ForkJoinPool.commonPool-worker-1<br>[a, b, c, d, e]<br></code></pre></td></tr></table></figure><p>如果使用<code>Set</code>, 则结果仍然是无序的,这是由<strong>数据结构本身</strong>的特点决定的,Spliterator和Fork/Join框架的分割合并策略并没有什么不同.</p><h2 id="unordered-concurrent">UNORDERED &amp; CONCURRENT</h2><p><strong>UNORDERED</strong></p><p>即便Colector被标记为<code>UNORDERED</code>,如果数据源或流操作本身是有序的,系统的执行策略通常仍会保持这些元素的出现顺序.只有在特定场景下系统才会针对那些被标记为<code>UNORDERED</code>的流进行优化从而打破顺序的约束.</p><p><strong>CONCURRENT</strong></p><ul><li>在标准的并行流处理中, 每个线程处理数据的一个子集,维护自己的局部结果容器. 在所有的数据处理完成后,这些局部结果会通过Combiner函数合并成一个最终的结果.</li><li>使用CONCURRENT特性后, 所有线程将<strong>共享同一个结果容器</strong>,而不是维护独立的局部结果, 从而减少了合并的需要.这通常会带来性能上的提升, 特别是合并操作较为复杂时.这时只有一个结果容器,这个容器必须是线程安全的(例如ConcurrentHashMap).</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE-FILE类与IO流</title>
    <link href="/2025/04/13/java10/"/>
    <url>/2025/04/13/java10/</url>
    
    <content type="html"><![CDATA[<h1 id="file类的使用">File类的使用</h1><p><strong>位置</strong>：<code>package java.io</code></p><p><strong>构造器</strong>：</p><ul><li><code>public File(String pathname)</code><ul><li><code>pathname</code>可以用绝对路径或相对路径</li></ul></li><li><code>public File(String parent, String child)</code><ul><li><code>parent</code>:父路径名字符串，如果为null则等效于上一种构造器</li><li><code>child</code>:子路径名字符串，如果它是绝对路径则直接忽略父路径名</li><li>如果二者都是相对路径，则把<code>child</code>添加在<code>parent</code>的后面</li></ul></li><li><code>public File(File parent, String child)</code></li></ul><h2 id="方法">方法</h2><p>见<code>File.java</code>（快捷键：<code>Ctrl + N</code>查找类，<code>Ctrl + F12</code>查找当前文件中的方法）。</p><p>例：输出一个目录下的所有文件名（递归）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printFileName</span><span class="hljs-params">(File file)</span> &#123;<br>    <span class="hljs-keyword">if</span>(file.isFile()) &#123;<br>        System.out.println(file.getName());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>        File[] files = file.listFiles();<span class="hljs-comment">//listFiles()返回当前目录下的所有文件+文件夹</span><br>        <span class="hljs-keyword">for</span> (File f : files) &#123;<br>            printFileName(f);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="io流">IO流</h1><p>IO流就是Java中用来“<strong>读</strong>”和“<strong>写</strong>”数据的通道。</p><ul><li>按数据方向分<ul><li>输入流：读取数据到程序中</li><li>输出流：写数据到外部设备</li></ul></li><li>按数据类型分：<ul><li>字节流：以字节（8bit）为单位，如<code>InputStream</code>，<code>OutputStream</code></li><li>字符流：以字符（长度不定）为单位，如<code>Reader</code>，<code>Writer</code></li></ul></li></ul><p><strong>节点流</strong>是直接与 <strong>数据源</strong> 或<strong>数据目的地</strong> 打交道的流，常用于最底层的 I/O 操作。</p><p><strong>处理流</strong>是“套接”在已有的流（通常是节点流）上，对数据进行<strong>加工处理</strong> 的流。</p><p><strong>注意</strong>：字符流专门用于<strong>处理文本内容</strong>，字节流用于处理<strong>所有类型的数据</strong>（包括文本、图片、视频、音频等）。</p><p>核心类结构图：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CSS">  ┌────────────┐            ┌────────────┐<br>  │ InputStream│ &lt;-------- │ FileInputStream │<br>  └────────────┘            └────────────┘<br>        ▲<br>        │<br><span class="hljs-selector-attr">[处理字节输入]</span><br><br>  ┌────────────┐            ┌────────────┐<br>  │ OutputStream│ &lt;--------│ FileOutputStream│<br>  └────────────┘            └────────────┘<br>        ▲<br>        │<br><span class="hljs-selector-attr">[处理字节输出]</span><br><br>  ┌────────┐             ┌───────────┐<br>  │ Reader │ &lt;--------- │ FileReader │<br>  └────────┘             └───────────┘<br>        ▲<br><span class="hljs-selector-attr">[处理字符输入]</span><br><br>  ┌────────┐             ┌───────────┐<br>  │ Writer │ &lt;--------- │ FileWriter │<br>  └────────┘             └───────────┘<br>        ▲<br><span class="hljs-selector-attr">[处理字符输出]</span><br><br></code></pre></td></tr></table></figure><p>左列：抽象基类<br />右列：节点流（文件流），直接连接数据源和数据目的地。</p><h2 id="filereaderfilewriter">FileReader、FileWriter</h2><p>一般步骤：</p><ol type="1"><li>创建读取或写出的File类实例</li><li>创建输入流或输出流</li><li>具体的读或写的过程<ol type="1"><li>read(char[] cbuffer):int</li><li>write(char[] cbuffer, 0, len):void</li></ol></li><li>关闭流资源</li></ol><p>注意： 1. 处理异常 2. 对于输入流，File类的实例对应的文件必须已经存在3.对于输出流，可以不存在，会自动创建并写入数据到此文件中；如果文件已经存在，则<code>FileWriter(File file, true/false)</code></p><h2id="fileinputstreamfileoutputstream">FileInputStream、FileOutputStream</h2><ol type="1"><li>创建读取或写出的File类对象</li><li>创建输入流或输出流</li><li>具体的读入或写出过程，仍然是read和write</li><li>关闭流资源</li></ol><h2 id="缓冲流">缓冲流</h2><p>4个处理流：</p><ul><li>BufferedInputStream</li><li>BufferedOutputStream</li><li>BufferedReader</li><li>BufferedWriter</li></ul><p>缓冲流的作用：<strong>提升文件读写的效率</strong>。</p><p>直接使用<code>FileInputStream</code>读取文件时，每次 .read()都会和磁盘打交道，这样效率会非常低。而<strong>缓冲流会一次性从底层流中读取大量数据存入内存缓冲区，之后就从内存中读取，提高了效率</strong>。</p><blockquote><p>磁盘 I/O 是非常慢的，如果你每次都去磁盘读 1 字节，CPU会一直等，效率很低。而一次性读取一个 8KB缓冲区，可以极大减少磁盘读取次数，提高程序运行效率。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将一个文件复制到另一个地方</span><br><span class="hljs-comment">//实际写的时候记得用try-catch</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Neuro.png&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\edge_download\\Neuro.png&quot;</span>);<br><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dest);<br><br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-comment">//bis.read():</span><br>        <span class="hljs-comment">//如果8KB的缓冲区的数据还没读完：从缓冲区中读一个字节返回。</span><br>        <span class="hljs-comment">//如果已经读完了：就会调用底层的输入流（例如 FileInputStream）的 read(byte[] buffer) 方法；</span><br>        <span class="hljs-comment">// 一次性从磁盘中读很多字节（最多8KB），存入缓冲区；然后再从这个缓冲区中读一个字节返回过来。</span><br>        <span class="hljs-comment">//如果底层输入流返回 -1（即文件已经读完了），则 bis.read() 也返回 -1 表示 EOF。</span><br>        <span class="hljs-keyword">while</span>((len = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(len);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Done&quot;</span>);<br><br>        <span class="hljs-comment">//外层的流的关闭可以自动关闭内层的流</span><br>        bos.close();<br>        bis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BufferedInputStream</code><strong>原理</strong>：</p><ul><li>他有一个内部的<code>byte[]</code>缓冲区，默认大小8192字节</li><li>当调用<code>.read()</code>时，<strong>如果缓冲区有数据</strong>，就直接从缓冲区读；<strong>如果缓冲区空了</strong>，就从底层流中<strong>读取一大块</strong>（比如8192字节）放入缓冲区</li><li>类似地，<code>BufferedOutputStream</code>也是把数据先写入缓冲区，等缓冲区满了或调用<code>.flush()</code>时才真正写到文件。</li></ul><hr /><p>从文本文件读取文本到控制台（一次读一行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//一次性创建流+缓冲流</span><br>        br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file));<br>        String Line;<span class="hljs-comment">//一次读取一行，直到文件结束</span><br>        <span class="hljs-keyword">while</span>( (Line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(Line);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(br != <span class="hljs-literal">null</span>) br.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转换流">转换流</h2><p>转换流（ConversionStreams）是连接<strong>字节流</strong>和<strong>字符流</strong>之间的桥梁，它们的作用是：</p><blockquote><p>将“字节”转换成“字符”，或相反地将“字符”转换成“字节”。</p></blockquote><p>如果能够确认文件的编码格式与你的程序使用的编码一致，那确实可以不显式使用转换流（InputStreamReader/ OutputStreamWriter），直接用字符流 FileReader /FileWriter也是没问题的。</p><table><thead><tr><th>类名</th><th>方向</th><th>用途</th></tr></thead><tbody><tr><td>InputStreamReader</td><td>字节 → 字符</td><td>把字节输入流转换成字符输入流（读文件）</td></tr><tr><td>OutputStreamWriter</td><td>字符 → 字节</td><td>把字符输出流转换成字节输出流（写文件）</td></tr></tbody></table><p>举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将gbk格式的文件转换为utf-8格式的文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;GB18030.txt&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;GB18030_to_utf8.txt&quot;</span>);<br><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file1);<br>    <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis,<span class="hljs-string">&quot;GB18030&quot;</span>);<span class="hljs-comment">//使用gbk格式解码</span><br><br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file2);<br>    <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(fos,<span class="hljs-string">&quot;utf-8&quot;</span>);<span class="hljs-comment">//把解码得到的字符以utf8输出为字节</span><br><br>    <span class="hljs-comment">//读写过程</span><br>    <span class="hljs-type">char</span>[] cBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-keyword">while</span>((len = isr.read(cBuffer)) != -<span class="hljs-number">1</span>)&#123;<br>        osw.write(cBuffer,<span class="hljs-number">0</span>,len);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;OVER&quot;</span>);<br><br>    isr.close();<br>    osw.close();<span class="hljs-comment">//关闭缓冲流后，缓冲的数据才会被真正写入</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，<code>OutputStreamWriter</code><strong>也是带缓冲的流</strong>，只有当缓冲区满了或者调用<code>flush()</code>或者关闭流时，才会向硬盘中写入数据。<code>.write()</code>方法只是写到了它的缓冲区中，并不一定写到了磁盘中。<code>OutputStreamWriter.close()</code>方法会自动调用<code>flush()</code>方法，并且关闭底层的<code>FileOutputStream</code>。</p><p>但是<code>InputStreamReader</code><strong>本身不带缓冲区</strong>，它只是一个“编码解码器”，用来把字节流转换为字符流。<code>BufferedReader</code>才带有缓冲读取功能。如果要提高读取的效率，应该给转换流外面套上一层缓冲流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>英文字符不会出现乱码问题。</p><hr /><p><strong>在内存中的字符问题</strong>：内存中的长度与编程语言有关，Java的一个<code>char</code><strong>在内存中</strong>占用两个字节。在硬盘中占用多少字节取决于编码方式。</p><h2 id="对象流">对象流</h2><p>将内存中定义的变量保存在文件中。</p><p><code>ObjectInputStream</code>从字节流中中还原出对象</p><p><code>ObjectOutputStream</code>将对象转换成字节流</p><ul><li>ObjectOutputStream写入的内容<strong>不是纯文本格式</strong>，而是包含了<strong>Java序列化头信息 + 字符串内容</strong>的<strong>二进制数据</strong>。</li></ul><h3 id="对象的序列化过程">对象的序列化过程</h3><p>对象的<strong>序列化</strong>机制（ObjectSerialization）是指将对象转换成一连串字节的过程，以便：</p><ol type="1"><li>保存到磁盘（例如写入文件）；</li><li>通过网络传输；</li><li>缓存；</li><li>后续还原（反序列化）为原始对象。</li></ol><p>在内存中的对象不能直接写到硬盘或通过网络发送，必须先转成可传输的格式（字节流），这就是序列化的目的。</p><p><strong>反序列化</strong>：将字节流还原为对象</p><hr /><ul><li>序列化的对象的类必须实现接口。</li><li>要求自定义类声明一个全局常量<code>static final long serialVersionUID = xxxxxxL</code>用来唯一地标识当前的类;虽然系统会自动生成UID，但是因为容易变化所以不推荐。</li><li>要求自定义类的各个属性也是可以序列化的<ul><li>基本数据类型默认可序列化</li><li>引用数据类型也实现了接口Serializable</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>项</th><th>说明</th></tr></thead><tbody><tr><td><code>transient</code>关键字</td><td>修饰的字段不会被序列化</td></tr><tr><td>静态字段</td><td><code>static</code>修饰的变量不会被序列化（它属于类，不属于实例）</td></tr><tr><td>父类未实现<code>Serializable</code></td><td>则父类的字段不会被序列化</td></tr><tr><td><code>serialVersionUID</code></td><td>建议手动指定版本号，防止类结构变化导致反序列化失败</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合底层源码</title>
    <link href="/2025/04/12/java9/"/>
    <url>/2025/04/12/java9/</url>
    
    <content type="html"><![CDATA[<h1 id="arraylist">ArrayList</h1><p><code>ArrayList</code>是 Java中基于数组实现的一个可变长度的动态数组，它实现了<code>List</code>接口。位置：<code>java.util.ArrayList</code></p><p>Java 8及之后的版本：</p><p><strong>底层数据结构</strong>：</p><p>创建一个Object数组，默认为空数组（懒汉式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// 实际存储元素的数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;               <span class="hljs-comment">// 当前元素个数（不是数组长度）</span><br></code></pre></td></tr></table></figure><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">// 指定初始容量</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认构造函数用于扩容为默认大小10，<strong>只有第一次添加元素时才扩容</strong>。</li><li>带参的构造函数用于自己指定初始大小。</li></ul><p><strong>添加元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>); <span class="hljs-comment">// 确保容量足够</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>size</code>表示添加元素之前已有的元素数量，<code>size+1</code>即添加之后所需要的最小容量</li><li><code>ensureCapacityInternal</code>用于判断是否需要扩容，如果需要扩容，那么<code>elementData</code>扩容为<code>elementData = Arrays.copyOf(elementData, newCapacity);</code>，是原来的1.5倍，旧数组拷贝到新数组。</li></ul><p>扩容操作的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">//如果第一次添加的元素数量和默认长度10做对比，取较大的数</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-comment">//后续添加元素的时候使用下面这个判断</span><br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">//如果所需最小容量大于现有容量，则扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-comment">// 扩容逻辑</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 扩容1.5倍</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//1.5倍仍然不够用的话就直接取元素的长度</span><br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//极端情况特殊处理</span><br>        newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">//拷贝旧数组到原数组</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    Objects.checkIndex(index, size);<span class="hljs-comment">//检查index是否越界，抛出异常</span><br>    <span class="hljs-keyword">final</span> Object[] es = elementData;<span class="hljs-comment">//为了写法更短、性能稍微好一点</span><br><br>    <span class="hljs-comment">//忽略编译器的泛型转换警告，将es强转为泛型类型E</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> (E) es[index];<br>    fastRemove(es, index);<span class="hljs-comment">//将index+1及其后面的元素全部向前挪动一位，覆盖要删除的元素，最后一位记为null</span><br><br>    <span class="hljs-keyword">return</span> oldValue;<span class="hljs-comment">//返回oldvalue</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>E是泛型类型参数，用来表示<code>ArrayList</code>中存储的元素的类型。</li></ul><p><strong>ArrayList的查找和（尾部）添加元素效率高，删除和插入操作效率低</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(8)-泛型</title>
    <link href="/2025/04/12/java8/"/>
    <url>/2025/04/12/java8/</url>
    
    <content type="html"><![CDATA[<p>修改历史：</p><p>2025/4/12 初次发布</p><p>2025/4/22 补充静态泛型方法，完善了通配符部分的内容</p><h1 id="概述">概述</h1><p><strong>泛型</strong>（Generics）是Java提供的一种机制，<strong>让类、接口、方法在定义时可以指定类型参数</strong>，从而实现类型安全和代码复用。</p><p><code>HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</code></p><p><code>ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();</code></p><p><code>ArrayList&lt;Person&gt; personList = new ArrayList&lt;&gt;();</code></p><p>都是使用泛型的例子。</p><h1 id="静态泛型方法">静态泛型方法</h1><p>静态方法的泛型和普通方法的泛型的写法不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个泛型类，表示一对相同类型的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-comment">//构造器，传入两个相同类型的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T last)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-comment">//getter and setter</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; ... &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123; ... &#125;<br><br>    <span class="hljs-comment">// 静态泛型方法应该使用其他类型区分:K不同于T</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(K first, K last)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;K&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的泛型方法用得泛型参数是<code>K</code>，这是因为<strong>泛型类型参数T是在类实例化时才确定的，而静态方法属于类本身，不依赖于实例化，所以它无法访问实例相关的泛型类型</strong>。因此需要另外设一个泛型参数<code>K</code>，可以把这个<code>K</code>看成是静态方法自己专用的类型参数，和类的<code>T</code>没有任何关系，只是刚好做的事相似而已。</p><p>而且，可以注意到静态方法的泛型参数<code>K</code>在声明中出现了两次，这是因为普通方法的<code>T</code>在类的声明中已经出现过，编译器知道它是什么；但是静态方法使用的<code>K</code><strong>从未出现</strong>，所以需要事先声明。第二次出现的<code>K</code>就是正常的使用了。</p><p>静态泛型方法的这种写法在普通方法中也可能出现，比如下边这个：</p><p><img src="https://s21.ax1x.com/2025/04/21/pE5lfxI.png" /></p><p>这句方法声明是 Java Stream API中的<code>map</code>方法，用于将一个流中的每个元素「映射」成另一个类型，返回一个新的流。</p><p>因为这里出现<strong>另一个类型</strong>，为了表示这个类型，需要预先声明<code>&lt;R&gt;</code>才行。</p><p>所以说在方法名前面出现的泛型参数的作用其实就是<strong>声明新参数</strong>，需要新参数了就写一下，防止后面调用的时候编译器不认识它报错，这在普通方法和静态方法中是一致的。</p><h1 id="擦拭法type-erasure">擦拭法(Type Erasure)</h1><p>见https://liaoxuefeng.com/books/java/generics/type-erasure/index.html</p><blockquote><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。编译器内部永远把所有类型T 视为 Object 处理，但是，在需要转型的时候，编译器会根据 T的类型自动为我们实行<strong>安全地强制转型</strong>。</p></blockquote><p>在不使用泛型的时候，一般使用<code>instanceOf</code> +强制转型来处理不同传入参数的情况，泛型使用的其实还是这个逻辑，只不过包装了一下方便用户编写代码。</p><h1 id="通配符">通配符</h1><h2 id="概述-1">概述</h2><p><strong>Java泛型的类型是严格的类型检查</strong>，并不允许不同类型的泛型直接相互赋值。例如，<code>ArrayList&lt;Object&gt;</code>和<code>ArrayList&lt;String&gt;</code>是两种完全不同的泛型类型，即使String是Object的子类。</p><p>解决方法：</p><ol type="1"><li>使用通配符(Wildcard):</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用通配符?，表示可以接受任何类型</span><br>List&lt;?&gt; list = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//创建一个泛型string的list1</span><br>List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">//将list1传给list</span><br>list1.add(<span class="hljs-string">&quot;AA&quot;</span>);<br>list = list1;<br><br><span class="hljs-comment">//这时list成功获取了list1中的元素</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//读取使用Object</span><br>System.out.println(obj);<br><br><span class="hljs-comment">//但是list不能写入数据（因为不能确定到底该放哪个类型），除了null</span><br>list.add(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p><strong>上界通配符</strong>(Upper BoundsWildcards)：<code>List&lt;? extends T&gt; list</code>，list是某种<code>T</code>的子类的列表。这样传入的参数可以是T或者T的子类。<strong>可以读，不能写</strong>，因为编译器不知道list是哪个子类。<strong>读取安全但是写入不安全</strong></p><p><strong>下界通配符</strong>：<code>List&lt;? super T&gt; list</code>，list是<code>T</code>的某个父类的列表。方法参数接受所有泛型类型为T及其父类的类型。读出只能被视为为Object（因为不知道具体是哪个父类），可以写入T或其子类。写入安全但是读取受限</p><p>总之：</p><ul><li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li><li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li></ul><p>作为另一个例子，看看<code>Collections</code>工具类中的<code>copy</code>方法是怎么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span><br></code></pre></td></tr></table></figure><p>这个方法的作用是把src列表的元素复制到dest列表中。</p><p>可以看到，源列表的泛型是上界通配符，因为我们要获取源列表的每一个元素，使用上界通配符的话源列表的每一个元素都不可能比<code>T</code>的等级“高”，可以安全地利用向上转型原则通过<code>T</code>来get它们。</p><p>与之相反，dest目标列表使用的是super，因为我们要对目标列表进行写入操作，使用super可以保证目标列表中的每一个元素都不会比<code>T</code>等级低，这样只要set一个<code>T</code>类型的元素就可以保证成功向上转型。</p><h2 id="pecs原则">PECS原则</h2><p><strong>Producer Extends Consumer Super</strong></p><p>生产者（源）用<code>extends</code>，消费者（目标）用<code>super</code>，就是上边说过的东西</p><h2 id="无限定通配符">无限定通配符</h2><p><strong>Unbounded Wildcard Type</strong></p><p><code>&lt;?&gt;</code></p><p>既没有extends，也没有super，也就是说既不能读也不能写，可以用于逻辑判断。</p><p><code>&lt;?&gt;</code>是等级最高的存在，可以保证顺利向上转型，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>    Pair&lt;?&gt; p2 = p; <span class="hljs-comment">// 安全地向上转型</span><br>    System.out.println(p2.getFirst() + <span class="hljs-string">&quot;, &quot;</span> + p2.getLast());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(7)-集合框架</title>
    <link href="/2025/04/10/java7/"/>
    <url>/2025/04/10/java7/</url>
    
    <content type="html"><![CDATA[<p>修改历史：</p><ul><li>2025/04/10 初次发布</li><li>2025/04/30 重新树立了结构，增加常用方法总结</li><li>2025/05/03 增加“如何将列表转换成特定类型的数组”部分</li></ul><h1 id="collection">Collection</h1><p><strong>内存层面</strong>需要针对多个数据进行存储，可以考虑的<strong>容器</strong>有：数组、集合类。</p><p>数组初始化后的长度不可变，存储数据为单一类型，可包含重复元素，不适用于不可重复的场景；可用的属性和方法都极少；不便删除和插入元素。</p><p>Java中的集合框架（Java Collections Framework，简称JCF）是一个统一的架构，用于表示和操作一组对象。</p><p>Java集合框架体系：</p><ul><li><code>java.util.Collection</code>:存储一个一个的数据<ul><li>子接口：<strong>List</strong>，存储<strong>有序</strong>的、<strong>可重复</strong>的数据（动态数组）<ul><li><code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code></li></ul></li><li>子接口：<strong>Set</strong>，存储<strong>无序</strong>的、<strong>不可重复</strong>的数据（类似集合）<ul><li><code>HashSet</code>,<code>LinkedHashSet</code>,<code>TreeSet</code></li></ul></li></ul></li><li><code>java.util.Map</code>:存储一对一对的数据<ul><li><code>HashMap</code>,<code>LinkedHashMap</code>,<code>TreeMap</code>,<code>Hashtable</code>,<code>Properties</code></li></ul></li></ul><h1 id="list及其实现类">List及其实现类</h1><h2 id="增强for循环">增强for循环</h2><p><strong>作用</strong>：遍历数组，集合</p><p>集合：底层使用迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (集合或数组的类型 临时变量 : 集合或数组变量) &#123;<br>    操作临时变量的输出;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="list及其实现类的特点">List及其实现类的特点</h2><p>List存储有序的可重复的数据，动态数组，每增加一个对象容量就自动加一。</p><ul><li>ArrayList:List的<strong>主要实现类</strong>，底层使用Object[]数组存储，插入和删除数据时效率低</li><li>LinkedList:底层使用双向链表的方式存储，添加和查找数据时效率较低。适用于对集合中的数据进行频繁的删除和插入操作.</li><li>Vector: 古老，不用</li></ul><h3id="arraylist和普通数组的对比"><code>ArrayList</code>和普通数组的对比</h3><table><thead><tr><th>特性</th><th>ArrayList</th><th>普通数组 (Array[])</th></tr></thead><tbody><tr><td>长度</td><td>动态变化，可自动扩容</td><td>固定长度，创建后不可更改</td></tr><tr><td>添加元素</td><td>使用 <code>add()</code> 方法添加</td><td>需指定索引或使用循环添加</td></tr><tr><td>删除元素</td><td>使用 <code>remove()</code> 方法删除</td><td>不支持直接删除，需要移动元素</td></tr><tr><td>查找元素</td><td>使用 <code>get(index)</code> 获取元素</td><td>使用 <code>array[index]</code> 访问</td></tr><tr><td>是否支持泛型</td><td>支持，例如 <code>ArrayList&lt;Integer&gt;</code></td><td>不支持泛型</td></tr><tr><td>是否支持基本类型</td><td>不支持，只能存对象（可装箱）</td><td>支持基本类型和对象类型</td></tr><tr><td>是否线程安全</td><td>默认<strong>不是</strong>线程安全的</td><td>不是线程安全</td></tr><tr><td>使用场景</td><td>元素数量不确定、操作灵活</td><td>元素数量固定、结构简单</td></tr></tbody></table><hr /><h1id="collectionlistarraylist的对比">Collection、List、ArrayList的对比：</h1><table><thead><tr><th>特性</th><th>Collection</th><th>List</th><th>ArrayList</th></tr></thead><tbody><tr><td>类型</td><td>接口</td><td>接口（继承自 Collection）</td><td>类（实现了 List 接口）</td></tr><tr><td>是否可实例化</td><td>❌ 不能直接实例化</td><td>❌ 不能直接实例化</td><td>✅ 可以直接实例化</td></tr><tr><td>顺序性</td><td>❌ 不保证顺序（由子接口决定）</td><td>✅ 保证元素顺序</td><td>✅ 保证元素顺序</td></tr><tr><td>是否允许重复</td><td>❓ 由具体实现决定</td><td>✅ 允许重复元素</td><td>✅ 允许重复元素</td></tr><tr><td>随机访问效率</td><td>❌ 无此功能</td><td>✅ 有 <code>get(int)</code> 方法</td><td>✅ 快速随机访问（基于数组）</td></tr><tr><td>常见实现类</td><td>List、Set、Queue 等</td><td>ArrayList、LinkedList 等</td><td>自身是实现类</td></tr><tr><td>典型使用场景</td><td>操作所有集合的通用方法</td><td>操作有序集合（如列表）</td><td>频繁查询、随机访问</td></tr><tr><td>方法示例</td><td><code>add()</code>, <code>remove()</code>, <code>size()</code></td><td>加上 <code>get()</code>, <code>set()</code>,<code>indexOf()</code>等</td><td>同 List，同时还有优化的内部实现</td></tr></tbody></table><h1 id="set">Set</h1><h2 id="实现类">实现类</h2><p><code>Set</code>接口是<code>Collection</code>接口的子接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Set</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <br></code></pre></td></tr></table></figure><p>它存储<strong>无序的不可重复的数据</strong>。常用实现类：</p><ul><li><code>HashSet</code>:<strong>主要实现类</strong>，底层使用<code>HashMap</code>，即数组+单向链表+红黑树<ul><li><code>LinkedHashSet</code>:<code>HashSet</code>的子类；在现有的结构的基础上又添加了一组双向链表，用于记录添加元素的先后顺序，便于频繁的查询操作。</li></ul></li><li><code>TreeSet</code>:底层使用红黑树存储。可以按照添加元素的指定的属性大小顺序进行自动排序，从而进行有序遍历。<ul><li>底层：红黑树。可以按照指定的大小顺序自动排序。</li><li>要求TreeSet中的元素必须是<strong>同一个类型</strong>，否则类型转换错误。</li><li>处理对象比较方法，排序的标准就是自然排序或定制排序对应方法的返回值。如果是零则认为是相等，不添加新元素。</li><li>不需要重写<code>hashCode()</code>和<code>equals()</code>方法。</li></ul></li></ul><p><strong>常用方法</strong>：<code>Collection</code>中常用的方法，<strong>无新增方法</strong>。</p><p>主要作用：<strong>去除重复数据</strong>。</p><h2 id="重写两个方法">重写两个方法</h2><p>添加到HashSet/LinkedHashSet中的元素的要求：元素所在的类要重写两个方法：<code>equal()</code>和<code>hashCode()</code>。</p><p><code>hashmap</code>中依据<code>key</code>的<code>hash</code>值来确定<code>value</code>存储位置（hash值就是数组的索引），所以一定要重写<code>hashCode</code>方法；</p><p>而重写<code>equals</code>方法，是为了解决<code>hash</code>冲突：我们在重写<code>hashcode()</code>方法时已经尽量保证了哈希值不会重复，如果发现两个不同的<code>key</code>的<code>hash</code>值相同，那么就会调用<code>equals</code>方法，继续比较<code>key</code>值是否相同。</p><p>在存储时：如果<code>equals</code>结果相同，说明是同一个键，那么就覆盖更新<code>value</code>值；如果键不同，但是哈希值相同，就用<code>List</code>把他们都存储在同一个位置。在取出时：如果<code>equals</code>结果相同就直接返回当前<code>value</code>值，如果不同就遍历<code>List</code>中下一个元素。即要<code>key</code>与<code>hash</code><strong>同时匹配</strong>才会认为是同一个<code>key</code>。</p><p>JDK中用于判断是否是同一个key的源码:<code>if(e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))&#123;ops;&#125;</code></p><h1 id="map">Map</h1><h2 id="map及其实现类对比">Map及其实现类对比</h2><p><code>java.util.Map</code>:存储一对一对的<strong>键值对</strong>.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">               ┌──────────────┐<br>               │   Map接口    │<br>               └─────┬────────┘<br>                     │<br>        ┌────────────┴─────────────┐<br>        │                          │<br>  ┌─────▼─────┐              ┌─────▼─────┐<br>  │ HashMap   │              │ SortedMap │（接口）<br>  └─────┬─────┘              └─────┬─────┘<br>        │                          │<br>┌───────▼────────┐           ┌─────▼─────┐<br>│ LinkedHashMap  │           │ TreeMap   │<br>└────────────────┘           └───────────┘<br><br>┌──────────────┐<br>│ Hashtable    │（古老的线程安全实现）<br>└─────┬────────┘<br>      │<br>┌─────▼─────┐<br>│Properties │（子类，专用于配置文件）<br>└───────────┘<br></code></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>HashMap</th><th>LinkedHashMap</th><th>TreeMap</th><th>Hashtable</th><th>Properties</th></tr></thead><tbody><tr><td>所属接口</td><td>Map</td><td>Map</td><td>Map, SortedMap, NavigableMap</td><td>Map</td><td>Hashtable</td></tr><tr><td>是否线程安全</td><td>否</td><td>否</td><td>否</td><td>是</td><td>是</td></tr><tr><td>是否允许 null 键</td><td>是（最多一个）</td><td>是（最多一个）</td><td>否（键不能为 null）</td><td>否</td><td>否</td></tr><tr><td>是否有序</td><td>否</td><td>有插入顺序</td><td>有自然顺序或指定 Comparator</td><td>否</td><td>否</td></tr><tr><td>底层结构</td><td>哈希表</td><td>哈希表 + 双向链表</td><td>红黑树</td><td>哈希表</td><td>哈希表</td></tr><tr><td>性能</td><td>查询快，一般推荐</td><td>查询快，顺序操作性能略低</td><td>查询较慢，适合排序需求</td><td>查询快，但并发性能不佳</td><td>主要用于配置文件加载</td></tr><tr><td>用途</td><td>通用 Map 容器</td><td>保留插入顺序的 Map</td><td>需要排序的 Map</td><td>早期线程安全 Map，已过时</td><td>存储配置信息（key/value 字符串）</td></tr></tbody></table><h2 id="hashmap">HashMap</h2><p><code>HashSet</code>就是基于<code>HashMap</code>实现的。两者的对比如下：</p><table><thead><tr><th>特性</th><th><code>HashSet</code></th><th><code>HashMap</code></th></tr></thead><tbody><tr><td>存储结构</td><td>只存储元素（作为键）</td><td>存储键值对（key-value）</td></tr><tr><td>是否允许重复</td><td>❌ 不允许重复元素</td><td>✅ 键不允许重复，值可以重复</td></tr><tr><td>内部实现</td><td>基于 <code>HashMap</code> 实现</td><td>使用数组+链表（或红黑树）实现</td></tr><tr><td>查找效率</td><td>O(1)</td><td>O(1)</td></tr><tr><td>底层结构</td><td>实际是 <code>HashMap&lt;E, Object&gt;</code></td><td>实际是 <code>HashMap&lt;K, V&gt;</code></td></tr></tbody></table><p><code>HashSet</code>中只存储元素（值），而不是键值对。</p><p>为了实现这一点，它把元素作为<code>HashMap</code>的键，用一个统一的对象（比如<code>PRESENT</code>）作为值。</p><p>所以其实每次你往<code>HashSet</code>添加一个元素时，它是在底层的<code>HashMap</code>中添加了一条键值对：<code>map.put(element, PRESENT);</code></p><hr /><ul><li>HashMap中的key用Set来存放，无序而且不允许重复，所以同一个Map对象所对应的类<strong>需要重写hashCode和equals</strong>。</li><li>HashMap中的Value可重复、无序。<strong>不强制重写任何方法</strong>。</li><li>每一个键值对构成一个<strong>entry</strong>，所有的entry构成了一个Set集合</li></ul><h2 id="treemap">TreeMap</h2><ul><li>底层使用红黑树，按照<strong>key</strong>指定的大小顺序排序。</li><li>需要考虑使用对象排序</li><li>必须是<strong>同一个类型</strong>的对象</li></ul><h2 id="properties">Properties</h2><ul><li>Hashtable的子类</li><li>键和值都是String类型，用来处理属性文件</li></ul><h1 id="queue">Queue</h1><p>队列(Queue)实现了一个先进先出的有序表。Queue只有两个操作：</p><ul><li>把元素添加到末尾</li><li>从头部取出元素</li></ul><p>接口<code>Queue</code>定义了以下几个方法：</p><ul><li><code>size(): int</code>:返回队列中的元素的数量</li><li><code>add(E e)</code>:添加元素到队尾，添加失败的话抛出<code>IllegalStateException</code></li><li><code>offer(E e): boolean</code>:添加元素到队尾，添加失败返回<code>false</code>。<strong>更安全，推荐</strong></li><li><code>remove(): E</code>:获取并移除队首元素，如果队列为空则抛异常<code>NoSuchElementException</code></li><li><code>poll(): E</code>:获取并移除队首元素，如果为空返回<code>null</code>。<strong>更安全，推荐</strong></li><li><code>element(): E</code>:获取但不移除队首元素，队列为空抛异常<code>NoSuchElementException</code></li><li><code>peek(): E</code>:获取但不移除队首元素，队列为空返回<code>null</code>。<strong>更安全，推荐</strong></li></ul><h2 id="linkedlist">LinkedList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable<br></code></pre></td></tr></table></figure><p><code>LinkedList</code>是最常用的实现类，底层使用双向链表的方式存储，添加和查找数据时效率较低。适用于对集合中的数据进行频繁的删除和插入操作。</p><p>注意<code>LinkedList</code>同时实现了<code>Queue</code>和<code>List</code>接口，使用时该用哪个用哪个。</p><h2 id="priorityqueue">PriorityQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable<br></code></pre></td></tr></table></figure><p>一个优先队列，元素的顺序按照<strong>优先级的大小</strong>排列，它并不遵循严格的先进先出。所谓优先级的大小，指的是它会根据提供的比较器对队列中的元素进行排序，或者使用自然排序（空构造器的情况）。</p><p>声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;E&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>上面的声明使用了空的构造器，这种情况下队列中的元素按照<strong>自然排序</strong>。也可以使用一个lambda表达式重写比较方法实现定制排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br><br>    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; b - a);<br><br>    pq.offer(<span class="hljs-number">5</span>);<br>    pq.offer(<span class="hljs-number">1</span>);<br>    pq.offer(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>        System.out.println(pq.poll());  <span class="hljs-comment">// 输出顺序：5, 3, 1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="deque">Deque</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deque</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;, SequencedCollection&lt;E&gt;<br></code></pre></td></tr></table></figure><div class="note note-secondary">            <p><code>Deque</code>是一个支持在队列两端插入和删除操作的线性集合。它的名字"deque"是"doubleendedqueue"（双端队列）的简称。大部分<code>Deque</code>的实现对包含的元素的数量没有固定限制，但是这个接口也支持有容量限制的队列和无限容量队列。</p>          </div><h3 id="实现类-1">实现类</h3><table><thead><tr><th>实现类名称</th><th>说明</th></tr></thead><tbody><tr><td><code>ArrayDeque</code></td><td>常用，基于数组，效率高，适合栈/队列操作</td></tr><tr><td><code>LinkedList</code></td><td>也实现了 <code>Deque</code>，但效率略低</td></tr><tr><td><code>LinkedBlockingDeque</code></td><td>线程安全，可设置容量限制（在并发场景使用）</td></tr></tbody></table><p>这里又出现了<code>LinkedList</code>。所以说使用<code>LinkedList</code>的时候最好使用它的接口来引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不推荐的写法:</span><br>LinkedList&lt;String&gt; d1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>d1.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br><span class="hljs-comment">// 推荐的写法：</span><br>Deque&lt;String&gt; d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>d2.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="方法">方法</h3><p><strong>添加元素的方法</strong>：</p><table><thead><tr><th>方法名</th><th>功能</th><th>抛异常版本</th><th>安全返回版本</th></tr></thead><tbody><tr><td><code>addFirst(e)</code></td><td>添加到队头（栈顶）</td><td>✅</td><td>❌（无）</td></tr><tr><td><code>offerFirst(e)</code></td><td>添加到队头（栈顶）</td><td>❌</td><td>✅</td></tr><tr><td><code>addLast(e)</code></td><td>添加到队尾（队列尾部）</td><td>✅</td><td>❌（无）</td></tr><tr><td><code>offerLast(e)</code></td><td>添加到队尾（队列尾部）</td><td>❌</td><td>✅</td></tr><tr><td><code>add(e)</code></td><td>默认添加到队尾（等同 <code>addLast</code>）</td><td>✅</td><td>❌</td></tr><tr><td><code>offer(e)</code></td><td>默认添加到队尾（等同 <code>offerLast</code>）</td><td>❌</td><td>✅</td></tr><tr><td><code>push(e)</code></td><td><strong>栈操作</strong>，添加到头部（等同<code>addFirst</code>）</td><td>✅</td><td>❌</td></tr></tbody></table><p><strong>删除元素的方法</strong></p><table><thead><tr><th>方法名</th><th>功能</th><th>抛异常版本</th><th>安全返回版本</th></tr></thead><tbody><tr><td><code>removeFirst()</code></td><td>删除并返回队头元素</td><td>✅</td><td>❌</td></tr><tr><td><code>pollFirst()</code></td><td>删除并返回队头元素</td><td>❌</td><td>✅</td></tr><tr><td><code>removeLast()</code></td><td>删除并返回队尾元素</td><td>✅</td><td>❌</td></tr><tr><td><code>pollLast()</code></td><td>删除并返回队尾元素</td><td>❌</td><td>✅</td></tr><tr><td><code>remove()</code></td><td>默认删除队头（等同 <code>removeFirst</code>）</td><td>✅</td><td>❌</td></tr><tr><td><code>poll()</code></td><td>默认删除队头（等同 <code>pollFirst</code>）</td><td>❌</td><td>✅</td></tr><tr><td><code>pop()</code></td><td><strong>栈操作</strong>，删除头部（等同<code>removeFirst</code>）</td><td>✅</td><td>❌</td></tr></tbody></table><p><strong>查看元素的方法</strong></p><table><thead><tr><th>方法名</th><th>功能</th><th>抛异常版本</th><th>安全返回版本</th></tr></thead><tbody><tr><td><code>getFirst()</code></td><td>获取队头元素</td><td>✅</td><td>❌</td></tr><tr><td><code>peekFirst()</code></td><td>获取队头元素</td><td>❌</td><td>✅</td></tr><tr><td><code>getLast()</code></td><td>获取队尾元素</td><td>✅</td><td>❌</td></tr><tr><td><code>peekLast()</code></td><td>获取队尾元素</td><td>❌</td><td>✅</td></tr><tr><td><code>element()</code></td><td>默认获取队头（等同 <code>getFirst</code>）</td><td>✅</td><td>❌</td></tr><tr><td><code>peek()</code></td><td>默认获取队头（等同 <code>peekFirst</code>）</td><td>❌</td><td>✅</td></tr></tbody></table><p><strong>其他方法</strong></p><table><thead><tr><th>方法名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>isEmpty()</code></td><td>判断队列是否为空</td></tr><tr><td><code>size()</code></td><td>返回当前元素数量</td></tr><tr><td><code>contains(Object)</code></td><td>判断队列中是否包含指定元素</td></tr><tr><td><code>clear()</code></td><td>清空所有元素</td></tr><tr><td><code>iterator()</code></td><td>从头到尾遍历</td></tr><tr><td><code>descendingIterator()</code></td><td>从尾到头遍历</td></tr></tbody></table><h2 id="stack">Stack</h2><p>Stack(栈)的特点：后进先出，相当于把队列的一端堵死，只留一个出口。</p><p>使用Deque可以实现后进先出的栈操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    Deque&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// push “压入” 栈操作添加到头部</span><br>    stack.push(<span class="hljs-string">&quot;A&quot;</span>);<br>    stack.push(<span class="hljs-string">&quot;B&quot;</span>);<br>    stack.push(<span class="hljs-string">&quot;C&quot;</span>);<br><br>    <span class="hljs-comment">// pop “弹出” 栈操作删除头部</span><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        System.out.println(stack.pop()); <span class="hljs-comment">// 输出顺序：C B A</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当我们把Deque作为Stack使用时，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，不要调用<code>addFirst()</code>/<code>removeFirst()</code>/<code>peekFirst()</code>方法，这样代码更加清晰。</p><h1 id="iterator">Iterator</h1><p>Iterator,获取迭代器的对象：<code>Iterator itr = 集合.iterator();</code></p><p>遍历集合的所有元素：<code>itr.hasNext()</code>+<code>itr.next()</code></p><figure><img src="https://i.imgur.com/uRaHFI0.png" alt="迭代器图解" /><figcaption aria-hidden="true">迭代器图解</figcaption></figure><p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种<strong>集合</strong>类型，而不必关心它们内部的存储结构。</p><h1 id="集合框架常用方法总结">集合框架常用方法总结</h1><h2 id="collection接口">Collection接口</h2><p><code>Collection</code>接口作为集合框架最上层的接口，所有的集合数据类型都可以使用其中定义的方法。如下：</p><table><thead><tr><th>方法签名</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>向集合中添加一个元素</td></tr><tr><td><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td><td>将指定集合中的所有元素添加进来</td></tr><tr><td><code>void clear()</code></td><td>清空集合中所有元素</td></tr><tr><td><code>boolean contains(Object o)</code></td><td>判断集合中是否包含某个元素</td></tr><tr><td><code>boolean containsAll(Collection&lt;?&gt; c)</code></td><td>判断集合是否包含另一个集合中的所有元素</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断集合是否为空</td></tr><tr><td><code>Iterator&lt;E&gt; iterator()</code></td><td>返回一个迭代器，用于遍历集合元素</td></tr><tr><td><code>boolean remove(Object o)</code></td><td>删除集合中首次出现的指定元素</td></tr><tr><td><code>boolean removeAll(Collection&lt;?&gt; c)</code></td><td>删除集合中与指定集合中相同的所有元素</td></tr><tr><td><code>boolean retainAll(Collection&lt;?&gt; c)</code></td><td>仅保留集合中也包含在指定集合中的元素（交集）</td></tr><tr><td><code>int size()</code></td><td>返回集合中元素的数量</td></tr><tr><td><code>Object[] toArray()</code></td><td>返回一个包含集合中所有元素的数组</td></tr><tr><td><code>&lt;T&gt; T[] toArray(T[] a)</code></td><td>返回一个包含集合中所有元素的指定类型数组</td></tr></tbody></table><h2 id="list接口">List接口</h2><p><img src="https://s21.ax1x.com/2025/04/30/pEHswkT.png" /></p><p><code>List</code>作为一个接口，也是Collection的子接口。<code>Collection</code>定义的所有方法都可以继续使用，除此之外还有一些特有的方法：</p><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td><code>void add(int index, E element)</code></td><td>在指定索引插入元素</td></tr><tr><td><code>E get(int index)</code></td><td>获取指定索引的元素</td></tr><tr><td><code>E set(int index, E element)</code></td><td>替换指定索引位置的元素</td></tr><tr><td><code>E remove(int index)</code></td><td>删除指定索引处的元素</td></tr><tr><td><code>int indexOf(Object o)</code></td><td>返回元素首次出现的索引</td></tr><tr><td><code>int lastIndexOf(Object o)</code></td><td>返回元素最后一次出现的索引</td></tr><tr><td><code>ListIterator&lt;E&gt; listIterator()</code></td><td>获取支持双向遍历的迭代器</td></tr><tr><td><code>ListIterator&lt;E&gt; listIterator(int index)</code></td><td>从指定索引开始的 ListIterator</td></tr><tr><td><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code></td><td>获取子列表 <code>[from, to)</code></td></tr></tbody></table><h2 id="set接口">Set接口</h2><p><code>Set</code>接口也是<code>Collection</code>的子接口,但是它<strong>没有额外定义新的方法</strong>。</p><p><img src="https://s21.ax1x.com/2025/04/30/pEHsNmq.png" /></p><h2 id="map接口">Map接口</h2><p><code>Map</code>专门用于存储键值对，它与<code>Collection</code>接口无直接关联，常用方法如下：</p><table><thead><tr><th>方法签名</th><th>描述</th></tr></thead><tbody><tr><td><code>V put(K key, V value)</code></td><td>将指定的键值对插入到 Map 中（若键已存在则更新值，返回旧值）</td></tr><tr><td><code>V get(Object key)</code></td><td>根据键获取对应的值</td></tr><tr><td><code>V remove(Object key)</code></td><td>根据键移除键值对，返回被删除的值</td></tr><tr><td><code>boolean containsKey(Object key)</code></td><td>判断是否包含指定键</td></tr><tr><td><code>boolean containsValue(Object value)</code></td><td>判断是否包含指定值</td></tr><tr><td><code>int size()</code></td><td>返回键值对数量</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断 Map 是否为空</td></tr><tr><td><code>void clear()</code></td><td>清空 Map 中所有内容</td></tr><tr><td><code>Set&lt;K&gt; keySet()</code></td><td>返回所有键的集合</td></tr><tr><td><code>Collection&lt;V&gt; values()</code></td><td>返回所有值的集合</td></tr><tr><td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td><td>返回所有键值对的集合（每个 Entry 是一个键值对）</td></tr><tr><td><code>V putIfAbsent(K key, V value)</code></td><td>如果键不存在，则插入键值对（JDK 1.8+）</td></tr></tbody></table><h1id="如何将列表转换成特定类型的数组">如何将列表转换成特定类型的数组</h1><h2 id="引入">引入</h2><p>先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ListNode&gt; TempList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>...<br>ListNode[] lists = TempList.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p><code>lists</code>是一个用于存放<code>ListNode</code>数据的数组，<code>Templist</code>是一个存放<code>ListNode</code>元素的列表。最后一行代码实现了从<code>TempList</code>列表向数组的转化。这里的关键是<code>toArray</code>方法，实际上<code>List</code>接口中定义了两个<code>toArray</code>抽象方法，一个空参一个有参，定义分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] toArray();<br>&lt;T&gt; T[] toArray(T[] a);<br></code></pre></td></tr></table></figure><p>为了搞清楚这两个方法如何使用，需要先介绍一下<code>runtime type</code>（运行时类型）和<code>compile type</code>（编译时类型）。</p><h2 id="编译时类型和运行时类型">编译时类型和运行时类型</h2><p>运行时类型，指的是对象在程序运行的过程中真实的类型。之所以强调“真实”，是因为Java中的多态使得编译器认为的类型和程序运行时的类型可能不一样，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br></code></pre></td></tr></table></figure><p>所谓<em>编译看左边，运行看右边</em>，<code>a</code>的编译时类型是<code>Animal</code>，运行时类型是<code>Dog</code>。</p><h2 id="java标准库提供的注释">Java标准库提供的注释</h2><p>先看空参方法<code>Object[] toArray();</code>：</p><blockquote><p>按照正确的顺序（从第一个到最后一个）返回一个包含原列表中所有元素的数组。</p><p>返回的数组是“安全的”，意思就是说它不包含任何对原列表的引用，是完全独立于原列表的。你可以放心地修改它，不用担心会对原列表产生任何影响。</p><p>这个方法是基于数组的 API 和基于集合的 API 之间的桥梁。</p></blockquote><p><code>返回值</code>:一个以正确的顺序包含列表中的所有元素的<code>Object</code>数组</p><p>这个方法的返回值类型固定为<code>Object[]</code>，在实际应用中需要手动强转成我们需要的类型，很不方便。于是就有了后面这个带参数的方法</p><hr /><p><code>&lt;T&gt; T[] toArray(T[] a);</code></p><blockquote><p>照正确的顺序（从第一个到最后一个）返回一个包含原列表中所有元素的数组。返回数组的运行时类型与指定数组相同。如果该列表可以装入指定的数组中，则直接把它放进数组并返回；否则，会分配一个具有与指定数组相同运行时类型的新数组，其大小等于列表的大小。</p><p>如果指定的数组比原列表需要的空间还大，那么空缺位置会被赋值为<code>null</code>。（<em>仅当</em>调用者确认原列表中不包含任何<code>null</code>元素时，这个特性才有助于判断列表的长度）</p><p>就像<code>toArray()</code>方法一样，该方法是基于数组的 API和基于集合的 API之间的桥梁。此外，该方法允许对输出数组的运行时类型进行精确的控制，在某些情况下或许可以节省内存开销。</p><p>假设<code>x</code>是一个已知只包含字符串的列表。以下代码可以用于将列表转存到新分配的String数组中：</p><p><code>String[] y = x.toArray(new String[0]);</code></p><p>注意<code>toArray(new Object[0])</code>与上面的<code>toArray()</code>完全相同。</p></blockquote><p><code>参数</code>: <code>a</code>-指定数组，如果足够大，原列表的元素将被直接存入该数组；否则，会分配一个与之相同运行类型的新数组。</p><p><code>返回值</code>: 一个包含列表元素的数组</p><p><code>抛出</code>: <code>ArrayStoreException</code> -如果指定数组的运行时类型不是每一个列表元素的父类型<br /><code>NullPointerException</code> - 如果指定数组是<code>null</code></p><hr /><p>Java标准库中给出的解释已经非常详细了。对于开头处的语句<code>ListNode[] lists = TempList.toArray(new ListNode[0]);</code>，形参<code>new ListNode[0]</code>的主要作用是<strong>确定返回数组的运行时类型</strong>，它作为我们给出的指定数组，其容量为0，显然是不够用的，所以会分配一个运行时类型为<code>ListNode[]</code>的新数组，其容量等于列表的大小。然后，把返回的数组赋给相同类型的数组<code>lists</code>就没有任何问题了。</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>サマータイムレコード じん　歌詞</title>
    <link href="/2025/04/08/summertimerecord/"/>
    <url>/2025/04/08/summertimerecord/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>これぞ夏</p><p>作詞/作曲/編曲/Guitar：じん</p><p>昨日も今日も晴天で<br />入道雲を見ていた</p><p>怠いくらいの快晴だ<br />徐々に目を閉じて</p><p>「それ」はどうも簡単に<br />思い出せやしない様で</p><p>年を取った現状に<br />浸ってたんだよ</p><p>大人ぶった作戦で<br />不思議な合図立てて</p><p>「行こうか、今日も戦争だ」<br />立ち向かって　手を取った</p><p>理不尽なんて当然で<br />一人ぼっち　強いられて</p><p>迷った僕は<br />憂鬱になりそうになってさ</p><p>背高草を分けて<br />滲む太陽睨んで</p><p>君はさ、こう言ったんだ<br />「孤独だから、おいでよ」</p><p>騒がしさがノックして<br />生まれた　感情さえも</p><p>頭に浮かんでは萎んだ</p><p>「幻なのかな？」</p><p>秘密基地に集まって<br />「楽しいね」って単純に</p><p>あの頃を思い出して<br />話をしよう</p><p>飛行機雲飛んで行って<br />「眩しいね」って泣いていた</p><p>君はどんな顔だっけ</p><p>なぜだろう</p><p>思い出せないな</p><hr /><p>痛いくらいに現実は　足早に駆け抜けた</p><p>選んだ今日は平凡で　崩れそうになる日々さ</p><p>昨日も今日も延長戦　大人だって　臆病だ</p><p>今になってなんとなく　気付けたみたいだよ</p><p>廻るセカイのイデア　枯れる太陽　炎天下</p><p>陽炎が揺らいだ　「忘れないで、さぁ、進もう」</p><p>もどかしさ何度でも　明日を夢に見ていた</p><p>戻らない、先のある世界へ　「僕たちで変えよう」 　「思い出して、終わたって　秘密基地も、冒険も」</p><p>あの日に迷い込んだ　話の事も</p><p>一人ぼっちが集まった　子供たちの作戦が　また今日も廻り出した</p><p>「また、何処かで。」</p><p>「涼しいね」って言い合った　夏空は透明だ</p><p>泣かない様に、吸い込んで　「さようなら」しよう</p><p>秘密基地に集まって　笑い合った夏の日に</p><p>「また何処かで思い出して　出逢えるかな」って</p><p>何度でも　描こう</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(6)常用类与基础API</title>
    <link href="/2025/04/08/java6/"/>
    <url>/2025/04/08/java6/</url>
    
    <content type="html"><![CDATA[<h1 id="string">String</h1><p>特性：不可变，创建后不能改变内容，任何修改其实是创建了新对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>String s1 = "hello";</code>使用<strong>字面量</strong>，在常量池里创建一个对象。如果有同样的字面量，会复用，效率更高</p><p><code>String s2 = new String("hello");</code>使用new在堆内存里创建一个对象，</p><p><code>s1==s2</code>判断为<code>false</code>,<code>s1.equals(s2)</code>判断为<code>true</code></p><h2 id="string的连接操作">String的连接操作</h2><p>常量+常量 = 常量池中的常量</p><p>常量+变量 = 堆空间中该字符串对象的地址</p><p><code>intern()</code>返回字符串常量池中对应的地址。</p><p><code>concat()</code>必然返回一个新对象</p><h2 id="常用方法">常用方法</h2><p><code>getBytes()</code>：将字符串转换成字节数组，储存的数字与编码有关，需要指定编码方式使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bytes = str.getBytes(StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure><p>utf-8或gbk都向下兼容ascii。</p><p><strong>解码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, 字符集名称);<br></code></pre></td></tr></table></figure><hr /><p><code>indexOf</code>:查找某个字符或子字符串在字符串中<strong>第一次</strong>出现的位置。没有找到则返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(String s);<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-type">char</span> ch);<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(String s, <span class="hljs-type">int</span> fromIndex);<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-type">char</span> ch, <span class="hljs-type">int</span> fromIndex);<br></code></pre></td></tr></table></figure><p>记录某个字符串在另一个字符串中出现的次数：（复杂度大）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">getSubStringCount</span><span class="hljs-params">(String str,String subStr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> str.indexOf(subStr);<span class="hljs-comment">//第一次出现的索引</span><br><br>    <span class="hljs-keyword">while</span>(index != -<span class="hljs-number">1</span>) &#123;<br>        count++;<br>        index = str.indexOf(subStr, index+subStr.length());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="stringstringbufferstringbuilder">String,StringBuffer,StringBuilder</h2><p>String:不可变的字符序列；</p><p>StringBuffer:可变的字符序列；线程安全，效率低</p><p>StringBuilder:可变的字符序列；线程不安全，效率高</p><p>以上三者底层均为byte[].</p><p>增:append</p><p>删:delete(int start, int end)<br />deleteCharAt(int index)</p><p>改:replace(int start, int end, String str) setCharAt(int index, charc)</p><p>查:charAt(inr index)</p><p>插:insert(int index, xx)</p><p>长度:length()</p><h1 id="日期时间api">日期时间API</h1><p>旧API</p><ol type="1"><li>currentTimeMillis():与1970.1.1日0时0分0秒之间的毫秒数</li><li>Date()类</li><li>Calendar抽象类</li></ol><p><strong>新API</strong>：</p><p>最常用的API：</p><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td><code>LocalDate</code></td><td>表示日期（如：2025-04-09），不含时间和时区</td></tr><tr><td><code>LocalTime</code></td><td>表示时间（如：12:30:45），不含日期和时区</td></tr><tr><td><code>LocalDateTime</code></td><td>表示日期和时间（如：2025-04-09T12:30:45），不含时区</td></tr><tr><td><code>ZonedDateTime</code></td><td>表示带时区的日期和时间（如：2025-04-09T12:30:45+09:00[Asia/Tokyo]）</td></tr><tr><td><code>Instant</code></td><td>表示时间戳，精确到纳秒（从1970-01-01T00:00:00Z开始）（重写为ISO-8601标准的字符串）</td></tr><tr><td><code>Duration</code></td><td>表示两个时间之间的间隔（单位：秒、纳秒）</td></tr><tr><td><code>Period</code></td><td>表示两个日期之间的间隔（单位：年、月、日）</td></tr><tr><td><code>DateTimeFormatter</code></td><td>用于格式化和解析日期时间</td></tr></tbody></table><h1 id="自定义类的对象的排序">自定义类的对象的排序</h1><h2 id="自然排序实现comparable接口">1.自然排序：实现Comparable接口</h2><ol type="1"><li>定义一个类实现<code>Comparable</code>接口这个泛型接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回负数: 当前实例比参数o小</span><br><span class="hljs-comment">     * 返回0: 当前实例与参数o相等</span><br><span class="hljs-comment">     * 返回正数: 当前实例比参数o大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>实现<code>public int compareTo(T o);</code>方法，指明比较的标准</li><li>创建实例，调用<code>Arrays.sort</code>或<code>compareTo</code>比较大小。</li></ol><p>实现compareTo方法之后，<code>Arrays.sort(arr)</code>的比较标准也会改变。</p><blockquote><p><code>Arrays.sort()</code> 会自动使用元素类中定义的<code>compareTo()</code>方法，所以当你重写了这个方法，排序逻辑自然也随之改变了。</p></blockquote><p>实例：让Person对象按照名字排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sort</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person[] ps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>[] &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">61</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">75</span>),<br>        &#125;;<br>        Arrays.sort(ps);<br>        System.out.println(Arrays.toString(ps));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Person&gt; &#123;<br>    String name;<br>    <span class="hljs-type">int</span> score;<br>    Person(String name, <span class="hljs-type">int</span> score) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-comment">//实现 compareTo 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person other)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(other.name);<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">this</span>.score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定制排序">2.定制排序</h2><p>适用情况：</p><ul><li>元素类型没有实现Comparable接口，而且不方便修改代码</li><li>实现了接口，但是以后不想用这个比较方法，又不能影响已有的使用</li></ul><ol type="1"><li>创建一个实现Comparator接口的实现类A</li><li>类A要重写compare方法</li><li>创建实现类A的实例，并传入<code>Arrays.sort(arr,类A的实例)</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>もうじき夏が終わるから n-buna &amp;初音ミク　歌詞</title>
    <link href="/2025/04/07/%E3%82%82%E3%81%86%E3%81%98%E3%81%8D%E5%A4%8F%E3%81%8C%E7%B5%82%E3%82%8F%E3%82%8B%E3%81%8B%E3%82%89/"/>
    <url>/2025/04/07/%E3%82%82%E3%81%86%E3%81%98%E3%81%8D%E5%A4%8F%E3%81%8C%E7%B5%82%E3%82%8F%E3%82%8B%E3%81%8B%E3%82%89/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>もうじき夏が終わるから</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><p>朝　小説を読んだ</p><p>君を待っていた</p><p>夜になって気が付いた</p><p>花火の音</p><p>花揺ら歌い今日藍を飛ばせ</p><p>貴方に聞こえないように消えて</p><p>それを言えない僕じゃ言えないよ</p><p>今に夏が終わってくから</p><p><ruby>昼顔<rt>ひるがお</rt></ruby>　鳥居　<ruby>鳳仙花<rt>ほうせんか</rt></ruby>　バス停</p><p>陽の落ちる街を歩いていた</p><p>今日もまた</p><p>朝　ラジオを聞いた君を待っていた</p><p>夜になって気が付いたことを覚えている</p><p>昨日もピアノを弾いた</p><p>朝を待っている</p><p>唄を歌っている</p><p>花詩　誓い　今日藍を飛ばせ</p><p>貴方に聞こえないように叫べ</p><p>夢を見れない僕花咲いた</p><p>終わる夏よ止まってしまえ</p><p>アベリア　始発　終電車　<ruby>緑青<rt>ろくしょう</rt></ruby></p><p>蝉の鳴く街を歩いていた</p><p>今日もまた</p><p>朝、今日も駅の裏</p><p>人が立っていた</p><p>夜の藍に花が咲く</p><p>絵をえがいていた</p><p>帰ってピアノを弾いた</p><p>夜になっていた</p><p>君を待っていた</p><p>花詩　誓い　明日藍を飛ばせ</p><p>貴方が居たくない今日を叫べ</p><p>夢が言えないことに気がついた</p><p>浅い夏よ　終わってくれよ</p><p><ruby>昼顔<rt>ひるがお</rt></ruby>　鳥居　<ruby>鳳仙花<rt>ほうせんか</rt></ruby>　バス停</p><p>夜が明けた街を歩いていた</p><p>今日もまた</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(5)异常处理&amp;多线程</title>
    <link href="/2025/04/06/java5/"/>
    <url>/2025/04/06/java5/</url>
    
    <content type="html"><![CDATA[<h1 id="异常">异常</h1><p>指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止。</p><p>一旦发生某种异常Java就创建该异常类型的对象，并且抛出(throw)。</p><p><strong>Error</strong>:java虚拟机无法处理的严重问题，一般不编写针对性的代码。例如：栈内存溢出，堆内存溢出。</p><p><strong>Exception</strong>:异常处理的情况，需要针对性的代码进行处理。</p><ul><li>编译时异常</li><li>运行时异常</li></ul><p>常见的运行时异常：角标越界异常 空指针异常 类别异常 输入类型不匹配异常数字格式化异常</p><p>编译时异常：<code>ClassNotFoundException</code><code>FileNotFoundException</code> <code>IOException</code></p><h2 id="处理异常的方式">处理异常的方式</h2><h3 id="try-catch-finally">1.try-catch-finally</h3><ol type="1"><li>程序在执行的过程中，一旦出现异常，就创建该异常类的对象并抛出，然后虚拟机就终止程序。</li><li>捕获异常对象，进行相应的处理，处理后可以继续执行代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能会抛出异常的代码</span><br>    <span class="hljs-comment">//try中声明的变量作用域只在try内部</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType1 e1) &#123;<br>    <span class="hljs-comment">// 异常类型1的处理代码</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType2 e2) &#123;<br>    <span class="hljs-comment">// 异常类型2的处理代码</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 可选的代码，无论是否发生异常都会执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>catch</code>中异常处理的方式：</p><ol type="1"><li>自己编写输出语句</li><li><code>printStackTrace()</code>打印异常的详细信息（推荐）</li><li><code>getMessage()</code>获取发生异常的原因</li></ol><ul><li>运行时异常：开发时通常不进行显式的处理</li><li>编译时异常：<strong>必须</strong>进行处理，否则编译不通过</li></ul><p><code>fianlly</code>：无论try或catch中是否存在仍未被处理的异常，finally中的语句都一定会被运行。</p><p>在开发中有一些资源使用之后必须显式地进行关闭，.close放在finally中。</p><h3 id="throws">2.throws</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExceptionType1, ExceptionType2 &#123;<br>    <span class="hljs-comment">// 可能抛出异常的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该方法本身不会处理这些异常，交给调用这个方法的代码去处理。</p><p>对于编译时异常，子类重写的方法抛出的异常类型不能比父类被重写的方法抛出的异常更高级。如果父类没抛异常，则子类也不能抛。</p><ul><li>如果代码重涉及到了资源的调用，则必须考虑使用try-catch-finally来处理，保证不出现内存泄漏。</li><li>如果父类被重写的方法没有throws，则子类只能使用try-catch-finally</li></ul><h3 id="throw">3.throw</h3><p>对于不满足实际场景，但不符合系统规定的异常的问题，手动抛出对象。</p><p>语法： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionType</span>(<span class="hljs-string">&quot;错误信息&quot;</span>);<br></code></pre></td></tr></table></figure></p><p>其中<code>ExceptionType</code>可以是系统自带的标准异常类，也可以是自定义的异常类。</p><p><strong>throw和throws的区别</strong>：</p><table><thead><tr><th><strong>功能</strong></th><th><strong><code>throw</code></strong></th><th><strong><code>throws</code></strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>用于手动抛出异常。</td><td>用于声明一个方法可能抛出的异常。</td></tr><tr><td><strong>使用位置</strong></td><td>用于方法内部。</td><td>用于方法声明中，表示该方法可能会抛出异常。</td></tr><tr><td><strong>后面跟的内容</strong></td><td>后面跟一个异常对象（如 <code>new Exception()</code>）。</td><td>后面跟异常类型（如<code>IOException</code>、<code>FileNotFoundException</code>）。</td></tr><tr><td><strong>是否需要处理异常</strong></td><td>抛出的异常必须由调用该方法的代码来处理。</td><td>调用方法的代码必须处理或声明这些异常。</td></tr></tbody></table><h1 id="多线程">多线程</h1><h2 id="程序进程与线程">程序、进程与线程</h2><p>程序(program) 进程(process) 线程(thread)</p><ul><li><strong>程序</strong>：我们写的代码/应用都属于程序，是一个静态的东西，包含了要执行的指令，只有在运行时才会发挥作用，相当于菜谱。</li><li><strong>进程</strong>：运行程序时操作系统会为程序分配资源，这时程序就变成了一个进程。进程是操作系统在执行过程中的“活跃”表现，相当于看着菜谱做菜的厨师。</li><li><strong>线程</strong>：进程中的最小执行单元，负责执行具体的命令。一个进程可以有多个线程，共享进程的资源比如内存。多线程可以让程序同时执行多个任务。</li></ul><h2 id="创建和启动线程">创建和启动线程</h2><h3 id="方式一继承thread类">方式一：继承Thread类</h3><ol type="1"><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run()，补充方法体</li><li>创建子类的对象</li><li>调用start():1.启动线程 2.调用当前线程的run()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintNumber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：不能让已经启动的线程再次启动，否则报异常<code>Exception in thread "main" java.lang.IllegalThreadStateException</code></p><p>要开启另一个线程需要重新创建一个对象。</p><h3 id="方式二实现runnable接口">方式二：实现Runnable接口</h3><p><em>Runnable.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Runs this operation.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>创建一个实现Runnable接口的类</li><li>实现run()，补全操作</li><li>创建对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread实例</li><li>实例调用start()</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NumberPrint</span> <span class="hljs-variable">numberPrint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberPrint</span>();<span class="hljs-comment">//创建类的实现对象</span><br>        <span class="hljs-comment">/*Thread的其中一个构造函数接受一个Runnable接口类型的参数，而NumberPrint类实现了这个接口，因此可以直接传入。</span><br><span class="hljs-comment">        * */</span><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(numberPrint);<br>        thread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberPrint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>④之所以成立，是因为Thread类有如下构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, task, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>形参为接口<code>Runnable</code>类型。<code>Runnable</code>是<code>Thread</code>类可以接受的类型，而<code>numberPrint</code>实现了<code>Runnable</code>接口，因此<code>Thread</code>类可以接受<code>numberPrint</code>类型的对象。</p><p><code>Thread</code>类并不关心具体传入的是哪一个实现<code>Runnable</code>接口的类，<code>numberPrint</code>只是其中的一个实现。</p><p><strong>多态性</strong>体现在，<code>Thread</code>类能够接受任何实现了<code>Runnable</code>接口的对象，实际执行的是实现类中的<code>run()</code>方法。</p><h2 id="thread的常用方法">Thread的常用方法</h2><ul><li><code>start()</code>:启动线程，调用线程的run()</li><li><code>run()</code>:将线程要执行的操作声明在run()中</li><li><code>currentThread()</code>:获取当前执行代码对应的线程</li><li><code>getName()</code>:获取线程名</li><li><code>setName()</code>:设置线程名</li><li><code>sleep(long millis)</code>:Thread类的<strong>静态</strong>方法，使当前线程睡眠指定的毫秒数</li><li><code>yield()</code>:一旦执行此方法，则提示当前线程让出CPU资源，让其他同优先级的线程有机会先执行（它只是一个<strong>提示</strong>，<strong>不能保证</strong>当前线程就一定会被挂起或其他线程就一定会立即执行）。调用该方法的线程会：<ul><li>实际开发中，yield()<strong>很少用</strong>来做线程调度控制，因为它行为不确定。</li></ul></li><li><code>join()</code>:<strong>非静态</strong>方法，等指定线程执行完毕，再继续执行当前线程。一般用于main等子线程执行完，而不会用于main，因为main的结束通常就意味着整个程序的结束。</li><li><code>isAlive()</code>:判断当前线程是否存活。</li></ul><h2 id="线程的优先级">线程的优先级</h2><p>线程优先级（Thread Priority）是 Java中用于提示操作系统调度器：哪个线程应该“更重要”，<strong>更可能获得 CPU时间片先运行的</strong>一种机制。</p><p><strong>线程优先级是建议，不是命令！</strong>操作系统可以参考，也可以无视它。</p><ul><li>getPriority():获取线程的优先级</li><li>setPriority():1~10</li><li>优先级的三个常量：<ul><li>MIN_PRIORITY = 1;最低优先级</li><li>NORM_PRIORITY = 5;默认优先级</li><li>MAX_PRIORITY = 10;最高优先级</li></ul></li><li>实际项目中很少用，一般由操作系统决定线程调度。</li></ul><h2 id="线程的生命周期">线程的生命周期</h2><p>现成的不同状态被定义在<code>Thread.java</code>的枚举类中。这些状态是Java虚拟机层面定义的状态，不一定等同于操作系统的线程状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br><br>    NEW,<br><br>    RUNNABLE,<span class="hljs-comment">//就绪+运行,Ready+Running=Runnable</span><br><br>    BLOCKED,<span class="hljs-comment">//阻塞，A thread that is blocked waiting for a monitor lock is in this state.</span><br><br>    WAITING,<span class="hljs-comment">//无限期等待</span><br><br>    TIMED_WAITING,<span class="hljs-comment">//限时等待</span><br><br>    TERMINATED;<span class="hljs-comment">//终止</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="https://i.imgur.com/eTf0YbI.png" alt="线程状态图解" /><figcaption aria-hidden="true">线程状态图解</figcaption></figure><h2 id="线程的安全问题">线程的安全问题</h2><p>多个线程访问同一资源时，如果都对资源有读和写的操作，可能会出现线程安全问题。</p><h3 id="解决方法">解决方法</h3><ol type="1"><li><strong>同步代码块</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步监视器)&#123;<br>    <span class="hljs-comment">//需要被同步的代码，即操作共享数据的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>作用：需要被同步的代码，当一个线程在操作这些代码的过程中其他线程必须等待。</li><li>同步监视器，俗称锁(Lock)。哪个线程获取了锁，哪个线程就能执行需要被同步的代码。</li><li>同步监视器可以使用任何一个类的实例充当。多个线程必须共用<strong>同一个</strong>同步监视器，是唯一的。</li></ul><ol start="2" type="1"><li><strong>同步方法</strong></li></ol><p>直接把方法声明为同步方法。相当于同步代码块的简化写法。</p><ul><li><code>synchronized</code>（实例方法）的同步监视器是this当前对象</li><li><code>static synchronized</code>（静态方法）的同步监视器是当前类的class对象</li></ul><p>synchronized弊端：串行执行，性能会低一些。</p><h3 id="线程安全的懒汉式">线程安全的懒汉式</h3><p>方式一：声明为同步方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Bank</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Bank <span class="hljs-title function_">getBank</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/*相当于</span><br><span class="hljs-comment">        synchronized (Bank.class) &#123;</span><br><span class="hljs-comment">            if(bank == null) &#123;</span><br><span class="hljs-comment">                bank = new Bank();</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(bank == <span class="hljs-literal">null</span>) &#123;<br>            bank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bank</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> bank;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方式二：同步代码块，与方式一等价。</p><p>方式三：避免指令重排的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 加 volatile 防止指令重排</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Bank</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title function_">getBank</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (bank == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 第一次检查</span><br>            <span class="hljs-keyword">synchronized</span> (Bank.class) &#123;<br>                <span class="hljs-keyword">if</span> (bank == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 第二次检查</span><br>                    bank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bank</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bank;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="死锁">死锁</h2><p>两个或多个线程在执行过程中，互相等待对方释放资源，结果谁也不释放，谁也无法继续执行，程序就“卡住”了。## Lock</p><p><code>import java.util.concurrent.locks.ReentrantLock;</code></p><ol type="1"><li>创建Lock的实例，确保多个线程共用一个lock实例:<code>private final Lock mylock = new ReentrantLock();</code></li><li>执行lock方法：<code>mylock.lock</code></li><li>调用unlock()，释放对共享数据的锁定。</li></ol><p>Lock更加灵活，推荐。</p><h2 id="线程间的通信机制">线程间的通信机制</h2><p>常用方法：</p><ul><li>wait():执行此方法的线程进入等待状态，<strong>同时会释放对同步监视器的调用</strong>，这一点与sleep()不同。“不干了，等通知”</li><li>notify():用来<strong>唤醒一个正在等待这个对象锁的线程</strong>。这个线程必须是因为<code>wait()</code>暂停的，别的不会受影响（在多个线程存在的情况下，唤醒优先级最高的那一个）。“<em>你可以起来干了</em>”。被唤醒的线程从当初被wait的位置继续执行。</li><li><strong>注意</strong>:wait()和notify()在调用时都应当让同步监视器(synchronized(obj)的obj)调用，否则报<code>IllegalMonitorStateException</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(obj) &#123;<br>    obj.wait();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>notifyAll():唤醒所有被wait的线程</li></ul><p>以上三个方法<strong>必须</strong>用于<strong>同步代码块或同步方法</strong>中。</p><p>不同点： - 声明的位置: - wait():声明在Object类中 -sleep()：声明在Thread类中，静态的</p><ul><li>使用的场景不同：<ul><li>wait()：只能使用在同步代码块或同步方法中</li><li>sleep():可以在任何需要使用的场景</li></ul></li><li>使用在同步代码块或同步方法中：<ul><li>wait()：一旦执行，会释放同步监视器</li><li>sleep()：一旦执行，不会释放同步监视器</li></ul></li><li>结束阻塞的方式：<ul><li>wait()：到达指定时间自动结束阻塞 或 通过被notify唤醒，结束阻塞</li><li>sleep():到达指定时间自动结束阻塞</li></ul></li></ul><h1 id="线程池">线程池</h1><p>提前创建好多个线程，放入线程池中，使用时直接获取。不在java基础的范围之内</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(4) 面向对象-高级</title>
    <link href="/2025/04/01/java4/"/>
    <url>/2025/04/01/java4/</url>
    
    <content type="html"><![CDATA[<h1 id="关键字static">关键字static</h1><p><strong>作用</strong>：使得类的某一个成员变量被这个类的所有实例所共享（类变量、静态变量），使得我们不需要创建对象就可以调用某个方法（类方法）。</p><p>静态变量：</p><ul><li>在内存空间中只有一份，被类的多个变量共享。</li><li>在JDK8之前，静态变量存储在方法区(MethodArea)；JDK8及以后，由于永久代(PermGen)被移除，静态变量存储在元空间(Metaspace)。</li><li>在类加载时就被初始化，分配内存，只加载一次，整个程序运行期间一直存在，直到类被卸载。</li></ul><table><thead><tr><th>类别</th><th>存储位置</th><th>生命周期</th><th>归属</th></tr></thead><tbody><tr><td>静态变量（static 变量）</td><td>方法区（JDK 8+ 为元空间）</td><td>类加载时分配，类卸载时释放</td><td>属于类，所有对象共享</td></tr><tr><td>实例变量</td><td>堆（Heap）</td><td>对象创建时分配，垃圾回收时释放</td><td>属于对象，每个对象都有独立副本</td></tr><tr><td>局部变量</td><td>栈（Stack）</td><td>方法执行时分配，方法结束后释放</td><td>属于方法，只能在当前方法中访问</td></tr></tbody></table><p>类方法：</p><ul><li>随着类的加载而加载</li><li>静态方法内可以调用静态的属性或静态的方法，不可以调用非静态的结构。</li><li><code>static</code>修饰的方法内不能使用<code>this</code>和<code>super</code>，因为<code>static</code>是属于<strong>类</strong>的，而<code>this</code>和<code>super</code>代表的是当前对象和当前对象的父类部分，他们都需要依赖于<strong>对象</strong>。同理，就算对象是一个空指针，也能正常调用静态的属性和方法，因为<code>static</code>不依赖于对象。</li></ul><p>什么时候需要<code>static</code>？</p><ul><li>当前的多个实例需要共享此成员变量</li><li>一些常量，比如PI</li></ul><p>什么时候要用静态方法？</p><ul><li>方法内要操作的变量都是静态变量时</li><li>工具类中的方法，比如<code>Arrays</code>，<code>Math</code>类</li></ul><h1 id="单例设计模式">单例设计模式</h1><p>单例(Singleton)设计模式，即每个类只能存在一个实例（即只能通过特定方法获取实例，不可随意创建），并提供一个全局访问点来获取该实例。</p><h2 id="饿汉式eager">饿汉式(Eager)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 提前创建实例</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// 私有构造器，防止外部创建实例</span><br><br>    <span class="hljs-comment">//使用getter方法获取当前实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>线程安全，在类加载时就创建实例，但是占用了一定内存，生命周期过长。</li><li>适用于实例创建开销小且使用频繁的场景。</li></ul><h2 id="懒汉式lazy">懒汉式(Lazy)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// 私有构造器，防止外部创建实例</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 只有在需要时才创建</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>延迟加载，在需要使用的时候再创建</li><li>线程不安全，如果多个线程同时调用<code>getInstance()</code>，可能会创建多个实例。</li></ul><h1 id="类的成员代码块">类的成员：代码块</h1><p>Java的代码块可以分为<strong>普通代码块、构造代码块、静态代码块、同步代码块</strong>。</p><table><thead><tr><th>代码块类型</th><th>关键字</th><th>触发时机</th><th>执行次数</th><th>作用</th></tr></thead><tbody><tr><td>普通代码块</td><td><code>&#123;&#125;</code></td><td>代码运行到该块时</td><td>多次</td><td>限定变量作用域，提高可读性</td></tr><tr><td>构造代码块</td><td><code>&#123;&#125;</code>（类中，不在方法内）</td><td>每次创建对象时</td><td>每次创建对象时执行</td><td>初始化对象公共属性，避免构造方法重复代码</td></tr><tr><td>静态代码块</td><td><code>static &#123;&#125;</code></td><td>类加载时</td><td>只执行一次</td><td>初始化静态变量，执行类级别的初始化</td></tr><tr><td>同步代码块</td><td><code>synchronized &#123;&#125;</code></td><td>代码执行时</td><td>多次</td><td>线程同步，保证线程安全</td></tr></tbody></table><p>普通代码块也可以放在类内方法外，这时用于初始化属性。执行顺序是静态代码块-普通代码块-构造器-其余方法。</p><p>代码块的加载顺序<strong>先于</strong>构造器，功能大差不差，初始化的操作在构造器里也可以实现。</p><h1 id="类的属性赋值">类的属性赋值</h1><p><img src="https://i.imgur.com/0g6owHM.png" /></p><h1 id="关键字final">关键字final</h1><p><code>final</code>可用来修饰类、方法、变量。</p><ol type="1"><li><code>final</code>修饰类；表示此类不能被继承。例如：<code>String</code><code>StringBuilder</code></li><li><code>final</code>修饰方法：表示此方法不能被重写。例如：<code>getClass()</code></li><li><code>final</code>修饰变量：成员变量或局部变量。此时变量其实就变成了常量，一旦赋值就不可更改。</li></ol><p><code>final</code>修饰成员变量可以显式赋值、构造器赋值、代码块赋值。</p><p><code>final</code>修饰局部变量：一旦赋值就不可更改。形参/方法内的局部变量。</p><p><code>final</code>与<code>static</code>搭配：成员变量称之为<strong>全局常量</strong>，例如<code>Math.PI</code></p><h1 id="abstract-class">Abstract Class</h1><p>抽象类是 Java中的一种特殊类，<strong>不能被实例化</strong>，通常用作<strong>基类</strong>，用于定义通用的行为和结构。它可以包含<strong>抽象方法</strong>（没有方法体的方法）和<strong>具体方法</strong>（有方法体的方法）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法（无方法体）</span><br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 具体方法（有方法体）</span><br>        System.out.println(<span class="hljs-string">&quot;Sleeping...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用<code>abstract</code>关键字。</li><li>抽象类其实是包含构造器的，因为子类对象实例化时，需要调用父类的构造器。</li><li>抽象类中可以没有抽象方法。</li><li>子类必须重写抽象类中的所有抽象方法之后才能实例化，否则子类仍然是抽象类。</li></ul><p><strong>使用场景</strong>：</p><ul><li>定义统一的接口，让不同的子类提供具体的实现。抽象类中只提供通用的逻辑，至于扩展特定的功能则交给子类的重写(Implement)。</li></ul><h1 id="接口">接口</h1><h2 id="概述">概述</h2><p>接口(interface)的本质是一组方法的规范。关键字：<code>interface</code>，</p><p>接口内部的说明：</p><ul><li>属性：不能包含实例变量，但可以有用<code>public static final</code>修饰（默认自带）。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">MAX_AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <span class="hljs-comment">// 等价于 public static final int MAX_AGE = 100;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法：声明抽象方法，修饰为<code>public abstract</code>（可以省略，默认自带）。</li><li><strong>不能有构造器</strong>（接口<strong>不能被实例化</strong>）。</li></ul><p><strong>接口与类的关系</strong>：使用<code>implements</code>关键字让一个类实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is eating...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is sleeping...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>规则</strong>：</p><ol type="1"><li>类必须实现接口中的<strong>所有</strong>方法，否则必须将类定义为<code>abstract</code>。</li><li>一个类可以实现<strong>多个接口</strong>（不像继承，Java只能单继承）。</li><li>类可以同时继承和实现：<code>class A extends SuperA implements B,C&#123;&#125;</code></li></ol><p>接口与接口可以多继承，类只能单继承。</p><h2 id="接口的多态性">接口的多态性</h2><p><code>接口名 变量名 = new 实现类</code> 非常常用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<span class="hljs-comment">//多态</span><br>        a.eat();<br>        a.sleep();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>区分抽象类和接口</strong>：</p><ul><li>共性：都可以声明抽象方法，都不能实例化</li><li>不同：抽象类一定有构造器，接口没有构造器；</li></ul><p>接口中声明的静态方法（java8引入）只能被接口调用，不能被其实现类调用。</p><p>从java8开始，接口可以有<code>default</code>方法，允许提供默认实现。默认方法可以被实现类继承，可以被实现类重写，不过在多实现时要注意重名问题（接口冲突），接口冲突时必须重写该方法。</p><p>java9允许接口定义<strong>私有方法</strong>，只在内部使用。</p><h1 id="类的成员内部类">类的成员：内部类</h1><h2 id="概述-1">概述</h2><p><strong>内部类(innerClass)</strong>：某个类A的内部还有一个部分需要一个完整的结构B来描述，B只为A服务，不在其他地方使用。A称为外部类，B称为内部类。</p><p>举例：<code>Thread</code>类内部的<code>State</code>类，表示线程的生命周期。</p><h2 id="分类">分类</h2><h3 id="成员内部类member-inner-class">1.成员内部类(Member InnerClass)</h3><ul><li>直接声明在外部类的里面，和成员变量一个位置。<ul><li>使用static修饰的：静态成员内部类</li><li>不使用static修饰的：非静态的成员内部类</li></ul></li><li>从类的角度看：<ul><li>内部可以声明类应有的结构</li><li>此内部类可以声明父类，实现接口</li><li>可以使用final修饰</li><li>也可以使用abstract</li></ul></li><li>从外部类的成员的角度：<ul><li>内部可以调用外部的结构</li><li>可以使用4种权限修饰符</li><li>可以使用static</li></ul></li></ul><h3 id="局部内部类local-inner-class">2.局部内部类(Local InnerClass)</h3><ul><li>声明在方法内部内、构造器内或代码块内的内部类<ul><li>匿名的成员内部类</li><li>非匿名的成员内部类</li></ul></li></ul><p><mark>匿名内部类的创建</mark></p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()&#123;<span class="hljs-comment">//创建一个继承于Object的匿名子类</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>            &#125;<br>        &#125;.test();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码可以无错误无警告地运行。</p><h1 id="枚举类">枚举类</h1><h2 id="概述-2">概述</h2><p>枚举属于<strong>引用数据类型</strong>，关键词：<code>enum</code>，枚举里面定义的是已经生成且固定下来的对象，实际上枚举中的每一个枚举值都是一个<code>public static final</code>实例。</p><blockquote><p>当我们使用“enum”定义枚举类型时，实质上我们定义出来的类型继承自java.lang.Enum类型，而枚举的成员其实就是我们定义的枚举类型的一个实例（Instance），他们都被预设为final，所以我们无法改变他们，他们也是static成员，所以我们可以通过类型名称直接使用他们，当然最重要的，他们都是公开的（public）。</p></blockquote><h2 id="enum的比较">enum的比较</h2><p>一般来说引用数据类型的中比较要使用<code>.equals()</code>，但是<code>enum</code>类型是例外，也可以使用<code>==</code>，这是因为每个枚举类型的常量在JVM中只有唯一的一个实例，所以两种比较方法都完全正确。</p><h2 id="enum类型">enum类型</h2><p><code>enum</code>定义的类型与一般的<code>class</code>没有任何区别，<code>enum</code>就是<code>class</code>。有以下特点：</p><ul><li><code>enum</code>继承自<code>java.lang.Enum</code>，<strong>不可以显式地定义其父类</strong>，而且无法被继承；</li><li>无法使用<code>new</code>创建新的枚举，因为枚举类型在编译时就已经固定下来。</li></ul><p>使用<code>enum</code>关键词创建的枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED, GREEN, BLUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>与下面这种写法基本等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span> &#123; <span class="hljs-comment">// 继承自Enum，标记为final class</span><br>    <span class="hljs-comment">// 每个实例均为全局唯一:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Color</span> <span class="hljs-variable">RED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Color</span> <span class="hljs-variable">GREEN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Color</span> <span class="hljs-variable">BLUE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();<br>    <span class="hljs-comment">// private构造方法，确保外部无法调用new操作符:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Color</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然每一个枚举的值都是<code>enum</code>类的一个实例。既然是实例，就应当可以调用方法；实际上<code>Enum.java</code>中已经提供了一些用于枚举值的方法。</p><h2 id="enum的常用方法">enum的常用方法</h2><p><code>name()</code>:返回常量名，定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ordinal()</code>:返回定义的常量的定义的顺序（整型），从0开始计数。</p><p><code>values()</code>:数组变量，储存枚举类所有对象的信息。</p><h2 id="枚举类实现接口的操作">枚举类实现接口的操作</h2><ol type="1"><li>枚举类实现接口，在枚举类中实现所需方法，通过枚举类的对象调用的是<strong>同一个</strong>方法（与普通类一样）</li><li>让每一个枚举类的对象<strong>分别</strong>重写方法，匿名的内部类。</li></ol><h1 id="注解annotation">注解(Annotation)</h1><p>常见的Java内置注解：</p><p><code>@override</code>用于检查重写方法是否写对。</p><p><code>@Deprecated</code>表示某个类或方法已经<strong>不推荐使用</strong>，调用时会有警告提示。调用被它标记的类或方法时会出现删除线。</p><p><code>@SuppressWarnings</code>告诉编译器<strong>忽略特定类型的警告</strong>。</p><p>框架 = 注解 + 反射 + 设计模式</p><p>元注解：注解的注解</p><h1 id="包装类">包装类</h1><p>包装类是为每种基本数据类型提供的一个形式封装，让基本数据类型可以像引用数据类型一样使用。</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr></tbody></table><p>包装类和对应的基本数据类型的内存地址也不一样：</p><p><img src="https://i.imgur.com/DIlCOZj.png" /></p><p><code>xxx.valueOf(...)</code><strong>手动</strong>将基本数据类型转化为引用数据类型，返回一个引用数据类型的新实例。</p><ul><li><p>已经创建的包装类的值可以修改吗？<strong>不可以</strong>，例如<code>Interger</code>是不可变对象，一旦被创建，值不可修改。</p></li><li><p><strong>装箱</strong>：Boxing，将一个基本数据类型转换为对应的包装类对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.valueOf(a);  <span class="hljs-comment">// 手动装箱</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>自动装箱</strong>：Autoboxing，Java5引入，直接把基本类型赋给包装类变量，Java编译器会自动帮你调用装箱的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;  <span class="hljs-comment">// 自动装箱：相当于 Integer.valueOf(a)</span><br></code></pre></td></tr></table></figure></p></li></ul><h1 id="string数据类型转换">String数据类型转换</h1><h2 id="基本数据类型包装类string">基本数据类型、包装类——&gt;String</h2><ol type="1"><li>直接调用<code>String xxx = String.valueOf(...);</code></li><li>也可以<code>String = xxx + "";</code></li></ol><h2 id="string基本数据类型包装类">String——&gt;基本数据类型、包装类</h2><p>调用包装类的静态方法<code>pasrsexxx</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br></code></pre></td></tr></table></figure><h1 id="常量池机制">常量池机制</h1><p>例如：自动装箱使用的<code>valueOf()</code>方法有缓存机制，<code>Integer</code>缓存-128~127，超出这个范围才会新建对象。</p><p>Java 中的“常量池(ConstantPool)”是一种<strong>优化内存使用和执行效率的机制</strong>。它的本质是一个用于存放常量（字面量、符号引用等）的特殊内存区域，目的是为了重用相同的值，避免重复创建对象。</p><h1 id="idea常用快捷键">IDEA常用快捷键</h1><table><thead><tr><th>功能说明</th><th>快捷键</th></tr></thead><tbody><tr><td>智能提示 - <em>edit</em></td><td><code>Alt + Enter</code></td></tr><tr><td>提示代码模板 - <em>insert live template</em></td><td><code>Ctrl + J</code></td></tr><tr><td>使用 xx 块环绕 - <em>surround with...</em></td><td><code>Ctrl + Alt + T</code></td></tr><tr><td>调出生成 getter/setter/构造器等结构</td><td><code>Alt + Insert</code></td></tr><tr><td>自动生成返回值变量 - <em>introduce variable</em></td><td><code>Ctrl + Alt + V</code></td></tr><tr><td>复制指定行的代码 - <em>duplicate line</em></td><td><code>Ctrl + D</code></td></tr><tr><td>删除指定行的代码 - <em>delete line</em></td><td><code>Ctrl + Y</code></td></tr><tr><td>切换到下一行代码空位 - <em>start new line</em></td><td><code>Shift + Enter</code></td></tr><tr><td>切换到上一行代码空位 - <em>start new line before current</em></td><td><code>Ctrl + Alt + Enter</code></td></tr><tr><td>向上移动代码 - <em>move statement up</em></td><td><code>Ctrl + Shift + ↑</code></td></tr><tr><td>向下移动代码 - <em>move statement down</em></td><td><code>Ctrl + Shift + ↓</code></td></tr><tr><td>向上移动行 - <em>move line up</em></td><td><code>Alt + Shift + ↑</code></td></tr><tr><td>向下移动行 - <em>move line down</em></td><td><code>Alt + Shift + ↓</code></td></tr><tr><td>查看方法参数提示 - <em>parameter info</em></td><td><code>Ctrl + P</code></td></tr><tr><td>重写父类的方法</td><td><code>Ctrl + O</code></td></tr><tr><td>实现接口的方法</td><td><code>Ctrl + I</code></td></tr><tr><td>查看继承树</td><td><code>Ctrl + H</code></td></tr><tr><td>类的UML关系图</td><td><code>Ctrl + Alt + U</code></td></tr><tr><td>定位某行、列</td><td><code>Ctrl + G</code></td></tr><tr><td>搜索</td><td><code>Ctrl + F</code></td></tr><tr><td>查找替换</td><td><code>Ctrl + R</code></td></tr><tr><td>全项目搜索文本</td><td><code>Ctrl + Shift + F</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(3) 面向对象-中级</title>
    <link href="/2025/03/30/java3/"/>
    <url>/2025/03/30/java3/</url>
    
    <content type="html"><![CDATA[<h1 id="this关键词">this关键词</h1><p>用<code>this</code>关键词可用来避免形参名和属性名<strong>重名</strong>的问题。简单来说，<strong>哪个对象调用，<code>this</code>就指向这个对象</strong>。</p><p><code>this</code>还可以用来<strong>调用构造器</strong>（即构造方法重载）：</p><ul><li>必须是构造方法的<strong>第一行</strong></li><li>在一个构造器中最多声明一个<code>this(形参列表)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">This</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">This</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-string">&quot;Unknown&quot;</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//此处this调用了This()构造器</span><br>        <span class="hljs-comment">//等价于：this.name = &quot;Unknown&quot;;this.age=0;</span><br>        System.out.println(<span class="hljs-string">&quot;This is the default constructor&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//以下为this调用属性：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">This</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name: &quot;</span> + name + <span class="hljs-string">&quot;, age: &quot;</span> + age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Getter</code>和<code>Setter</code>方法的快速调用：<code>alt + Insert</code>。</p><h1 id="面向对象的继承性">面向对象的继承性</h1><p>继承(inheritance)，关键词：<code>extends</code>，子类(subclass)继承父类(superclass)的属性和方法。</p><h2 id="优势">优势</h2><ol type="1"><li>减少代码冗余，提高代码的复用性</li><li>更利于功能的扩展</li><li>为多态的使用创造了前提</li><li>描述事物之间的所属关系，父类更为通用</li><li>继承不影响父类的封装性</li></ol><h2 id="语法">语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br> <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Java中声明的类，如果没有显式的声明其父类，则默认继承于<code>java.lang.object</code></li><li>Java只支持单继承，不支持多继承，一个子类只能有一个父类</li></ul><h2 id="protected-权限修饰符">protected 权限修饰符</h2><p>声明为 protected 的成员可以被以下范围访问：</p><ol type="1"><li>同一个类 ✅（当然可以访问）</li><li>同一个包中的其他类 ✅（包内可以访问）</li><li>子类（无论是否在同一个包） ✅（继承后可以访问）</li><li>不同包中的非子类 ❌（不能访问）</li></ol><p>应用场景：</p><ul><li>用于子类的继承，子类可以访问<code>protected</code>的方法和变量。</li></ul><h1 id="方法的重写">方法的重写</h1><p>方法重写(override)指的是子类对从父类继承的方法进行重新实现，提供不同的功能。</p><ul><li>必须发生在父类和子类之间</li><li>方法名和参数列表必须相同</li><li>子类的访问权限不能比父类更严格，不能重写<code>private</code>方法</li><li>只能重写非static方法，static方法不能被重写</li><li>可使用<code>@Override</code>注解</li><li>关于返回值类型：<br />父类void，则重写必须void;<br />父类基本数据类型，则子类重写必须相同数据类型；<br />父类引用数据类型，则子类的返回值数据类型可以相同或是其子类</li></ul><p>区分方法的重载与重写：</p><table><thead><tr><th>特性</th><th>方法重写（Override）</th><th>方法重载（Overload）</th></tr></thead><tbody><tr><td><strong>发生范围</strong></td><td>子类和父类</td><td>同一个类</td></tr><tr><td><strong>方法名</strong></td><td>必须相同</td><td>必须相同</td></tr><tr><td><strong>参数列表</strong></td><td>必须相同</td><td>必须不同（参数个数或类型不同）</td></tr><tr><td><strong>返回值类型</strong></td><td>必须兼容（可以是协变返回类型）</td><td>可以不同</td></tr><tr><td><strong>访问修饰符</strong></td><td>不能比父类更严格</td><td>没有限制</td></tr><tr><td><strong>关键字</strong></td><td>可以使用 <code>@Override</code></td><td>不需要 <code>@Override</code></td></tr></tbody></table><ul><li>关键词<code>super</code>可以在存在重写的情况下调用父类中的方法，或是用来区分子类和父类中同名的属性。</li><li>子类不会继承父类的构造器，<code>super(形参列表)</code>可以调用父类的构造器，放在构造器的<strong>首行</strong>。</li><li>子类构造器默认隐式调用父类的无参构造器，<code>super()</code>，</li><li>若父类为有参构造器，则子类必须也显式调用父类的有参构造器</li><li>子类中使用<code>this</code>调用同一类中的其他构造器，用<code>super</code>调用父类的构造器，<strong>二者不能共存</strong></li></ul><h1 id="面向对象的多态性">面向对象的多态性</h1><p>多态性(Polymorphism)的使用前提： 1. 要有类的继承关系 2.要有方法的<strong>重写</strong></p><p>多态性适用于方法，不适用于属性。</p><p>缺陷：父类引用的子类无法调用子类特有的方法。</p><p>如果要判断某个对象是否属于某个类的实例，可以用<code>instanceof</code>关键字：<code>A instanceof B</code>，直接用于条件判断。</p><p>多态可以通过向下转型提取出子类，从而可以调用子类的方法。在向下转型之前，可以使用<code>instanceof</code>进行判断，避免出现异常。</p><p>多态的好处：减少了大量的重载的方法的定义；开闭原则</p><h1 id="object类">Object类</h1><p><code>java.lang.Object</code>是类层次结构的根类，是所有其他类的父类。</p><p><img src="https://i.imgur.com/aJ69aSq.png" /></p><p>重点方法：<code>equals()</code> <code>toStriung()</code><br />了解方法：<code>clone()</code> <code>finalize()</code><br />其他：<code>getClass()</code> <code>hashCode()</code><code>notify()</code> <code>wait()</code></p><h2 id="equals">equals()</h2><ul><li>自定义的类，在没有重写Object和equals()方法的情况下，调用的就是Object中声明的equals()，即比较两个引用对象的<strong>地址</strong>是否相同</li><li>对于<code>String</code> <code>File</code><code>Date</code>和包装类等，都重写了Object中的equals()方法，用于比较两个对象的实体<strong>内容</strong>是否相等。</li><li>通常需要重写equals()，以便按照值（内容）进行比较，可用IDEA自动生成。</li></ul><p><strong>IDEA自动生成的格式</strong>：</p><p>以Customer类为例:</p><table><thead><tr><th>Customer</th></tr></thead><tbody><tr><td>- name: String</td></tr><tr><td>- age: int</td></tr><tr><td>- acct: Account</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Override</span> <span class="hljs-comment">//注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123; <span class="hljs-comment">//声明</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//若对象为空，或者不属于同一个类，则直接false</span><br>    <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> (Customer) o;<span class="hljs-comment">//在确定同类的情况下，向下转型</span><br>    <span class="hljs-keyword">return</span> age == customer.age &amp;&amp; Objects.equals(name, customer.name) &amp;&amp; Objects.equals(acct, customer.acct);<br>    <span class="hljs-comment">//如果两个对象的所有属性全部相同，则返回true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区分和equals">区分<code>==</code>和<code>equals()</code></h3><p><code>==</code>：运算符</p><ol type="1"><li>适用范围：基本数据类型，引用数据类型</li><li>基本数据类型：判断数据值是否相等</li><li>引用数据类型：比较两个引用变量地址值是否相等</li></ol><p><code>equals()</code>：</p><ol type="1"><li>只能用于引用数据类型</li><li>具体使用：见上</li></ol><h2 id="tostring">toString()</h2><p>Object类中toString的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p>开发中的使用场景：</p><ul><li><code>System.out.println()</code>打印的其实就是对象的<code>toString()</code></li></ul><p>子类使用说明：</p><ul><li>自定义的类没有重写该方法的情况下，默认返回的是对象的地址值。</li><li><code>String</code> <code>File</code><code>Date</code>等Object的子类都重写了该方法，调用时返回当前对象的实体内容。</li></ul><p>开发使用说明：</p><ul><li>习惯上，自定义的类会重写toString。</li></ul><p>仍以Customer类为例，自动生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Customer&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>            <span class="hljs-string">&quot;, acct=&quot;</span> + acct +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vscode实用快捷键总结</title>
    <link href="/2025/03/29/vscode/"/>
    <url>/2025/03/29/vscode/</url>
    
    <content type="html"><![CDATA[<h3 id="行操作"><strong>🔹 行操作</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Windows / Linux</strong></th><th><strong>Mac</strong></th></tr></thead><tbody><tr><td><strong>交换当前行和上一行</strong></td><td><code>Alt + ↑</code></td><td><code>Option + ↑</code></td></tr><tr><td><strong>交换当前行和下一行</strong></td><td><code>Alt + ↓</code></td><td><code>Option + ↓</code></td></tr><tr><td><strong>复制当前行</strong></td><td><code>Shift + Alt + ↓</code></td><td><code>Shift + Option + ↓</code></td></tr><tr><td><strong>删除当前行</strong></td><td><code>Ctrl + Shift + K</code></td><td><code>Cmd + Shift + K</code></td></tr><tr><td><strong>在下一行插入一行</strong></td><td><code>Ctrl + Enter</code></td><td><code>Cmd + Enter</code></td></tr><tr><td><strong>在上一行插入一行</strong></td><td><code>Ctrl + Shift + Enter</code></td><td><code>Cmd + Shift + Enter</code></td></tr></tbody></table><hr /><h3 id="选中-编辑"><strong>🔹 选中 &amp; 编辑</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Windows / Linux</strong></th><th><strong>Mac</strong></th></tr></thead><tbody><tr><td><strong>选中整行</strong></td><td><code>Ctrl + L</code></td><td><code>Cmd + L</code></td></tr><tr><td><strong>选中多个相同单词</strong></td><td><code>Ctrl + D</code></td><td><code>Cmd + D</code></td></tr><tr><td><strong>跳过当前选中，选中下一个匹配项</strong></td><td><code>Ctrl + K, Ctrl + D</code></td><td><code>Cmd + K, Cmd + D</code></td></tr><tr><td><strong>选中所有匹配项</strong></td><td><code>Ctrl + Shift + L</code></td><td><code>Cmd + Shift + L</code></td></tr><tr><td><strong>展开选中区域</strong></td><td><code>Shift + Alt + →</code></td><td><code>Shift + Option + →</code></td></tr><tr><td><strong>缩小选中区域</strong></td><td><code>Shift + Alt + ←</code></td><td><code>Shift + Option + ←</code></td></tr></tbody></table><hr /><h3 id="多光标编辑"><strong>🔹 多光标编辑</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Windows / Linux</strong></th><th><strong>Mac</strong></th></tr></thead><tbody><tr><td><strong>添加多个光标</strong></td><td><code>Alt + 点击</code></td><td><code>Option + 点击</code></td></tr><tr><td><strong>在选中区域的每一行添加光标</strong></td><td><code>Shift + Alt + I</code></td><td><code>Shift + Option + I</code></td></tr><tr><td><strong>光标向上添加一个光标</strong></td><td><code>Ctrl + Alt + ↑</code></td><td><code>Cmd + Option + ↑</code></td></tr><tr><td><strong>光标向下添加一个光标</strong></td><td><code>Ctrl + Alt + ↓</code></td><td><code>Cmd + Option + ↓</code></td></tr></tbody></table><hr /><h3 id="代码格式-其他"><strong>🔹 代码格式 &amp; 其他</strong></h3><table><thead><tr><th><strong>操作</strong></th><th><strong>Windows / Linux</strong></th><th><strong>Mac</strong></th></tr></thead><tbody><tr><td><strong>格式化代码</strong></td><td><code>Shift + Alt + F</code></td><td><code>Shift + Option + F</code></td></tr><tr><td><strong>快速打开文件</strong></td><td><code>Ctrl + P</code></td><td><code>Cmd + P</code></td></tr><tr><td><strong>打开终端</strong></td><td><code>Ctrl + ~</code></td><td><code>Cmd + ~</code></td></tr><tr><td><strong>查找</strong></td><td><code>Ctrl + F</code></td><td><code>Cmd + F</code></td></tr><tr><td><strong>替换</strong></td><td><code>Ctrl + H</code></td><td><code>Cmd + H</code></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(2) 面向对象-基础</title>
    <link href="/2025/03/28/java2/"/>
    <url>/2025/03/28/java2/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象的基本概念">面向对象的基本概念</h1><p>类（class）和对象（object）是面向对象的核心概念。</p><p><strong>类</strong>：具有相同特征的一大类事物</p><p><strong>对象</strong>：实际存在的该类事物的每个个体，也被称为实例（instance）。</p><p>面向对象内容的三大主线：</p><ul><li>Java类及类的成员：属性，方法，构造器；代码块、内部类。</li><li>面向对象的特征：封装、继承、多态、（抽象）</li><li>其他关键词的使用：this,super,package,import,static,final,interface,abstract等</li></ul><p>类，是一组相关<strong>属性</strong>和<strong>行为</strong>的集合，属性(field)即成员变量，行为即方法(method)。</p><h1 id="内存结构">内存结构</h1><ul><li>栈（stack）：方法内定义的变量，储存在栈中</li><li>堆（heap）：new创建的结构</li></ul><p>例如：</p><p>创建单个对象：</p><p><img src="https://i.imgur.com/Q9v6R16.png" /></p><p>创建多个对象：</p><p><img src="https://i.imgur.com/IdTtXZe.png" /></p><h1 id="类的成员属性">类的成员：属性</h1><p>Field:字段/域/成员变量</p><blockquote><p>Java中，一个类包含的变量被称为字段（Field）或成员变量。当这些变量通过getter/setter 方法暴露时，我们称其为“属性”（Property）。</p></blockquote><p>实例变量：类的对象拥有的变量，每个对象都有自己的一份。</p><p><strong>变量的分类</strong>：</p><p>按照数据类型来分：基本数据类型、引用数据类型</p><p>按照声明的位置来分：</p><ul><li>在方法体外，类体内声明的变量为<strong>成员变量</strong></li><li>在方法体内部等位置声明的变量为<strong>局部变量</strong></li></ul><p><img src="https://i.imgur.com/xx6LrzF.png" /></p><p>成员变量和局部变量在内存中分配的位置不同：</p><ul><li>成员变量（属性）存储在堆空间</li><li>局部变量存储在栈空间</li></ul><p><strong>生命周期</strong>：</p><ul><li>属性在对象创建时分配，销毁时释放。</li><li>局部变量随着方法对应的栈帧入栈，出栈而消亡。</li></ul><p><strong>是否有默认值</strong>：属性都有默认值，局部变量都没有默认值，必须先赋值再调用。</p><p>声明变量时，<code>static</code>关键字用<strong>于静态变量</strong>，访问时不需要创建对象，所有对象访问的是同一个变量，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<span class="hljs-comment">//声明</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 静态变量</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Example.num = <span class="hljs-number">20</span>; <span class="hljs-comment">// 直接用类名访问</span><br>        <span class="hljs-type">Example</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();<br>        <span class="hljs-type">Example</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();<br>        System.out.println(obj1.num); <span class="hljs-comment">// 20</span><br>        System.out.println(obj2.num); <span class="hljs-comment">// 20（所有对象访问的是同一个变量）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态变量在程序运行期间一直存在，类加载时分配，程序结束时释放。</p><h1 id="类的成员方法">类的成员：方法</h1><p>作用：类似C语言的函数，简化代码。</p><p>Java的方法<strong>不能独立存在</strong>，必须定义在类里。</p><h2 id="声明的格式">1.声明的格式</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">权限修饰符 <span class="hljs-selector-attr">[其他修饰符]</span> 返回值类型 方法名(形参列表) <span class="hljs-selector-attr">[throws 异常类型]</span> &#123; <span class="hljs-comment">//方法头</span><br>    <span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>权限修饰符</strong>：private  缺省  protected  public</p></blockquote><blockquote><p>形参列表的格式：(类型1 形参1,类型2 形参2, ...)</p></blockquote><h2id="对象调用方法时的内存分配情况">2.对象调用方法时的内存分配情况</h2><p>在 Java 中，当对象调用方法时，内存主要分为三个区域：</p><ol type="1"><li>堆（Heap） - 存放对象实例和实例变量。</li><li>栈（Stack） -存放方法调用时的局部变量、方法执行环境（方法帧）。</li><li>方法区（Method Area） -存放类的字节码信息、静态变量、方法元信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name; <span class="hljs-comment">// 实例变量（存放在堆内存）</span><br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// 局部变量（存放在栈内存）</span><br>        System.out.println(greeting);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/***************************************************/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>); <span class="hljs-comment">// 创建对象，存入堆</span><br>        p1.sayHello(); <span class="hljs-comment">// 调用方法</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 方法调用遵循“先入后出”的栈规则</span><br><span class="hljs-comment">* main入栈-sayHello入栈-sayHello出栈-main出栈-程序结束，JVM退出</span><br><span class="hljs-comment">*/</span><br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ol type="1"><li>对象 (<code>Person</code>) 创建在堆内存，实例变量(<code>name</code>) 也存放在堆。</li><li>方法调用时，会创建<strong>栈帧</strong>，局部变量存入栈内存，方法执行完后自动释放。</li><li>类的字节码信息存储在方法区，所有对象共享。</li><li><code>p1</code> 变量存放在栈内存，指向堆中的 <code>Person</code>对象。</li></ol><h1 id="对象数组">对象数组</h1><p>当数组的元素是引用类型的类(class)时，称之为对象数组。</p><p>创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名[] 数组名 = <span class="hljs-keyword">new</span> 类名[数组大小];<br></code></pre></td></tr></table></figure><h1 id="方法的应用">方法的应用</h1><h2 id="方法的重载">1.方法的重载</h2><p>方法重载（MethodOverloading）指的是在<strong>同一个类</strong>中，<strong>多个方法的名字相同，但参数列表不同</strong>（参数的类型、个数或顺序不同）。</p><p>方法的重载与形参名、权限修饰符、返回值的类型都没有关系。</p><p>编译器如何确定调用的是哪一个具体的方法？：先通过方法名，再通过形参列表。</p><p>坑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">char</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>&#125;;<br>System.out.println(arr);<br></code></pre></td></tr></table></figure><p>打印出来的结果是<code>abcdef</code>，而不是地址值。</p><h2 id="可变个数形参的方法">2.可变个数形参的方法</h2><p>在 Java 中，<strong>可变参数</strong>（Varargs，VariableArguments）允许一个方法接受<strong>可变数量的参数</strong>，使代码更加灵活。</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">返回值类型 方法名(数据类型... 变量名) &#123;<br>    <span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>可变参数在方法内部被当作<strong>数组</strong>处理，如<code>int... numbers</code>实际上等价于<code>int[] numbers</code>。</li><li>可变参数必须是方法的最后一个参数。</li><li>一个方法只能有一个可变参数。</li></ol><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Varargs2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">overload2</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">overload2</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> test.concat(<span class="hljs-string">&quot;=&quot;</span>,<span class="hljs-string">&quot;new&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>        System.out.println(info);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">overload2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">concat</span><span class="hljs-params">(String operator,String ... strs)</span>&#123;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(); <span class="hljs-comment">//拼接字符串时使用 StringBuilder可以避免频繁创建新的对象，性能更好</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>)&#123;<br>                result.append(strs[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.append(operator).append(strs[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.toString();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法的值传递机制">3.方法的值传递机制</h2><p>Java中方法的参数传递机制是<strong>按值传递(pass byvalue)</strong></p><p>方法体内声明的变量为局部变量，存储在栈空间。</p><ul><li>对于基本数据类型的变量来说，传递的是此变量保存的数据值。</li><li>对于引用型数据变量来说，传递的是此变量保存的地址值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 方法的值传递机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ep19</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2025/3/29 15:45</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassByValue</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">method</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">method</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        test.change(num);<br>        System.out.println(<span class="hljs-string">&quot;num = &quot;</span> + num);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">method</span> &#123;<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span> <span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>        m ++;<br>        System.out.println(<span class="hljs-string">&quot;m: &quot;</span> + m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">m: <span class="hljs-number">11</span><br>num = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></p><p>图例：</p><p><img src="https://i.imgur.com/upVuJnq.png" /></p><h2 id="递归方法">4.递归方法</h2><p><strong>递归(Recursion)</strong>是指<strong>一个方法在其内部调用自己</strong>，直到满足某个终止条件（基准条件），否则会无限递归，导致<code>StackOverflowError</code>。</p><p>递归示例：计算阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">compute</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算一个数的阶乘（递归）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n 输入一个整数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回输入值的阶乘结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">factorial</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//终止条件</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> n * factorial(n-<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：递归的内存耗用较多，占用大量的系统堆栈，需要<strong>慎用</strong>，高性能情况下尽量避免使用递归，不如循环迭代。</p><h1 id="package和import">package和import</h1><p>用于<strong>定义类的所属包</strong>，必须写在<strong>Java文件的第一行</strong>（除了注释）。</p><ul><li>package命名全部小写</li><li>通常使用公司域名的倒置</li></ul><p>例：<strong>MVC(Model-Vie-Controller)</strong>软件架构模式：</p><table><thead><tr><th>组件</th><th>作用</th><th>示例（以 Java Web 应用为例）</th></tr></thead><tbody><tr><td><strong>Model（模型）</strong></td><td>处理 <strong>数据和业务逻辑</strong>，与数据库交互</td><td>Java Bean、DAO（数据访问对象）</td></tr><tr><td><strong>View（视图）</strong></td><td>负责 <strong>用户界面</strong>，展示数据</td><td>HTML、JSP、Thymeleaf、前端框架（Vue、React）</td></tr><tr><td><strong>Controller（控制器）</strong></td><td>负责 <strong>接收用户请求</strong>，调用 Model 处理数据，并返回View</td><td>Servlet、Spring Controller</td></tr></tbody></table><ul><li><code>import</code>用于引入其他包中的类，以便可以直接使用类名，而不必写完整路径。</li><li>在同一个包中的类不需要导入。</li><li>如果使用不同的包下的同名的类，需要使用类的全名的方式指明是哪个类例如：</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">java.util.<span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>java.sql.<span class="hljs-type">date1</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.sql.Date(<span class="hljs-number">121212L</span>);<br></code></pre></td></tr></table></figure></li></ul><h1 id="面向对象的封装性">面向对象的封装性</h1><p>面向对象编程(OOP)的三大特性：<strong>封装、继承、多态</strong>。</p><h2 id="含义">含义</h2><p><strong>封装(Encapsulation)</strong>，指的是<strong>将对象的状态（属性）和行为（方法）封装在一起，并隐藏对象的内部实现细节</strong>，只向外界暴露必要的接口，以提高代码的<strong>安全性</strong>和<strong>可维护性</strong>。</p><p><code>高内聚、低耦合</code></p><h2 id="数据封装的方法">数据封装的方法</h2><p><strong>权限修饰符</strong>：<code>private</code>、<code>default</code>、<code>protected</code>、<code>public</code>，这体现了Java的封装性。我们可以用4种权限修饰符来修饰类和类的内部成员</p><p><strong>作用</strong>：体现被调用时的可见性的大小。声明为<code>private</code>的变量只能通过暴露的方法间接访问(赋值或取值)。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getnum</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>四种权限修饰符的总结</strong>(按照可见性从小到大)：</p><table><thead><tr><th>访问修饰符</th><th>同包访问</th><th>跨包访问</th><th>子类访问</th><th>适用场景</th></tr></thead><tbody><tr><td><code>private</code></td><td>❌ 不能访问</td><td>❌ 不能访问</td><td>❌ 不能访问</td><td>适用于 <strong>完全封装</strong>，只能内部访问</td></tr><tr><td><code>default</code>（无修饰符）</td><td>✅ 可以访问</td><td>❌ 无法访问</td><td>❌ 不能访问</td><td>适用于 <strong>包内使用</strong></td></tr><tr><td><code>protected</code></td><td>✅ 可以访问</td><td>❌ 无法访问</td><td>✅ 继承后可访问</td><td>适用于 <strong>子类继承但不暴露给外部</strong></td></tr><tr><td><code>public</code></td><td>✅ 可以访问</td><td>✅ 可以访问</td><td>✅ 可以访问</td><td>适用于 <strong>完全公开</strong></td></tr></tbody></table><p><strong>封装性的体现</strong>：</p><ol type="1"><li>私有化类的属性，提供公共的get和set方法，对此属性进行获取或修改。</li><li>将类中不需要对外暴露的方法设置为private。</li><li>单例模式中构造器为private，避免在类的外部创建实例。</li></ol><h1 id="类的成员构造器">类的成员：构造器</h1><p>构造器（Constructor）是<strong>用于创建对象</strong>的特殊方法，它在创建对象时会自动调用，一般用于<strong>初始化对象的属性</strong>。</p><p>构造器的声明格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">权限修饰符 类名(形参列表)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建类以后，在没有显式声明构造器的情况下，系统会默认提供一个构造器。且权限修饰符与类相同。</p><p>构造器可以重载。</p><hr /><p><strong>问1：main方法的public权限修饰符能不能换成private？</strong></p><ul><li><code>main</code>方法是 Java 程序的入口点，Java虚拟机（JVM）在执行程序时会调用<code>main</code>方法。如果<code>main</code>方法是<code>private</code>，JVM就无法访问它，导致程序启动失败。</li><li>同理，也不能是<code>protected</code>或缺省，否则JVM无法调用。</li></ul><p><strong>问2：为什么main方法必须是static?</strong></p><ul><li><code>main</code>方法是程序的入口，JVM在启动程序时不会自动创建类的对象，而是直接调用<code>main</code>方法。如果<code>main</code>不是<code>static</code>，那么JVM需要创建该类的对象，但没有默认构造方法可调用，因此会报错。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java SE(1) 基本常识</title>
    <link href="/2025/03/22/java1/"/>
    <url>/2025/03/22/java1/</url>
    
    <content type="html"><![CDATA[<p>学习顺序：javase、mysql、jdbc、javaweb、mybatis、springmvc、spring，这几样基本上就是学习java的骨架了。</p><h1 id="变量与运算符">变量与运算符</h1><h2 id="标识符的命名规范">标识符的命名规范</h2><ul><li>包名：多单词组成时所有字母都小写 xxxyyyzzz</li><li>类名、接口名：多单词组成时，所有单词的首字母大写 XxxYyyZzz</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写age,name,bookName</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接XXX_YYY_ZZZ</li></ul><h2 id="变量">变量</h2><p>变量（variable）定义：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。</p><p>构成：数据类型 变量名 = 变量值，例如：<code>int age = 10;</code></p><p>java的变量按照数据类型分为：</p><pre><code class="hljs">基本数据类型（8种）：      整型：byte \ short \ int \ long      浮点型：float \ double      字符型：char      布尔型：boolean  引用数据类型（6种）：    类（class）      数组（array）      接口（interface）      枚举（enum）      注解（annotation）      记录（record）</code></pre><p>变量都有其<strong>作用域</strong>，只在其作用域内有效。</p><h3 id="整型">整型</h3><p>byte  short  int  long 分别占用1，2，4，8字节（有正负）。</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>取值范围</th><th>默认值</th></tr></thead><tbody><tr><td><code>byte</code></td><td>1</td><td><code>-128</code> ~ <code>127</code></td><td><code>0</code></td></tr><tr><td><code>short</code></td><td>2</td><td><code>-32,768</code> ~ <code>32,767</code></td><td><code>0</code></td></tr><tr><td><code>int</code></td><td>4</td><td><code>-2,147,483,648</code> ~ <code>2,147,483,647</code></td><td><code>0</code></td></tr><tr><td><code>long</code></td><td>8</td><td><code>-9,223,372,036,854,775,808</code> ~<code>9,223,372,036,854,775,807</code></td><td><code>0L</code></td></tr></tbody></table><ul><li>定义<code>long</code>类型的变量，赋值时需要以“l”或“L”作为后缀。</li><li>Java程序中变量通常声明为<code>int</code>。</li><li>整数常量<strong>默认为int类型</strong>。</li></ul><h3 id="浮点型">浮点型</h3><table><thead><tr><th>数据类型</th><th>字节数</th><th>取值范围</th><th>默认值</th><th>精度</th></tr></thead><tbody><tr><td><code>float</code></td><td>4</td><td><code>±1.4E-45</code> ~ <code>±3.4028235E+38</code></td><td><code>0.0f</code></td><td>约 7 位</td></tr><tr><td><code>double</code></td><td>8</td><td><code>±4.9E-324</code> ~ <code>±1.7976931348623157E+308</code></td><td><code>0.0d</code></td><td>约 15~16 位</td></tr></tbody></table><ul><li>定义<code>float</code>类型的变量，赋值时需要以“f”或“F”作为后缀。</li><li>float的表示范围大于long，但是精度不高。</li><li>Java的浮点型常量<strong>默认为double型</strong>。</li><li>float、double不适用于不容许舍入误差的金融计算领域。如果需要精确数字计算或保留特定位数的精度，需要使用BigDecimal类。</li><li><code>IEEE 754标准</code>仍然不能实现“每一个十进制小数都对应一个二进制小数”，0.1+0.2不等于0.3</li></ul><h3 id="字符型">字符型</h3><ul><li>占用两个字节</li></ul><p>字符型变量的三种表现形式：</p><ol type="1"><li>单引号<code>''</code>适用于<strong>单个字符</strong></li><li>直接使用Unicode值表示。例如<code>char c8 = '\u0043';</code></li><li>使用转义字符''将后面的字符转变为字符型常量。</li><li>ASCII码</li></ol><h3 id="布尔型">布尔型</h3><ul><li>只有两个值：true、false，常常用在流程控制语句。</li><li>可以认为占4个字节（一般不谈布尔类型占用的空间大小）。具体来说：编译时不谈几个字节，但是JVM给boolean类型分配内存空间时，boolean类型的变量占据一个槽位（slot，等于4个字节）。</li></ul><h3 id="基本数据类型间的运算规则">基本数据类型间的运算规则</h3><ol type="1"><li><strong>自动类型提升</strong>：</li></ol><p>规则：容量小的变量与容量大的变量做运算时，结果自动转换为容量大的数据类型。容量指可表示数据范围的大小。</p><p>byte---&gt;short---&gt;int---&gt;long---&gt;float---&gt;double</p><ul><li>特殊情况1：容量小于int做运算结果用int类型，否则报错，而且实际的开发中也基本用不上byte和short。</li><li>特殊情况2：char类型运算结果也用int类型，同上。</li></ul><ol start="2" type="1"><li><strong>强制类型转换</strong></li></ol><p>规则：大范围类型转换为小范围类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)d1;<br><br></code></pre></td></tr></table></figure><h3 id="string类">String类</h3><ol type="1"><li>String类属于引用数据类型，俗称字符串。</li><li>可以使用一对双引号进行赋值。</li></ol><p>String与基本数据类型间的运算：</p><ol type="1"><li>这里可以包含布尔变量在内共8种。</li><li>只能做连接运算，用+。</li></ol><h2 id="运算符">运算符</h2><h3 id="逻辑运算符">逻辑运算符</h3><table><thead><tr><th>逻辑运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与（AND）</td><td>只有两个操作数都为 <code>true</code> 时，结果才为<code>true</code></td><td><code>true &amp;&amp; false</code> → <code>false</code></td></tr><tr><td><code>\|\|</code></td><td>逻辑或（OR）</td><td>只要有一个操作数为 <code>true</code>，结果就为<code>true</code></td><td><code>true \|\| false</code> → <code>true</code></td></tr><tr><td><code>!</code></td><td>逻辑非（NOT）</td><td>取反运算，将 <code>true</code> 变 <code>false</code>，反之亦然</td><td><code>!true</code> → <code>false</code></td></tr><tr><td><code>&amp;</code></td><td>按位与（AND）</td><td>与 <code>&amp;&amp;</code>类似，但<strong>不会发生短路</strong></td><td><code>true &amp; false</code> → <code>false</code></td></tr><tr><td><code>\|</code></td><td>按位或（OR）</td><td>与 <code>\|\|</code> 类似，但<strong>不会发生短路</strong></td><td><code>true \| false</code> → <code>true</code></td></tr><tr><td><code>^</code></td><td>逻辑异或（XOR）</td><td>只有两个操作数不相同时，结果才为 <code>true</code></td><td><code>true ^ false</code> → <code>true</code></td></tr></tbody></table><ul><li>逻辑运算符针对的是布尔型变量，结果也是布尔型。</li><li><code>&amp;&amp;</code>和<code>||</code><strong>具有短路特性</strong>，即在某些情况下可以<strong>提前确定最终结果</strong>，从而跳过后续运算，提高效率并避免不必要的计算。例如，<code>A &amp;&amp; B</code>只有当<code>A</code>为<code>true</code>时，才会计算<code>B</code>，如果<code>A</code>为<code>false</code>，那么结果必然为<code>false</code>，所以<code>B</code>会被直接跳过。对于<code>||</code>则反过来，如果<code>A</code>为<code>true</code>，那么不会计算<code>B</code>。</li></ul><h3 id="位运算符">位运算符</h3><p>难点、非重点</p><table style="width:100%;"><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与（AND）</td><td>两个位都为 <code>1</code>，结果才为 <code>1</code></td><td><code>5 &amp; 3</code> → <code>101 &amp; 011 = 001</code> →<code>1</code></td></tr><tr><td><code>\|</code></td><td>按位或（OR）</td><td>只要有一个位为 <code>1</code>，结果就是 <code>1</code></td><td><code>5 \| 3</code> → <code>101 \| 011 = 111</code> →<code>7</code></td></tr><tr><td><code>^</code></td><td>按位异或（XOR）</td><td>两个位不同则为 <code>1</code>，相同则为 <code>0</code></td><td><code>5 ^ 3</code> → <code>101 ^ 011 = 110</code> →<code>6</code></td></tr><tr><td><code>~</code></td><td>按位取反（NOT）</td><td>0 变 1，1 变 0（取反补码）</td><td><code>~5</code> → <code>~00000101</code> → <code>11111010</code>（即<code>-6</code>）</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移（Left Shift）</td><td>将二进制位左移 <code>n</code> 位，右侧补 <code>0</code></td><td><code>5 &lt;&lt; 2</code> → <code>101</code> → <code>10100</code> →<code>20</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移（Arithmetic Right Shift）</td><td>保持符号位，左侧补 <code>1</code> 或 <code>0</code></td><td><code>-5 &gt;&gt; 2</code> → <code>11111011</code> →<code>11111110</code> → <code>-2</code></td></tr><tr><td><code>&gt;&gt;&gt;</code></td><td>无符号右移（Logical Right Shift）</td><td>左侧统一补 <code>0</code>，不保持符号位</td><td><code>-5 &gt;&gt;&gt; 2</code> → <code>11111011</code> →<code>00111110</code>（即 <code>1073741822</code>）</td></tr></tbody></table><p><strong>案例</strong>：如何交换两个int变量的值？String呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;m=&quot;</span> + m + <span class="hljs-string">&quot;, n=&quot;</span> + n);<br><br>        <span class="hljs-comment">//声明一个临时变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> m;<br>        m = n;<br>        n = temp;<br><br>        System.out.println(<span class="hljs-string">&quot;m=&quot;</span> + m + <span class="hljs-string">&quot;, n=&quot;</span> + n);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件运算符">条件运算符</h3><p>(条件表达式) ? 表达式1 : 表达式2</p><p>条件表达式的结果是布尔类型。</p><h1 id="流程控制">流程控制</h1><h2 id="if-else">if-else</h2><p>与C语言相同，不赘述。</p><p>如何从键盘获取不同类型的变量：使用Scanner类。Scanner类中提供了获取不同类型变量的方法，除了char，需要使用<code>scan.next().charAt(0)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//提供（或创建）一个Scanner类的实例，这里创建了一个Scanner对象sc，用于接收用户的输入</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">//调用Scanner类中的方法，获取指定类型的变量，这里使用nextLine()读取整行文本</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sc.nextLine();<br><br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + s);<br><br>        <span class="hljs-comment">//关闭资源，调用Scanner类的close()</span><br>        scan.close();<br>    &#125;<br>&#125;    <br><br></code></pre></td></tr></table></figure><h2 id="获取随机数">获取随机数</h2><p>可以使用Java提供的API：Math类的random()（不用额外导包），返回一个[0.0,1.0)范围内的double随机数。</p><p>进一步的可以得到其他范围的随机数，例如[0,100]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">101</span>);<br></code></pre></td></tr></table></figure><p>获取一个[a,b]范围的随机数：<code>(int)(Math.random() * (b - a + 1)) + a;</code></p><h2 id="switch-case">switch-case</h2><p>语法格式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br><br>    <span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:<br>        <span class="hljs-comment">//执行语句1</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:<br>        <span class="hljs-comment">//执行语句2</span><br>        <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">//执行语句</span><br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>switch中的表达式只能是特定的数据类型：byte  short  char  int 枚举(JDK5.0新增)  String(JDK7.0新增)</li><li>开发中使用switch-case时，通常case匹配的情况都有限。</li><li>default的位置是灵活的。</li></ul><h2 id="循环语句">循环语句</h2><p>共三种：for,while,do-while</p><p>循环的4个要素：</p><ol type="1"><li>初始化条件</li><li>循环条件</li><li>循环体</li><li>迭代部分</li></ol><h3 id="for循环">for循环</h3><p>for(1;2;4){<br />3<br />}</p><p>迭代部分含有多条语句时，可以用逗号连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        输入两个正整数m和n，求最大公约数和最小公倍数。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> m&lt;n?m:n;<br><br>        <span class="hljs-comment">//最大公约数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=min;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span> &amp;&amp; m%i==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;最大公约数&quot;</span>+i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最小公倍数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> m&gt;n?m:n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=max;i&lt;=m*n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i%m==<span class="hljs-number">0</span> &amp;&amp; i%n==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;最小公倍数为&quot;</span> + i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们可以在循环结构中使用break，用于跳出循环结构。</li><li>循环条件不满足/循环体中执行了break</li></ul><h3 id="while循环">while循环</h3><p>1 while(2){<br />3<br />4<br />}</p><p>练习：猜数字小游戏 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        随机生成一个1到100以内的整数，用户输入一个整数，记录猜了几次才正确</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//生成随机数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomNumber</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>)+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//记录尝试的次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">guessNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//创建对象sc</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//输入数字</span><br>        System.out.println(<span class="hljs-string">&quot;Please enter a number between 1 and 100&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">yourNumber</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-comment">//循环</span><br>        <span class="hljs-keyword">while</span>(yourNumber != randomNumber)&#123;<br>            <span class="hljs-keyword">if</span>(yourNumber &gt; randomNumber)&#123;<br>                System.out.println(<span class="hljs-string">&quot;Your number is greater than random number&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Your number is less than random number&quot;</span>);<br>            &#125;<br>            guessNumber++;<br>            <span class="hljs-comment">//重新输入数字</span><br>            System.out.println(<span class="hljs-string">&quot;Please try again&quot;</span>);<br>            yourNumber = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-comment">//结束游戏</span><br>        System.out.println(<span class="hljs-string">&quot;congratulations!you have tried &quot;</span> + guessNumber + <span class="hljs-string">&quot; guesses&quot;</span>);<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="do-while-循环">do-while 循环</h3><p>1<br />do{<br />3<br />4<br />}while(2);</p><p>执行过程：1 - 3 - 4 - 2 - 3 - 4 - ··· - 2</p><p>至少会执行一次循环体，用得相对来说比较少。</p><h3 id="无限循环结构">“无限”循环结构</h3><p>格式： while(true) 或 for(;;)，中途使用break跳出循环。</p><p>示例：九九乘法表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java">ublic <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        案例：九九乘法表</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>                System.out.print(i + <span class="hljs-string">&quot;*&quot;</span> + j + <span class="hljs-string">&quot;=&quot;</span> + i*j + <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例">案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        案例：找出100000以内的所有质数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100000</span>;i++)&#123;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;Math.sqrt(i);j++)&#123;<br>                <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>)&#123;<br>                    isFlag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isFlag)&#123;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        System.out.println(<span class="hljs-string">&quot;time spend: &quot;</span> + (endTime - startTime));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：<code>time spend: 35</code>，注意这里的Math.sqrt(i)可以大大提升运算速度，因为一个数的因数关于它的算术平方根对称。</p><h1 id="数组">数组</h1><h2 id="基础知识">基础知识</h2><p>多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，通过编号统一管理。</p><p>Java中的<strong>容器</strong>：数组、集合框架：在<strong>内存</strong>中对多个数据的存储。</p><p>数组属于<strong>引用数据类型</strong>，声明格式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//如果已知初始值：</span><br><span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-comment">//如果未知初始值，需要动态创建：</span><br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-comment">//后续赋值时，直接引用元素，例如</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">30</span>;<br>arr[<span class="hljs-number">3</span>] = <span class="hljs-number">40</span>;<br>arr[<span class="hljs-number">4</span>] = <span class="hljs-number">50</span>;<br><br></code></pre></td></tr></table></figure></p><ul><li>数组一旦初始化完成，其长度确定，并且无法更改。</li><li>内存中一整块连续的空间。</li><li>数组长度可以使用arr.length获取</li></ul><p><strong>数组元素的默认初始化值</strong></p><ul><li>整型：<code>0</code></li><li>浮点型：<code>0.0</code></li><li>字符型：<code>0</code>（对应<code>'\u0000'</code>）</li><li>boolean型：<code>false</code></li><li>引用数据类型：<code>null</code></li></ul><h2 id="算法案例">算法案例</h2><h3 id="生成回行数">生成回行数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpiralMatrix</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入一个数字: &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        scanner.close();<br>        <br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (num &lt;= n * n) &#123;<br>            <span class="hljs-comment">// 从左到右</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) matrix[top][i] = num++;<br>            top++;<br>            <br>            <span class="hljs-comment">// 从上到下</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) matrix[i][right] = num++;<br>            right--;<br>            <br>            <span class="hljs-comment">// 从右到左</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) matrix[bottom][i] = num++;<br>            bottom--;<br>            <br>            <span class="hljs-comment">// 从下到上</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) matrix[i][left] = num++;<br>            left++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 打印结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                System.out.printf(<span class="hljs-string">&quot;%3d &quot;</span>, matrix[i][j]);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数组的扩容">数组的扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 现有数组 int[] arr = new int []&#123;1,2,3,4,5&#125;</span><br><span class="hljs-comment"> * 将数组的长度扩容1倍，将10，20，30添加到数组中，如何操作？</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ep19</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2025/3/26 21:52</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">expansion</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> []&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br>        <span class="hljs-comment">//扩容1倍容量</span><br>        <span class="hljs-type">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [arr.length*<span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">//复制到新的数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            newArr[i] = arr[i];<br>        &#125;<br><br>        <span class="hljs-comment">//添加新的数字</span><br>        newArr[arr.length] = <span class="hljs-number">10</span>;<br>        newArr[arr.length+<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br>        newArr[arr.length+<span class="hljs-number">2</span>] = <span class="hljs-number">30</span>;<br><br>        <span class="hljs-comment">//将新的数组地址赋值给原有的数组变量</span><br>        arr = newArr;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; newArr.length; i++) &#123;<br>            System.out.print(newArr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找">查找</h3><ol type="1"><li>线性查找：遍历数组返回索引 复杂度：O(N)</li><li>二分法查找（适用于<strong>有序</strong>数组）复杂度：O(log₂N)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dichotomy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">22</span>&#125;;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否找到了</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//默认的首索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<span class="hljs-comment">//默认的尾索引</span><br><br>        <span class="hljs-keyword">while</span> (head &lt;= end) &#123;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> head + (end - head) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">if</span>(target == arr[mid]) &#123;<br>                System.out.println(<span class="hljs-string">&quot;found it, the index is &quot;</span> + mid);<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid]) &#123;<br>                head = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                end = mid - <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            System.out.println(<span class="hljs-string">&quot;not found&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序算法">排序算法</h3><ol type="1"><li>时间复杂度：分析关键字的比较次数和记录移动的次数，记为<spanclass="math inline">\(O(n)\)</span></li><li>空间复杂度：分析排序算法中需要多少辅助内存，记为<spanclass="math inline">\(S(n)\)</span></li><li>稳定性：若两个值相等的A和B在排序后的前后顺序不变，则这种排序算法是稳定的</li></ol><p><strong>冒泡排序</strong>：</p><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">bubbling</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">33</span>,<span class="hljs-number">55</span>,<span class="hljs-number">43</span>,<span class="hljs-number">22</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-comment">//打印初始数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k : arr) &#123;<br>            System.out.print(k + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br><br>        System.out.println();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                    arr[j+<span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-comment">//打印排序后的结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : arr) &#123;<br>            System.out.print(k + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>快速排序</strong></p><p>时间复杂度： <span class="math inline">\(O(n\log(n))\)</span></p><h2 id="arrays工具类">Arrays工具类</h2><p><strong>判断两个数组是否相等</strong></p><p>位置：java.util</p><p>boolean equals(int[] a,int[] b):比较两个数组的元素是否<strong>依次相等</strong>。相等时返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isEquals</span> <span class="hljs-operator">=</span> Arrays.equals(arr1,arr2);<br></code></pre></td></tr></table></figure><p><strong>输出数组信息</strong></p><p><code>System.out.println(Arrays.toString(arr1));</code></p><p><strong>填充</strong></p><p>将数组中的所有元素填充为指定的数值，例如：<code>Arrays.fill(arr1,22);</code></p><p><strong>排序</strong></p><p><code>Arrays.sort(arr3);</code>，使用快速排序算法</p><p>数组的索引，表示数组元素距离首地址的偏移量，第一个元素地址与首地址相同，偏移量为0，索引是0</p><p>案例：</p><blockquote><p>输入一个整型数组，数组里既有正数也有负数，数组中连续的一个或多个整数成一个子数组，每个子数组都有一个和，求所有子数组的和的最大值。要求时间复杂度为O(n)。</p></blockquote><p><strong>卡丹算法</strong>(Kadane's Algorithm)，用<code>currentSum</code>记录以当前位置为结尾的子数组的最大和，<code>maxSum</code>记录所有子数组中的最大和。遍历数组，对于数组中的每个元素，最大子数组和只有两种可能：</p><ol type="1"><li><code>nums[i]</code>自己构成一个子数组，最大子数组和就是它自己</li><li><code>nums[i]</code>与前面的最大子数组和相加之后，得到的结果才是最大子数组和</li></ol><p>所以，<code>currentSum</code>每次都取以上两种情况中最大的一个。之后，更新<code>maxSum</code>，记录下这个最大值即可。实现的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * 输入一个整型数组，数组里既有正数也有负数，数组中连续的一个或多个整数成一个子数组，每个子数组都有一个和，</span><br><span class="hljs-comment"> * 求所有子数组的和的最大值。要求时间复杂度为O(n)。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ep19</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2025/3/27 21:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">sum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建数组</span><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//子数组和的最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentSum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//当前的子数组的和</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<span class="hljs-comment">//注意i从1开始计数，而不是0</span><br>            currentSum  = Math.max(currentSum + nums[i], nums[i]);<br>            maxSum = Math.max(maxSum, currentSum);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;maxSum is &quot;</span> + maxSum);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>卡丹算法只需要对数组进行一次遍历，因此时间复杂度是<spanclass="math inline">\(O(n)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为Hexo博客绑定域名出现ERR_SSL_UNRECOGNIZED_NAME_ALERTu错误</title>
    <link href="/2025/01/17/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    <url>/2025/01/17/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近为这个博客网站新绑定了一个域名。因为我先前没有学过计算机网络相关的知识，遇到ERR_SSL_UNRECOGNIZED_NAME_ALERTu的报错的时候反应了半天才明白要去申请一个SSL证书，在此记录一下这次绑定域名的操作流程。</p><h1 id="参考链接">参考链接</h1><p>1.<ahref="https://cps.ninja/2016/10/09/customize-your-blog-domain/">为Github 上的 Hexo 博客绑定个性域名</a></p><p>2.<ahref="https://www.littlelittleblack.com/Hexo/20200508-self-server-url.html">在自架服务器上搭建Hexo博客并绑定域名</a></p><h1 id="操作流程">操作流程</h1><p>我最开始看的是第一个链接，在namesilo上购买一个域名，然后直接使用namesilo进行DNS解析。第一个链接里有一点没有说清楚：A记录的IP地址应当是<code>username.github.io</code>的IP地址，而不是github的地址。对此，github的<ahref="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">官方文档</a>中有详细的说明：</p><p><img src="https://i.imgur.com/ZMUsLHh.png" /></p><p>向DNS解析中加入4个A记录即可。</p><p>当然也可以通过ping的方式获取IP地址。按<code>win</code>+<code>R</code>输入<code>cmd</code>，再输入<code>ping username.github.io</code>，看一下返回的IP即可：</p><p><img src="https://i.imgur.com/OEH8zEM.png" /></p><p>这次返回的是<code>185.199.109.153</code>.</p><h1 id="踩坑">踩坑</h1><p>我按照链接1的步骤操作完成之后，发现新绑定域名后的博客仍无法打开，报错：</p><p><strong>嗯… 无法访问此页面 https://kznep19.blog/上的网页似乎有问题，或者可能已永久移动到新的 Web 地址。ERR_SSL_UNRECOGNIZED_NAME_ALERTu</strong></p><p>向浏览器中输入<code>username.github.io</code>，发现原来的地址也无法访问了。起初我以为是namesilo自带的DNS解析功能无法正常使用（因为namesilo的名声似乎不是很好），所以我仿照链接2将NDS解析转移到国内的DNSPod网站上，发现仍然是同样的报错，说明问题不在这里。</p><p>注意<code>ERR_SSL_UNRECOGNIZED_NAME_ALERTu</code>，对此ChatGPT的回答如下：</p><blockquote><p>ERR_SSL_UNRECOGNIZED_NAME_ALERT 是一个与 SSL/TLS连接相关的错误，通常出现在客户端和服务器进行加密通信时。这种错误表示客户端在请求时提供的主机名（如网址）没有在服务器的证书中正确匹配，或者服务器没有正确配置SSL/TLS 证书。</p></blockquote><p>“没有正确配置 SSL/TLS证书”，我查找资料的过程中没有见到说绑定域名需要单独配置SSL证书的教程。直到我看到了<ahref="https://github.com/lss233/chatgpt-mirai-qq-bot/issues/1146">这个网站</a>，里面提到</p><blockquote><p>浏览器报错 ERR_SSL_UNRECOGNIZED_NAME_ALERT<br />其意为 “错误 SSL 无法识别的名称警报"。应该因为你还未部署SSL证书💦。SSL证书是此服务必须的，去申请一个即可 🙏。</p></blockquote><p>于是我在<ahref="https://ohttps.com/monitor/dashboard">OHTTPS</a>中为这个域名免费申请了一个SSL证书，很快网站就能正常访问了，至此问题终于得到解决。</p><p>另外，不管是OHTTPS还是DNSPod提供的SSL证书发放服务，其免费证书的有效期都只有三个月，快到期的时候要不要忘了更换证书。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>エルマ-ヨルシカ</title>
    <link href="/2025/01/07/Elma/"/>
    <url>/2025/01/07/Elma/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>雨とカプチーノ - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p><hr /><p>朝日の差す木漏れ日　僕とエルマ</p><p>まだ　まだ眠いかい</p><p>初夏の初め近づく五月の森</p><hr /><p>歩きだした顔には花の雫</p><p>ほら　涙みたいだ</p><p>このまま欠伸をしよう</p><p>なんならまた椅子にでも座ろう</p><hr /><p>許せないことなんてないんだよ</p><p>君は優しくなんてなれる</p><hr /><p>このまま何処かの遠い国で</p><p>浅い夏の隙間に寝そべったまま</p><p>涙も言葉も出ないままで</p><p>ただ夜の深さも知らないままで</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p><hr /><p>辛いことも苦しいことも何も見えないならわからないし</p><p>塞いだ目閉じたままで逃げた</p><p>月明かりの道を歩く</p><hr /><p>狭い部屋も冷たい夜も</p><p>眠い昼も　寂しい朝も</p><p>さよならの言葉越しに君の顔を見てる</p><hr /><p>このまま何処かの遠い国で</p><p>浅い夏の隙間に寝そべったまま</p><p>涙も言葉も出ないままで</p><p>ただ空の青さだけ見たままで</p><hr /><p>ただ君と終わりも知らないままで</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>少女A</title>
    <link href="/2025/01/05/%E5%B0%91%E5%A5%B3A/"/>
    <url>/2025/01/05/%E5%B0%91%E5%A5%B3A/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>神様のダンス - ヨルシカ</p><p>作詞：椎名もた（ぽわぽわP）</p><p>作曲：椎名もた（ぽわぽわP）</p><p>唄：鏡音リン</p><p>中文翻譯：https://home.gamer.com.tw/artwork.php?sn=5816671</p><hr /><p>僕の命ってったって　誰の命っつったって</p><p>即使說這是我的生命　即使說這是他人的生命</p><p>時々　公平に　裁かれるもんなんでしょ</p><p>偶爾　也會被公平地　受到裁決對吧</p><p>暗い空にやってきた　鬱を連れてやってきた</p><p>我抵達了漆黑的天空　並帶來了憂愁</p><p>時々雨　総計に　頼り切りだ　どうしよう</p><p>偶爾下起了雨　我總是　依賴著它　該怎麼辦呢</p><p>朽ちるまでの愛憎を　朽ちるまでの愛憎を</p><p>接受枯朽之前的愛憎　枯朽之前的愛憎的你</p><p>飲み込む君　簡単に　微笑む君　どうして</p><p>簡單地　露出微笑的你　為什麼</p><p>言葉を書く　曖昧に　言葉を書く　曖昧に</p><p>曖昧地　書寫著話語　曖昧地　書寫著話語</p><p>伝わりきらんないから　君だけをさ　信じて</p><p>因為根本無法全數傳達出去啊　所以我只　相信你一人</p><p>捨ててきた夢をあつめて</p><p>我開始收集起之前我所捨棄的夢想</p><p>ちょっと　ちょっと　間違えたから</p><p>因為這其中有些　有些　錯誤啊</p><p>ああ　「時に　時に　躓いたって、」</p><p>啊啊　「即使偶爾　偶爾　受到挫折、」　也還是</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い　言い寄らないで</p><p>好冷好冷好冷好冷　別如此求愛啊</p><p>ああ　君の君の君の声が</p><p>啊啊　你的你的你的聲音十分</p><p>遠い遠い遠い遠い遠い</p><p>遙遠遙遠遙遠遙遠遙遠</p><p>遠い遠い遠い遠い遠い</p><p>遙遠遙遠遙遠遙遠遙遠</p><p>遠い遠い遠い遠い　傷つけないで</p><p>遙遠遙遠遙遠遙遠　別傷害我啊</p><p>何番目でも　何番目でも</p><p>不管是第幾個　不管是第幾個</p><p>僕が僕であるために？</p><p>我也希望我能保有自我？</p><p>契り集め持ってきた　契り集め持ってきた</p><p>我收集起來各種約定　我收集起來各種約定</p><p>あの日の間違いを　飲み込むのが苦るしくて</p><p>要理解那一天的誤會　實在是過於痛苦</p><p>朽ちるまでの愛憎を　朽ちるまでの愛憎を</p><p>接受枯朽之前的愛憎　枯朽之前的愛憎的你</p><p>飲み込む君　簡単に　微笑む君　どうして</p><p>簡單地　露出微笑的你　為什麼</p><p>「子供だましの花ふたつ、」</p><p>「欺騙小孩的兩束花、」</p><p>きっと　きっと　諦めたから？</p><p>一定　一定是因為　我放棄了？</p><p>ああ　遠い夢を追いかけてさ</p><p>啊啊　我追趕著遙遠的夢想　但夢想卻十分</p><p>早い早い早い早い早い</p><p>快速快速快速快速快速</p><p>早い早い早い早い早い</p><p>快速快速快速快速快速</p><p>早い早い早い早い　追いつけないよ</p><p>快速快速快速快速　我根本無法追上啊</p><p>捨てきれず残した思いが</p><p>我無法完全捨棄並遺留下來的感受讓人十分</p><p>憎い憎い憎い憎い憎い</p><p>憎恨憎恨憎恨憎恨憎恨</p><p>憎い憎い憎い憎い憎い</p><p>憎恨憎恨憎恨憎恨憎恨</p><p>憎い憎い憎い憎い　許されないの？</p><p>憎恨憎恨憎恨憎恨　不被他人原諒嗎？</p><p>ああ　夢を夢を見てたはずが</p><p>啊啊　我本應該正在做夢　但卻感到了</p><p>怖い怖い怖い怖い怖い</p><p>恐懼恐懼恐懼恐懼恐懼</p><p>怖い怖い怖い怖い怖い</p><p>恐懼恐懼恐懼恐懼恐懼</p><p>怖い怖い怖い怖い　近づかないで</p><p>恐懼恐懼恐懼恐懼　別靠近我啊</p><p>合言葉を繰り返すだけ</p><p>我只是不斷重複著暗語而已</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い　お願いだから</p><p>好冷好冷好冷好冷　拜託你</p><p>何番目でも　何番目でも</p><p>不管是第幾個　不管是第幾個</p><p>僕が僕であるために…</p><p>我也希望我能保有自我…</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>雨とカプチーノ - ヨルシカ</title>
    <link href="/2024/12/30/%E9%9B%A8%E3%81%A8%E3%82%AB%E3%83%97%E3%83%81%E3%83%BC%E3%83%8E%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/12/30/%E9%9B%A8%E3%81%A8%E3%82%AB%E3%83%97%E3%83%81%E3%83%BC%E3%83%8E%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>雨とカプチーノ - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>灰色に白んだ言葉はカプチーノみたいな色してる</p><p>言い訳はいいよ　窓辺に置いてきて</p><p>数え切れないよ</p><hr /><p>灰色に白んだ心はカプチーノみたいな色をしてる</p><p>言い訳はいいよ　<ruby>呷<rt>あお</rt></ruby>ろうカプチーノ</p><p><ruby>戯<rt>おど</rt></ruby>けた振りをして</p><hr /><p>さぁ<ruby>揺蕩<rt>たゆた</rt></ruby>うように雨流れ</p><p>僕らに<ruby>嵐<rt>あら</rt></ruby>す花に溺れ</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないような思い出を</p><p>どうか、どうか、どうか君が溢れないように</p><hr /><p><ruby>波<rt>なみ</rt></ruby>待つ海岸　<ruby>紅<rt>くれない</rt></ruby>夕差す日</p><p>窓に反射して</p><p>八月のヴィスビー　<ruby>潮騒<rt>しおさい</rt></ruby></p><p>待ちぼうけ　海風一つで</p><hr /><p>夏泳いだ花の白さ、<ruby>宵<rt>よい</rt></ruby>の雨</p><p>流れる夜に溺れ</p><p>誰も褪せないような花一つ</p><p>どうか、どうか、どうか胸の内側に挿して</p><hr /><p>ずっとおかしいんだ</p><p>生き方一つを教えてほしいだけ</p><p>払えるものなんて僕にはもうないけど</p><p>何も答えられないなら言葉一つでもいいよ</p><p>わからないよ</p><p>本当にわからないんだよ</p><hr /><p>さぁ<ruby>揺蕩<rt>たゆた</rt></ruby>うように雨流れ</p><p>僕らに<ruby>嵐<rt>あら</rt></ruby>す花に溺れ</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないように書く詩を</p><p>どうか、どうか、どうか今も忘れないように</p><p>また一つ夏が終わって、花一つを胸に抱いて、</p><p>流れる<ruby>目蓋<rt>まぶた</rt></ruby>の裏で</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないようにこの詩を</p><p>どうか、どうか君が溢れないように</p><hr />]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神様のダンス - ヨルシカ</title>
    <link href="/2024/12/27/%E7%A5%9E%E6%A7%98%E3%81%AE%E3%83%80%E3%83%B3%E3%82%B9%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/12/27/%E7%A5%9E%E6%A7%98%E3%81%AE%E3%83%80%E3%83%B3%E3%82%B9%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>神様のダンス - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>忘れるなんて酷いだろ</p><p>幸せになんてなるものか</p><p>色のない何かが咲いた</p><p>君のいない夏に咲いた</p><hr /><p>人に笑われたくないから</p><p>怯えるように下を向く</p><p>心より大事な何かが</p><p>あってたまるものか</p><hr /><p>暮れない夕に茜追い付いて</p><p>君を染め抜いた</p><p>見えないように僕を追い越して</p><p>行かないで</p><hr /><p>僕たち神様なんて知らん顔</p><p>どこまでだって行ける</p><p>なぁ、心まで醜い僕らだ</p><p>世界は僕らのものだ</p><hr /><p>音楽だけでいいんだろ</p><p>他人に合わせて歩くなよ</p><p>教えてくれたのはあんたじゃないか</p><hr /><p>どうだっていいよ、このまま遠くへ</p><p>誰も知らない場所で月明かりを探すのだ</p><hr /><p>名もない花が綺麗のだ</p><p>どうでもいいことばっかだ</p><p>君の口癖が感染ってる</p><p>喉の真下には君がいる</p><hr /><p>言葉も生活も愛想も</p><p>全て捨ててこそ音楽だ</p><p>その価値も知らないあんたに</p><p>わかって堪るものか</p><hr /><p>暮れない夕に茜追い付いて</p><p>僕を染め抜いた</p><p>いつか時間が全て追い抜いて</p><p>消えないで</p><hr /><p>僕たち神様なんて知らん顔</p><p>世界の全部が欲しい</p><p>なぁ心まで醜いあんたの、想い出全部をくれよ</p><p>価値観だって自由なら</p><p>人を傷付けていいだろ</p><p>教えなかったのはあんたじゃないか</p><hr /><p>どうだっていいよ、このまま遠くへ</p><p>誰も見てない場所で生きる真似をしてるのさ</p><p>酷い顔で踊るのさ</p><p>胸も痛いままで</p><hr /><p>神様僕たちなんて知らん顔</p><p>どこまでだって行ける</p><p>なぁ、言葉が世界だと云うなら、世界は僕らのものだ</p><p>忘れるなんて酷いだろ</p><p>幸せになんてなれるかよ</p><p>僕を歪めたのはあんたじゃないか</p><hr /><p>そうだった、僕はこのまま遠くへ</p><p>誰も知らない場所で月明かりを探すのだ</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>レプリカント - ヨルシカ</title>
    <link href="/2024/11/25/%E3%83%AC%E3%83%97%E3%83%AA%E3%82%AB%E3%83%B3%E3%83%88%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/11/25/%E3%83%AC%E3%83%97%E3%83%AA%E3%82%AB%E3%83%B3%E3%83%88%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>レプリカント - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><p>君は映画をずっと観ている<br />在空无一人的劇場之中</p><p>誰一人もない劇場で<br />你一个人独自看着電影</p><p>今思えばチープなセットで<br />那是部現在看来布景廉价</p><p>人のよく死ぬSF映画<br />常有人死去的科幻電影</p><p>いつか世界が真面になって<br />如果将来世界能變得積極美好</p><p>人の寿命さえ随分伸びて<br />人的寿命也无限延長</p><p>死ねない世界になればいいのにね<br />可以不用經歷死亡就好了</p><p>そしたら心以外は偽物だ<br />這樣一来 除了真心其余皆是虚假的</p><p>言葉以外は偽物だ<br />除了話語其余皆是虚假的</p><p>神様だって作品なんだから<br />因為神明也不過是个作品罷了</p><p>僕ら皆レプリカだ<br />我們全都是複製品</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>冷たくなって年老いて<br />天气轉冷 年華逝去</p><p>その時に<br />届時</p><hr /><p>僕は映画をずっと観ている<br />我一直在看着一部電影</p><p>つまらないほどに薄い映画<br />一部庸俗到无聊的電影</p><p>席を立ってからやっと気付く<br />起身离席時我才終于發現</p><p>これは僕を描いたドラマだ<br />劇情所講述的正是我自己的故事啊</p><p>いつか僕らは大人になって<br />我們終将長大成人</p><p>手に入れるものも大きくなった<br />所獲之物也日益重大</p><p>次は愛でも買えればいいのにね<br />接下来要是連愛也能買到就好了呢</p><p>あんたの価値観なんて偽物だ<br />你的価値観全都是虚假的</p><p>思い出だって偽物だ<br />連回憶也全都是虚假的</p><p>心は腦の信号なんだから<br />因為心思不過是大腦傳輸的信号罷了</p><p>愛も皆レプリカだ<br />所有的愛也全都是複製品</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>思い出ばかりが募って<br />只有回憶靜靜堆積</p><p>その時に<br />届時</p><hr /><p>満たされるならそれで良かった<br />只要能感到滿足就好</p><p>歌を歌うのに理由も無いは<br />歌唱并不需要理由</p><p>他人の為に生きられない<br />我不会為他人而活</p><p>さよなら以外全部塵<br />离别以外 全部如塵</p><p>人を呪う歌を描きたい<br />想譜寫出詛咒他人的歌</p><p>それで誰かを殺せればいいぜ<br />若是能借此取人性命就好了</p><p>夏の匂いに胸が詰まっていた<br />夏日的气息郁結滿懷</p><p>僕らの心以外は偽物だ<br />除了我們的心其余皆是虚假的</p><p>言葉以外は偽物だ<br />除了話語其余皆是虚假的</p><p>この世の全部は主観なんだから<br />因為世界全凭主觀而存在啊</p><p>君も皆レプリカだ<br />你也同樣是複製品</p><p>さよならだって投げ出して<br />豁出一切道别离开</p><p>このまま遠く逃げ出して<br />就這樣逃向遠方</p><p>言葉で全部表して<br />用語言来表述一切</p><p>心も愛も書き足して<br />添注上真心与愛</p><p>それでも空は酷く青いんだから<br />因為即便如此 天空仍是无可比擬的蔚藍</p><p>それはきっと魔法だから<br />那一定是魔法</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>冷たくなって年老いて<br />天气轉冷 年華逝去</p><p>その時にやっとわかる<br />届時才終于明白</p><p>僕もその青さがわかる<br />我也懂得那份蔚藍</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>锁相环CD4046使用心得</title>
    <link href="/2024/11/23/%E9%94%81%E7%9B%B8%E7%8E%AFCD4046%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/2024/11/23/%E9%94%81%E7%9B%B8%E7%8E%AFCD4046%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<figure><img src="https://i.imgur.com/ZpUo6qu.jpg" alt="成品" /><figcaption aria-hidden="true">成品</figcaption></figure><h1 id="前言">前言</h1><p>最近在忙着做校队招新的题目，要求是用锁相环CD4046B做一个倍频器，倍频系数为1，2，4，8，16，32，64。这个题最烦人的地方在于覆盖的频率范围很大，输入信号范围是1kHz~100kHz，这样来算输出最大要达到6.4MHz，然而以CD4046B来说这根本不可能，因为这款锁相环上集成的VCO的输出频率最大也就1MHz左右：</p><p><img src="https://i.imgur.com/51pBwa3.png" /></p><p>如你所见，输出最大频率的典型值为<strong>1.4MHz</strong>，这也基本符合我实测的结果。总之这题做满100kHz的64倍频基本是没戏了，但是听说有个组做到了7MHz？搞不懂是什么情况。（再吐槽一句，TI的CD4046B的数据手册真的太古老了啊，赶紧更新一下吧）</p><h1 id="引脚说明">引脚说明</h1><p><img src="https://i.imgur.com/Z91APjn.png" /></p><p>见上图。</p><ul><li>3；鉴相器输入</li><li>4：VCO输出</li><li>6、7之间的<spanclass="math inline">\(C_1\)</span>是VCO的起振电容</li><li>12脚<spanclass="math inline">\(R_2\)</span>决定了输出频率是否叠加一个偏置。如果不接，那么输出无偏置，频率就可以达到比较低的范围；如果接上电阻，频率范围整体会往上移动。</li><li>11脚<spanclass="math inline">\(R_1\)</span>也影响了输出频率·范围，R1越小输出频率越大，我这里取的是10k欧。</li><li>5脚禁止端，低电平使能器件。</li><li>13，鉴相器2的输出，它接入环路滤波器的输入端。</li><li>9，VCO的输入，这个输入电压应当尽可能平稳，这样VCO才会有稳定的输出。</li></ul><p>我这次在调试电路过程中动的最多的就是C1和引脚，4。通过调整C1的值来获得不同的频率输出范围；将3、4直接连接来测试锁相环的功能；确定锁相环能正常工作后再把3、4断开，接入分频器。</p><h1 id="频率范围">频率范围</h1><p>CD4046B的输出频率与供电电压有关，供电电压越大，能够输出的频率也越大，但是不能超过15V。根据我的测试，在5V供电，R2不接，R1=10k欧，C1=100pF的情况下，VCO的输出频率最多只有大约700kHZ。想达到1MHz以上的频率必须增大电压到10V，但是这又会产生一问题：锁相环是10V电平输入输出，而分频器是5V电平，两种电平并不互容，必须进行<strong>电平转换</strong>。这是我们组在昨天得到的结论，然后今天我自己花了半个上午的时间才总算是调好了。为了能够覆盖从1kHz~1MHz的频率范围，我切换了三个电容：</p><table><thead><tr><th>100pF</th><th>4.7nF</th><th>3.3nF</th></tr></thead><tbody><tr><td>41k~1.2M</td><td>2k~40k</td><td>1k~29k</td></tr></tbody></table><p>注意这里的频率应当是<strong>倍频后最终输出的频率</strong>。</p><h1 id="电平转换">电平转换</h1><p>这里的电平转换，具体来说：</p><ul><li>锁相环VCO输出的10V方波要被转换为5V方波</li><li>分频器输出的5V方波要被转换为10V方波</li></ul><p>LTspice仿真结果如下：</p><p><img src="https://i.imgur.com/3vQpjKX.png" /></p><p>高电平转低电平用的是左边那个电路，其实就是一个反相器。需要注意的是上拉电阻R1不要取得太大，不然上升沿过于缓慢，适应不了1MHz。而且这个电路实际测试的时候输出在下降沿的振铃非常大，大概是杂散电容和寄生电感的影响（毕竟是焊接到洞洞板上的）。</p><p>低电平转高电平用的是右边的电路，因为左边的电路这时候就不能用了。</p><h1 id="环路滤波器">环路滤波器</h1><p>这是锁相环相当重要的一环。环路滤波器的职责就是将鉴相器输出的高频分量尽可能地滤干净。网上关于环路滤波器的设计方法资料并不是很多，可以参见该博客：<ahref="https://www.cnblogs.com/qm1412/p/18222379">锁相环学习---CD4046</a></p><p>环路滤波器有专用的设计软件，但是非常古老，必须再下载一个XP系统的虚拟机，非常麻烦，所以我就直接使用博客里设计好的电路了：</p><p><img src="https://i.imgur.com/yCQpeqy.jpg" /></p><p>LTspice仿真得到其幅频响应和相频响应如下：</p><p><img src="https://i.imgur.com/LWBPZIo.png" /></p><p>实测这个滤波器可以用于1kHz~1MHz的范围。</p><h1 id="对vco输出进行整形">对VCO输出进行整形</h1><p>这一步其实并不是必要的，但是我还是使用告诉比较器把输出波形整成好看一点的方波，这主要是因为我所用的10V转5V的电平转换电路上升沿非常慢，以至于方波几乎已经变成锯齿波了，非常难受。</p><p><img src="https://i.imgur.com/NrkVsnV.png" /></p><p>注意我最终电路中VIN是经过电容之后才送入比较器，这样隔离直流分量，比较器容易产生正确的结果。另外R1可以稍微取得大一些，比如500欧，对噪声的抑制能力也会强一些。这个比较器的输出为3.3V、0V，可以直接送入单片机的外部时钟输入引脚用来测量频率。</p><h1 id="总结">总结</h1><p>最后实现的效果如图（输入信号与输出信号稳定同频显示不漂移）只拍了N=1的情况，N=64也能非常稳</p><p><img src="https://i.imgur.com/PvEWWA3.jpg" /></p><p>这次与锁相环有关的电路基本都是我负责的，焊接在一大块洞洞板上，焊锡丝的助焊剂快熏死我了。。。不过好在最后的成品表现非常不错，最大能锁定到1.2MHz的频率，已经接近CD4046B的极限了。另外队友也买了一大堆CD4046B，过几天我想用这些多余的芯片测试一下锁相环的FM解调功能。</p>]]></content>
    
    
    <categories>
      
      <category>电子设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日語中的「くの字点」</title>
    <link href="/2024/10/30/%E6%97%A5%E8%AA%9E%E4%B8%AD%E7%9A%84%E3%80%8C%E3%81%8F%E3%81%AE%E5%AD%97%E7%82%B9%E3%80%8D/"/>
    <url>/2024/10/30/%E6%97%A5%E8%AA%9E%E4%B8%AD%E7%9A%84%E3%80%8C%E3%81%8F%E3%81%AE%E5%AD%97%E7%82%B9%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>最近在青空文庫上閲讀日語圖書的時候發現了這樣一段文字：</p><blockquote><p>表記について<br />このファイルは W3C 勧告 XHTML1.1 にそった形式で作成されています。<br />「くの字点」は「／＼」で表しました。</p></blockquote><p>即：此文件是根据W3C推荐的XHTML1.1格式制作的。'くの字点'用'／＼'表示。</p><p>「くの字点」是什麽？</p><p>我找到了這樣一篇解釋文章：<ahref="https://www.canon-its.co.jp/files/topics/2560_ext_06_0.pdf">https://www.canon-its.co.jp/files/topics/2560_ext_06_0.pdf</a></p><p>所謂'くの字点'，就是在重复两个字以上的假名，或漢字与假名時使用的標記符號。如果在重複時漢字的讀音變爲濁音，那麽くの字点也要相應地加上濁音符號。一個くの字点要占用兩個字節的位置。以下圖爲例：</p><p><img src="https://i.imgur.com/7NyGuQV.png" /></p><p>まあまあー＞まあ／＼ 大致，還算過得去<br />しかじかー＞しか／"＼　云云，等等<br />見る見るー＞見る／＼　眼看著，轉眼間<br />離れ離れー＞離れ／＼　失散</p><p>由於日語文章經常按照縱向排列，因此青空文庫就使用“／＼”來代替這個符號了。</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LTspice中SW元件的使用</title>
    <link href="/2024/10/14/LTspice%E4%B8%ADSW%E5%85%83%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/10/14/LTspice%E4%B8%ADSW%E5%85%83%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>LTspice不像Multisim那样有现成的手动开关。开关功能可以用<strong>S.Voltage Controlled Switch</strong>（压控开关）实现。</p><p><img src="https://i.imgur.com/1EAGN5i.png" /></p><ol type="1"><li>按P键打开元件库，搜索"SW"，放置在图纸中</li><li>插入指令定义SW元件的行为，例如：<code>.model MYSW SW(Ron=1 Roff=1Meg Vt=.5 Vh=-.4)</code>，其中<code>Ron</code>是导通电阻（<strong>导通电阻不能为0！</strong>），<code>Roff</code>为断开电阻，Vt和Vh决定了开关的阈值电压，在本例中为0.9V和0.1V</li><li>将开关模型的名称改成MYSW</li><li>放置一个电压源用来控制开关，这里用的是Pulse，开关在闭合1s后保持关断状态。</li></ol><p>SW相关的所有参数如下表格：</p><table><thead><tr><th style="text-align: center;">Name</th><th style="text-align: center;">Description</th><th style="text-align: center;">Units</th><th style="text-align: center;">default</th></tr></thead><tbody><tr><td style="text-align: center;">Vt</td><td style="text-align: center;">阈值电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Vh</td><td style="text-align: center;">滞后电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Ron</td><td style="text-align: center;">导通电阻</td><td style="text-align: center;">Ω</td><td style="text-align: center;">1.0</td></tr><tr><td style="text-align: center;">Roff</td><td style="text-align: center;">关断电阻</td><td style="text-align: center;">Ω</td><td style="text-align: center;">1/Gmin</td></tr><tr><td style="text-align: center;">Lser</td><td style="text-align: center;">串联电感</td><td style="text-align: center;">H</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Vser</td><td style="text-align: center;">串联电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Ilimit</td><td style="text-align: center;">限制电流</td><td style="text-align: center;">A</td><td style="text-align: center;">Infin.</td></tr></tbody></table><p><strong>该开关根据滞回电压 Vh的值，具有三种不同的电压控制模式:</strong></p><ul><li>如果 Vh为零，开关将始终完全导通或关断，具体取决于输入电压是否超过阈值电压。</li><li>如果 Vh为正值，开关将表现出滞回现象，就像通过施密特触发器控制一样，触发点为 Vt- Vh 和 Vt + Vh。需要注意的是，Vh是触发点之间电压的一半，这与常见的实验室术语有所不同。</li><li>如果 Vh为负值，开关将在导通和关断阻抗之间平滑过渡。过渡发生在控制电压 Vt - Vh和 Vt + Vh 之间，且平滑过渡遵循开关导通行为的对数的低阶多项式拟合。</li></ul><p>平时设Vh为负值就好。</p><p>参考链接：<br /><ahref="https://www.analog.com/cn/resources/technical-articles/ltspiceiv-voltage-controlled-switches.html#:~:text=To%20insert%20and%20configure%20a%20switch%20in%20LTspice%E2%80%A6,this%20example%3A.model%20MYSW%20SW%20%28Ron%3D1%20Roff%3D1Meg%20Vt%3D.5%20Vh%3D-.4%29">LTspice:Voltage Controlled Switches</a></p>]]></content>
    
    
    <categories>
      
      <category>EE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为Fluid主题首页的副标题添加淡入效果</title>
    <link href="/2024/10/04/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E7%9A%84%E5%89%AF%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%B7%A1%E5%85%A5%E6%95%88%E6%9E%9C/"/>
    <url>/2024/10/04/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E7%9A%84%E5%89%AF%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%B7%A1%E5%85%A5%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近又折腾了一下博客的美化。默认Fluid主题的首页副标题用的是打字机特效，不过我不太喜欢，于是琢磨了一下淡入效果。我并没有学过前端，一下代码主要靠chatgpt和其他网友得到。</p><h1 id="过程">过程</h1><p>使用F12打开开发者模式，定位副标题：<br /><img src="https://i.imgur.com/mgjRfJ2.jpg" alt="Imgur" />目标对应的元素为<code>.h2 #subtitle</code>，在外部CSS文件中加入下列代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Si Yuan&quot;</span>;<br>    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;../fonts/Si Yuan.otf&quot;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;truetype&quot;</span>);<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">400</span>;<br>  &#125;<br><br><span class="hljs-selector-class">.h2</span> <span class="hljs-selector-id">#subtitle</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Si Yuan&#x27;</span>, sans-serif; <span class="hljs-comment">/* 替换为你想要的字体 */</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32px</span>; <span class="hljs-comment">/* 调整字体大小 */</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>; <span class="hljs-comment">/* 设置字体颜色 */</span><br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 初始透明度为0，隐藏 */</span><br>    <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">1.5s</span> linear; <span class="hljs-comment">/* 设置过渡效果 */</span><br>  &#125;<br><br><span class="hljs-selector-class">.h2</span> <span class="hljs-selector-id">#subtitle</span><span class="hljs-selector-class">.visible</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 完全可见 */</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>由于这里我使用的是思源宋体，并非系统自带的字体，因此额外使用<code>@font-face</code>引入外来字体。</p><p>另外，注意文章页的标题和首页的标题用的是同一个元素，二者会同时发生变更。</p><p>再向外部js文件中加入下列代码： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> subtitle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;subtitle&#x27;</span>);<br>    subtitle.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;visible&#x27;</span>); <span class="hljs-comment">// 页面加载后添加 visible 类</span><br>&#125;);<br></code></pre></td></tr></table></figure> 完成。</p>]]></content>
    
    
    <categories>
      
      <category>Theme</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>雪酷字幕组的特效注释字幕分析</title>
    <link href="/2024/10/02/%E9%9B%AA%E9%85%B7%E5%AD%97%E5%B9%95%E7%BB%84%E7%9A%84%E7%89%B9%E6%95%88%E6%B3%A8%E9%87%8A%E5%AD%97%E5%B9%95%E5%88%86%E6%9E%90/"/>
    <url>/2024/10/02/%E9%9B%AA%E9%85%B7%E5%AD%97%E5%B9%95%E7%BB%84%E7%9A%84%E7%89%B9%E6%95%88%E6%B3%A8%E9%87%8A%E5%AD%97%E5%B9%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>雪酷字幕组在2011至2012年期间与曙光字幕组合作完成了《命运石之门》的翻译工作，这也是我最早看的一个版本，翻译非常贴切自然，并且动漫中出现的流行词汇也都附上了详尽的注释。可惜在2014年之后雪酷字幕组就突然失踪了……这里我想分析一下他们在为《命运石之门》做字幕注释时用到的特效方案，从中窥视那个时代的字幕组对待字幕工作是何等敬业。</p><span id="more"></span><p>以繁体版第10集3:46处的注释为例，ass文件代码如下：</p><pre><code class="hljs">3:46.19~3:51.20     &#123;\move(15,20,15,10,0,200)\pos(15,10)\fad(300, 300)&#125;Blood Tune3:45.90~3:51.41   &#123;\fscx0\pos(15,20)\t(0,200,1,\fscx100)\t(5300,0,1,\fscx0)&#125;————3:46.19~3:51.20   &#123;\move(15,20,15,50,0,200)\pos(15,50)\fad(300, 300)&#125;（架空）ＴＶ動畫『BLOOD TUNE THE ANIMATION』。\N原作是漫畫，隨著多元媒體化的風潮終於在去年動畫化。\N作品被製作成為全２６話的作品，受到了動漫愛好者們的廣泛關注，\N特別是女主角『星來Orujeru』的PVC模型擁有相當高的人氣。</code></pre><p>上面一共用了三段字幕来完成对【BloodTune】的注释。而且，三段字幕分别使用了三种不同大小的字体（在1080p清晰度下）：</p><ol type="1"><li>neta1-微软雅黑，用于注释对象的名称，字号26，边框2，阴影0</li><li>neta2-微软雅黑，用于创造分界线，字号40，边框2，阴影0</li><li>neta3-微软雅黑，用于注释的具体内容，字号28，边框2，阴影0</li></ol><p>实现的效果如图 <imgsrc="https://media.giphy.com/media/EuIDh9scyssnZXBT39/giphy.gif" /></p><p>下面对这三段代码进行逐行分析。</p><h1 id="平滑的文本展示效果">平滑的文本展示效果</h1><p><code>\move</code>用于设置文本的<strong>移动轨迹</strong>，其基本语法是<code>\move(x1,y1,x2,y2,start_time,end_time)</code>，其中<code>(x1,y1)</code>是起始位置，<code>(x2,y2)</code>是结束位置，<code>start_time</code>和<code>end_time</code>定义动画的开始和结束时间（单位：毫秒）。</p><p><code>\pos</code>用于设置文本的<strong>绝对位置</strong>，其语法是(x,y)，其中 x 和 y是屏幕坐标。这个命令将文本固定在指定的位置，不随时间变化。</p><p><code>\fad</code>用于设置文本的<strong>淡入淡出</strong>效果，其基本语法是<code>\fad(fade_in_time, fade_out_time)</code>，其中<code>fade_in_time</code>是淡入持续的时间（毫秒），<code>fade_out_time</code>是淡出持续的时间（毫秒）。</p><p><code>&#123;\move(15,20,15,10,0,200)\pos(15,10)\fad(300, 300)&#125;Blood Tune</code>是一串复合代码，综合以上三点，其作用为：- 文本从屏幕坐标<code>(15, 20)</code>移动到<code>(15, 10)</code>，在 0毫秒时开始，200 毫秒时结束。 -文本运动到<code>(15,10)</code>后会被固定到这个位置。 -在文本开始移动的同时，会附加一个300毫秒的淡入效果，在文本消失时则有300毫秒的淡出效果。</p><h1 id="动态的分界线">动态的分界线</h1><p><code>\fscx</code>用于设置文本的<strong>水平缩放</strong>(<strong>f</strong>ront<strong>sc</strong>ale<strong>x</strong>)，其基本语法是<code>\fscx&lt;value&gt;</code>，其中<code>&lt;value&gt;</code>是缩放的百分比值。例如：</p><ul><li><code>\fscx100</code>表示正常大小</li><li><code>\fscx50</code>表示正常大小的一半</li></ul><p><code>\t</code>用于创建<strong>动画效果</strong>（transformation），从一个样式动画渐变到另外一个。Aegisub手册给出的语法如下：</p><pre><code class="hljs">\t(&lt;style modifiers&gt;)\t(&lt;accel&gt;,&lt;style modifiers&gt;)\t(&lt;t1&gt;,&lt;t2&gt;,&lt;style modifiers&gt;)\t(&lt;t1&gt;,&lt;t2&gt;,&lt;accel&gt;,&lt;style modifiers&gt;)</code></pre><p>本例使用的是第四个。其中<code>&lt;style modifiers&gt;</code>参数是特效标签，<code>accel</code>参数可以让动画效果不再是匀速的，而是满足一条指数曲线。该参数为1时，运动速度是恒定的。参数在0和1之间时，运动速度逐渐变慢。参数大于1时，运动速度越来越快。</p><p>整个代码的运行逻辑可以用下图概括：<br /><img src="https://i.imgur.com/r6Rsdn7.png" /></p>]]></content>
    
    
    <categories>
      
      <category>字幕</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid主题渲染LaTeX数学公式的问题总结</title>
    <link href="/2024/09/15/Hexo%20Fluid%E4%B8%BB%E9%A2%98%E6%B8%B2%E6%9F%93LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2024/09/15/Hexo%20Fluid%E4%B8%BB%E9%A2%98%E6%B8%B2%E6%9F%93LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>在Fluid的<ahref="https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">官方指南文档</a>中已经做了详尽的说明，一步一步跟着做就没问题。值得注意的是，在主题配置的代码</p><pre><code class="hljs">post:math:enable: truespecific: falseengine: mathjax</code></pre><p>中，要想使用数学公式，<code>enable</code>一项必须是<code>true</code>才行，否则会出现渲染错误，比如像下面这样：</p><p><imgsrc="https://github.com/banyee19/blog_images/blob/main/%E4%B8%8D%E5%90%AF%E7%94%A8.jpg?raw=true" /></p><p>同样的公式渲染了一次之后又重复了一次。</p><p>另外，Hexo中无法使用换行符<code>\\</code>，原因是<code>\</code>在Markdown属于特殊字符，用于字符转义，所以两个<code>\</code>经过Markdown引擎处理为html后，只剩下一个，等到LaTex渲染引擎处理时，实际上只看到一个<code>\</code>，渲染引擎把它当作LaTeX 中的空格。</p><p>在不改动现有代码的情况下，我的解决方法是直接改变公式的写法。比如下边这个公式</p><pre><code class="hljs">$$a_11=b_11 \\a_22=b_22+c_22$$</code></pre><p>改为</p><pre><code class="hljs">$$\begin&#123;aligned&#125;a_&#123;11&#125;&amp; =b_&#123;11&#125;\\a_&#123;22&#125;&amp; =b_&#123;22&#125;+c_&#123;22&#125;\end&#123;aligned&#125;$$</code></pre><p>渲染效果如下： <span class="math display">\[\begin{aligned}a_{11}&amp; =b_{11}\\a_{22}&amp; =b_{22}+c_{22}\end{aligned}\]</span> 更复杂的公式同理： <span class="math display">\[\begin{aligned}    F_x&#39;&amp;=\gamma\{q[\frac{-i\gamma}{c}(u_t&#39;+i\betau_x&#39;)E_x+u_y&#39;B_z-u_z&#39;B_y]    +i\beta\frac{iq}{c}[\gamma(u_x&#39;-i\betau_t&#39;)E_x+u_y&#39;E_y+u_z&#39;E_z] \}\\    &amp;=\frac{-iq\gamma^2}{c}(1-\beta^2)E_xu_t&#39;-q\gamma(B_y+\frac{\beta}{c}E_z)u_z&#39;+q\gamma(B_z-\frac{\beta}{c}E_y)u_y&#39;\end{aligned}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序章-新博客的诞生</title>
    <link href="/2024/09/13/hello-world/"/>
    <url>/2024/09/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>新博客建成祝贺！ <span id="more"></span>经过两天的配置，，终于成功用Github把博客搭建出来了！</p><p>其实之前我一直是在博客园上面写博客的（虽然也才刚写了几个月），但是最近博客园的运营情况令人堪忧，可能再过几个月就要被收购了，嘛这样的话到时候博客园大概率要植入广告了，所以索性自己创建一个博客好了。另一方面，我写博客的目的是把自己的想法记录下来，或者分享自己的知识，所以博客园那种类似于论坛式的模式其实并不是很适合我。只要把博文发出来，我就达到目的了，就算没有人看也没关系。</p><p>不出意外的话这个博客应该会长期更新下去。毕竟是自己费了好大的功夫才建出来的嘛（笑）我在生活中并不喜欢和别人交流，周围能和我一起交流喜欢的事物的人几乎没有，但是我还是希望把自己思考的东西分享出来。那干脆就借助博客好了。以后这个博客上会发布各种我感兴趣的内容。</p><p>总之，我宣布，Banyee's Blog从今天开始正式成立了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>初次见面</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
