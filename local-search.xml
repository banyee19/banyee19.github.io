<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java基础知识（一）</title>
    <link href="/2025/03/22/javanote/"/>
    <url>/2025/03/22/javanote/</url>
    
    <content type="html"><![CDATA[<p>学习顺序：javase、mysql、jdbc、javaweb、mybatis、springmvc、spring，这几样基本上就是学习java的骨架了。</p><h1 id="变量与运算符">变量与运算符</h1><h2 id="标识符的命名规范">标识符的命名规范</h2><ul><li>包名：多单词组成时所有字母都小写 xxxyyyzzz</li><li>类名、接口名：多单词组成时，所有单词的首字母大写 XxxYyyZzz</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写age,name,bookName</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接XXX_YYY_ZZZ</li></ul><h2 id="变量">变量</h2><p>变量（variable）定义：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化。</p><p>构成：数据类型 变量名 = 变量值，例如：<code>int age = 10;</code></p><p>java的变量按照数据类型分为：</p><pre><code class="hljs">基本数据类型（8种）：      整型：byte \ short \ int \ long      浮点型：float \ double      字符型：char      布尔型：boolean  引用数据类型（6种）：    类（class）      数组（array）      接口（interface）      枚举（enum）      注解（annotation）      记录（record）</code></pre><p>变量都有其<strong>作用域</strong>，只在其作用域内有效。</p><h3 id="整型">整型</h3><p>byte  short  int  long 分别占用1，2，4，8字节（有正负）。</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>取值范围</th><th>默认值</th></tr></thead><tbody><tr><td><code>byte</code></td><td>1</td><td><code>-128</code> ~ <code>127</code></td><td><code>0</code></td></tr><tr><td><code>short</code></td><td>2</td><td><code>-32,768</code> ~ <code>32,767</code></td><td><code>0</code></td></tr><tr><td><code>int</code></td><td>4</td><td><code>-2,147,483,648</code> ~ <code>2,147,483,647</code></td><td><code>0</code></td></tr><tr><td><code>long</code></td><td>8</td><td><code>-9,223,372,036,854,775,808</code> ~<code>9,223,372,036,854,775,807</code></td><td><code>0L</code></td></tr></tbody></table><ul><li>定义<code>long</code>类型的变量，赋值时需要以“l”或“L”作为后缀。</li><li>Java程序中变量通常声明为<code>int</code>。</li><li>整数常量<strong>默认为int类型</strong>。</li></ul><h3 id="浮点型">浮点型</h3><table><thead><tr><th>数据类型</th><th>字节数</th><th>取值范围</th><th>默认值</th><th>精度</th></tr></thead><tbody><tr><td><code>float</code></td><td>4</td><td><code>±1.4E-45</code> ~ <code>±3.4028235E+38</code></td><td><code>0.0f</code></td><td>约 7 位</td></tr><tr><td><code>double</code></td><td>8</td><td><code>±4.9E-324</code> ~ <code>±1.7976931348623157E+308</code></td><td><code>0.0d</code></td><td>约 15~16 位</td></tr></tbody></table><ul><li>定义<code>float</code>类型的变量，赋值时需要以“f”或“F”作为后缀。</li><li>float的表示范围大于long，但是精度不高。</li><li>Java的浮点型常量<strong>默认为double型</strong>。</li><li>float、double不适用于不容许舍入误差的金融计算领域。如果需要精确数字计算或保留特定位数的精度，需要使用BigDecimal类。</li><li><code>IEEE 754标准</code>仍然不能实现“每一个十进制小数都对应一个二进制小数”，0.1+0.2不等于0.3</li></ul><h3 id="字符型">字符型</h3><ul><li>占用两个字节</li></ul><p>字符型变量的三种表现形式：</p><ol type="1"><li>单引号<code>''</code>适用于<strong>单个字符</strong></li><li>直接使用Unicode值表示。例如<code>char c8 = '\u0043';</code></li><li>使用转义字符''将后面的字符转变为字符型常量。</li><li>ASCII码</li></ol><h3 id="布尔型">布尔型</h3><ul><li>只有两个值：true、false，常常用在流程控制语句。</li><li>可以认为占4个字节（一般不谈布尔类型占用的空间大小）。具体来说：编译时不谈几个字节，但是JVM给boolean类型分配内存空间时，boolean类型的变量占据一个槽位（slot，等于4个字节）。</li></ul><h3 id="基本数据类型间的运算规则">基本数据类型间的运算规则</h3><ol type="1"><li><strong>自动类型提升</strong>：</li></ol><p>规则：容量小的变量与容量大的变量做运算时，结果自动转换为容量大的数据类型。容量指可表示数据范围的大小。</p><p>byte---&gt;short---&gt;int---&gt;long---&gt;float---&gt;double</p><ul><li>特殊情况1：容量小于int做运算结果用int类型，否则报错，而且实际的开发中也基本用不上byte和short。</li><li>特殊情况2：char类型运算结果也用int类型，同上。</li></ul><ol start="2" type="1"><li><strong>强制类型转换</strong></li></ol><p>规则：大范围类型转换为小范围类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)d1;<br><br></code></pre></td></tr></table></figure><h3 id="string类">String类</h3><ol type="1"><li>String类属于引用数据类型，俗称字符串。</li><li>可以使用一对双引号进行赋值。</li></ol><p>String与基本数据类型间的运算：</p><ol type="1"><li>这里可以包含布尔变量在内共8种。</li><li>只能做连接运算，用+。</li></ol><h2 id="运算符">运算符</h2><h3 id="逻辑运算符">逻辑运算符</h3><table><thead><tr><th>逻辑运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与（AND）</td><td>只有两个操作数都为 <code>true</code> 时，结果才为<code>true</code></td><td><code>true &amp;&amp; false</code> → <code>false</code></td></tr><tr><td><code>\|\|</code></td><td>逻辑或（OR）</td><td>只要有一个操作数为 <code>true</code>，结果就为<code>true</code></td><td><code>true \|\| false</code> → <code>true</code></td></tr><tr><td><code>!</code></td><td>逻辑非（NOT）</td><td>取反运算，将 <code>true</code> 变 <code>false</code>，反之亦然</td><td><code>!true</code> → <code>false</code></td></tr><tr><td><code>&amp;</code></td><td>按位与（AND）</td><td>与 <code>&amp;&amp;</code>类似，但<strong>不会发生短路</strong></td><td><code>true &amp; false</code> → <code>false</code></td></tr><tr><td><code>\|</code></td><td>按位或（OR）</td><td>与 <code>\|\|</code> 类似，但<strong>不会发生短路</strong></td><td><code>true \| false</code> → <code>true</code></td></tr><tr><td><code>^</code></td><td>逻辑异或（XOR）</td><td>只有两个操作数不相同时，结果才为 <code>true</code></td><td><code>true ^ false</code> → <code>true</code></td></tr></tbody></table><ul><li>逻辑运算符针对的是布尔型变量，结果也是布尔型。</li><li><code>&amp;&amp;</code>和<code>||</code><strong>具有短路特性</strong>，即在某些情况下可以<strong>提前确定最终结果</strong>，从而跳过后续运算，提高效率并避免不必要的计算。例如，<code>A &amp;&amp; B</code>只有当<code>A</code>为<code>true</code>时，才会计算<code>B</code>，如果<code>A</code>为<code>false</code>，那么结果必然为<code>false</code>，所以<code>B</code>会被直接跳过。对于<code>||</code>则反过来，如果<code>A</code>为<code>true</code>，那么不会计算<code>B</code>。</li></ul><h3 id="位运算符">位运算符</h3><p>难点、非重点</p><table style="width:100%;"><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与（AND）</td><td>两个位都为 <code>1</code>，结果才为 <code>1</code></td><td><code>5 &amp; 3</code> → <code>101 &amp; 011 = 001</code> →<code>1</code></td></tr><tr><td><code>\|</code></td><td>按位或（OR）</td><td>只要有一个位为 <code>1</code>，结果就是 <code>1</code></td><td><code>5 \| 3</code> → <code>101 \| 011 = 111</code> →<code>7</code></td></tr><tr><td><code>^</code></td><td>按位异或（XOR）</td><td>两个位不同则为 <code>1</code>，相同则为 <code>0</code></td><td><code>5 ^ 3</code> → <code>101 ^ 011 = 110</code> →<code>6</code></td></tr><tr><td><code>~</code></td><td>按位取反（NOT）</td><td>0 变 1，1 变 0（取反补码）</td><td><code>~5</code> → <code>~00000101</code> → <code>11111010</code>（即<code>-6</code>）</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移（Left Shift）</td><td>将二进制位左移 <code>n</code> 位，右侧补 <code>0</code></td><td><code>5 &lt;&lt; 2</code> → <code>101</code> → <code>10100</code> →<code>20</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移（Arithmetic Right Shift）</td><td>保持符号位，左侧补 <code>1</code> 或 <code>0</code></td><td><code>-5 &gt;&gt; 2</code> → <code>11111011</code> →<code>11111110</code> → <code>-2</code></td></tr><tr><td><code>&gt;&gt;&gt;</code></td><td>无符号右移（Logical Right Shift）</td><td>左侧统一补 <code>0</code>，不保持符号位</td><td><code>-5 &gt;&gt;&gt; 2</code> → <code>11111011</code> →<code>00111110</code>（即 <code>1073741822</code>）</td></tr></tbody></table><p><strong>案例</strong>：如何交换两个int变量的值？String呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;m=&quot;</span> + m + <span class="hljs-string">&quot;, n=&quot;</span> + n);<br><br>        <span class="hljs-comment">//声明一个临时变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> m;<br>        m = n;<br>        n = temp;<br><br>        System.out.println(<span class="hljs-string">&quot;m=&quot;</span> + m + <span class="hljs-string">&quot;, n=&quot;</span> + n);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件运算符">条件运算符</h3><p>(条件表达式) ? 表达式1 : 表达式2</p><p>条件表达式的结果是布尔类型。</p><h1 id="流程控制">流程控制</h1><h2 id="if-else">if-else</h2><p>与C语言相同，不赘述。</p><p>如何从键盘获取不同类型的变量：使用Scanner类。Scanner类中提供了获取不同类型变量的方法，除了char，需要使用<code>scan.next().charAt(0)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//提供（或创建）一个Scanner类的实例，这里创建了一个Scanner对象sc，用于接收用户的输入</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">//调用Scanner类中的方法，获取指定类型的变量，这里使用nextLine()读取整行文本</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sc.nextLine();<br><br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + s);<br><br>        <span class="hljs-comment">//关闭资源，调用Scanner类的close()</span><br>        scan.close();<br>    &#125;<br>&#125;    <br><br></code></pre></td></tr></table></figure><h2 id="获取随机数">获取随机数</h2><p>可以使用Java提供的API：Math类的random()（不用额外导包），返回一个[0.0,1.0)范围内的double随机数。</p><p>进一步的可以得到其他范围的随机数，例如[0,100]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random()*<span class="hljs-number">101</span>);<br></code></pre></td></tr></table></figure><p>获取一个[a,b]范围的随机数：<code>(int)(Math.random() * (b - a + 1)) + a;</code></p><h2 id="switch-case">switch-case</h2><p>语法格式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br><br>    <span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:<br>        <span class="hljs-comment">//执行语句1</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:<br>        <span class="hljs-comment">//执行语句2</span><br>        <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">//执行语句</span><br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>switch中的表达式只能是特定的数据类型：byte  short  char  int 枚举(JDK5.0新增)  String(JDK7.0新增)</li><li>开发中使用switch-case时，通常case匹配的情况都有限。</li><li>default的位置是灵活的。</li></ul><h2 id="循环语句">循环语句</h2><p>共三种：for,while,do-while</p><p>循环的4个要素：</p><ol type="1"><li>初始化条件</li><li>循环条件</li><li>循环体</li><li>迭代部分</li></ol><h3 id="for循环">for循环</h3><p>for(1;2;4){<br />3<br />}</p><p>迭代部分含有多条语句时，可以用逗号连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        输入两个正整数m和n，求最大公约数和最小公倍数。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> m&lt;n?m:n;<br><br>        <span class="hljs-comment">//最大公约数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=min;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span> &amp;&amp; m%i==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;最大公约数&quot;</span>+i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最小公倍数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> m&gt;n?m:n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=max;i&lt;=m*n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i%m==<span class="hljs-number">0</span> &amp;&amp; i%n==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;最小公倍数为&quot;</span> + i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们可以在循环结构中使用break，用于跳出循环结构。</li><li>循环条件不满足/循环体中执行了break</li></ul><h3 id="while循环">while循环</h3><p>1 while(2){<br />3<br />4<br />}</p><p>练习：猜数字小游戏 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        随机生成一个1到100以内的整数，用户输入一个整数，记录猜了几次才正确</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//生成随机数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomNumber</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>)+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//记录尝试的次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">guessNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//创建对象sc</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//输入数字</span><br>        System.out.println(<span class="hljs-string">&quot;Please enter a number between 1 and 100&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">yourNumber</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-comment">//循环</span><br>        <span class="hljs-keyword">while</span>(yourNumber != randomNumber)&#123;<br>            <span class="hljs-keyword">if</span>(yourNumber &gt; randomNumber)&#123;<br>                System.out.println(<span class="hljs-string">&quot;Your number is greater than random number&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Your number is less than random number&quot;</span>);<br>            &#125;<br>            guessNumber++;<br>            <span class="hljs-comment">//重新输入数字</span><br>            System.out.println(<span class="hljs-string">&quot;Please try again&quot;</span>);<br>            yourNumber = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-comment">//结束游戏</span><br>        System.out.println(<span class="hljs-string">&quot;congratulations!you have tried &quot;</span> + guessNumber + <span class="hljs-string">&quot; guesses&quot;</span>);<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="do-while-循环">do-while 循环</h3><p>1<br />do{<br />3<br />4<br />}while(2);</p><p>执行过程：1 - 3 - 4 - 2 - 3 - 4 - ··· - 2</p><p>至少会执行一次循环体，用得相对来说比较少。</p><h3 id="无限循环结构">“无限”循环结构</h3><p>格式： while(true) 或 for(;;)，中途使用break跳出循环。</p><p>示例：九九乘法表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java">ublic <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        案例：九九乘法表</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>                System.out.print(i + <span class="hljs-string">&quot;*&quot;</span> + j + <span class="hljs-string">&quot;=&quot;</span> + i*j + <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例">案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        案例：找出100000以内的所有质数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100000</span>;i++)&#123;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;Math.sqrt(i);j++)&#123;<br>                <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>)&#123;<br>                    isFlag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isFlag)&#123;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        System.out.println(<span class="hljs-string">&quot;time spend: &quot;</span> + (endTime - startTime));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：<code>time spend: 35</code>，注意这里的Math.sqrt(i)可以大大提升运算速度，因为一个数的因数关于它的算术平方根对称。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为Hexo博客绑定域名出现ERR_SSL_UNRECOGNIZED_NAME_ALERTu错误</title>
    <link href="/2025/01/17/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    <url>/2025/01/17/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近为这个博客网站新绑定了一个域名。因为我先前没有学过计算机网络相关的知识，遇到ERR_SSL_UNRECOGNIZED_NAME_ALERTu的报错的时候反应了半天才明白要去申请一个SSL证书，在此记录一下这次绑定域名的操作流程。</p><h1 id="参考链接">参考链接</h1><p>1.<ahref="https://cps.ninja/2016/10/09/customize-your-blog-domain/">为Github 上的 Hexo 博客绑定个性域名</a></p><p>2.<ahref="https://www.littlelittleblack.com/Hexo/20200508-self-server-url.html">在自架服务器上搭建Hexo博客并绑定域名</a></p><h1 id="操作流程">操作流程</h1><p>我最开始看的是第一个链接，在namesilo上购买一个域名，然后直接使用namesilo进行DNS解析。第一个链接里有一点没有说清楚：A记录的IP地址应当是<code>username.github.io</code>的IP地址，而不是github的地址。对此，github的<ahref="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">官方文档</a>中有详细的说明：</p><p><img src="https://i.imgur.com/ZMUsLHh.png" /></p><p>向DNS解析中加入4个A记录即可。</p><p>当然也可以通过ping的方式获取IP地址。按<code>win</code>+<code>R</code>输入<code>cmd</code>，再输入<code>ping username.github.io</code>，看一下返回的IP即可：</p><p><img src="https://i.imgur.com/OEH8zEM.png" /></p><p>这次返回的是<code>185.199.109.153</code>.</p><h1 id="踩坑">踩坑</h1><p>我按照链接1的步骤操作完成之后，发现新绑定域名后的博客仍无法打开，报错：</p><p><strong>嗯… 无法访问此页面 https://kznep19.blog/上的网页似乎有问题，或者可能已永久移动到新的 Web 地址。ERR_SSL_UNRECOGNIZED_NAME_ALERTu</strong></p><p>向浏览器中输入<code>username.github.io</code>，发现原来的地址也无法访问了。起初我以为是namesilo自带的DNS解析功能无法正常使用（因为namesilo的名声似乎不是很好），所以我仿照链接2将NDS解析转移到国内的DNSPod网站上，发现仍然是同样的报错，说明问题不在这里。</p><p>注意<code>ERR_SSL_UNRECOGNIZED_NAME_ALERTu</code>，对此ChatGPT的回答如下：</p><blockquote><p>ERR_SSL_UNRECOGNIZED_NAME_ALERT 是一个与 SSL/TLS连接相关的错误，通常出现在客户端和服务器进行加密通信时。这种错误表示客户端在请求时提供的主机名（如网址）没有在服务器的证书中正确匹配，或者服务器没有正确配置SSL/TLS 证书。</p></blockquote><p>“没有正确配置 SSL/TLS证书”，我查找资料的过程中没有见到说绑定域名需要单独配置SSL证书的教程。直到我看到了<ahref="https://github.com/lss233/chatgpt-mirai-qq-bot/issues/1146">这个网站</a>，里面提到</p><blockquote><p>浏览器报错 ERR_SSL_UNRECOGNIZED_NAME_ALERT<br />其意为 “错误 SSL 无法识别的名称警报"。应该因为你还未部署SSL证书💦。SSL证书是此服务必须的，去申请一个即可 🙏。</p></blockquote><p>于是我在<ahref="https://ohttps.com/monitor/dashboard">OHTTPS</a>中为这个域名免费申请了一个SSL证书，很快网站就能正常访问了，至此问题终于得到解决。</p><p>另外，不管是OHTTPS还是DNSPod提供的SSL证书发放服务，其免费证书的有效期都只有三个月，快到期的时候要不要忘了更换证书。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>エルマ-ヨルシカ</title>
    <link href="/2025/01/07/Elma/"/>
    <url>/2025/01/07/Elma/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>雨とカプチーノ - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p><hr /><p>朝日の差す木漏れ日　僕とエルマ</p><p>まだ　まだ眠いかい</p><p>初夏の初め近づく五月の森</p><hr /><p>歩きだした顔には花の雫</p><p>ほら　涙みたいだ</p><p>このまま欠伸をしよう</p><p>なんならまた椅子にでも座ろう</p><hr /><p>許せないことなんてないんだよ</p><p>君は優しくなんてなれる</p><hr /><p>このまま何処かの遠い国で</p><p>浅い夏の隙間に寝そべったまま</p><p>涙も言葉も出ないままで</p><p>ただ夜の深さも知らないままで</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p><hr /><p>辛いことも苦しいことも何も見えないならわからないし</p><p>塞いだ目閉じたままで逃げた</p><p>月明かりの道を歩く</p><hr /><p>狭い部屋も冷たい夜も</p><p>眠い昼も　寂しい朝も</p><p>さよならの言葉越しに君の顔を見てる</p><hr /><p>このまま何処かの遠い国で</p><p>浅い夏の隙間に寝そべったまま</p><p>涙も言葉も出ないままで</p><p>ただ空の青さだけ見たままで</p><hr /><p>ただ君と終わりも知らないままで</p><hr /><p>噓つきなんて　わかって　触れて</p><p>エルマ　まだ　まだ痛いよ</p><p>もうさよならだって歌って</p><p>暮れて夜が来るまで</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>少女A</title>
    <link href="/2025/01/05/%E5%B0%91%E5%A5%B3A/"/>
    <url>/2025/01/05/%E5%B0%91%E5%A5%B3A/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>神様のダンス - ヨルシカ</p><p>作詞：椎名もた（ぽわぽわP）</p><p>作曲：椎名もた（ぽわぽわP）</p><p>唄：鏡音リン</p><p>中文翻譯：https://home.gamer.com.tw/artwork.php?sn=5816671</p><hr /><p>僕の命ってったって　誰の命っつったって</p><p>即使說這是我的生命　即使說這是他人的生命</p><p>時々　公平に　裁かれるもんなんでしょ</p><p>偶爾　也會被公平地　受到裁決對吧</p><p>暗い空にやってきた　鬱を連れてやってきた</p><p>我抵達了漆黑的天空　並帶來了憂愁</p><p>時々雨　総計に　頼り切りだ　どうしよう</p><p>偶爾下起了雨　我總是　依賴著它　該怎麼辦呢</p><p>朽ちるまでの愛憎を　朽ちるまでの愛憎を</p><p>接受枯朽之前的愛憎　枯朽之前的愛憎的你</p><p>飲み込む君　簡単に　微笑む君　どうして</p><p>簡單地　露出微笑的你　為什麼</p><p>言葉を書く　曖昧に　言葉を書く　曖昧に</p><p>曖昧地　書寫著話語　曖昧地　書寫著話語</p><p>伝わりきらんないから　君だけをさ　信じて</p><p>因為根本無法全數傳達出去啊　所以我只　相信你一人</p><p>捨ててきた夢をあつめて</p><p>我開始收集起之前我所捨棄的夢想</p><p>ちょっと　ちょっと　間違えたから</p><p>因為這其中有些　有些　錯誤啊</p><p>ああ　「時に　時に　躓いたって、」</p><p>啊啊　「即使偶爾　偶爾　受到挫折、」　也還是</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い　言い寄らないで</p><p>好冷好冷好冷好冷　別如此求愛啊</p><p>ああ　君の君の君の声が</p><p>啊啊　你的你的你的聲音十分</p><p>遠い遠い遠い遠い遠い</p><p>遙遠遙遠遙遠遙遠遙遠</p><p>遠い遠い遠い遠い遠い</p><p>遙遠遙遠遙遠遙遠遙遠</p><p>遠い遠い遠い遠い　傷つけないで</p><p>遙遠遙遠遙遠遙遠　別傷害我啊</p><p>何番目でも　何番目でも</p><p>不管是第幾個　不管是第幾個</p><p>僕が僕であるために？</p><p>我也希望我能保有自我？</p><p>契り集め持ってきた　契り集め持ってきた</p><p>我收集起來各種約定　我收集起來各種約定</p><p>あの日の間違いを　飲み込むのが苦るしくて</p><p>要理解那一天的誤會　實在是過於痛苦</p><p>朽ちるまでの愛憎を　朽ちるまでの愛憎を</p><p>接受枯朽之前的愛憎　枯朽之前的愛憎的你</p><p>飲み込む君　簡単に　微笑む君　どうして</p><p>簡單地　露出微笑的你　為什麼</p><p>「子供だましの花ふたつ、」</p><p>「欺騙小孩的兩束花、」</p><p>きっと　きっと　諦めたから？</p><p>一定　一定是因為　我放棄了？</p><p>ああ　遠い夢を追いかけてさ</p><p>啊啊　我追趕著遙遠的夢想　但夢想卻十分</p><p>早い早い早い早い早い</p><p>快速快速快速快速快速</p><p>早い早い早い早い早い</p><p>快速快速快速快速快速</p><p>早い早い早い早い　追いつけないよ</p><p>快速快速快速快速　我根本無法追上啊</p><p>捨てきれず残した思いが</p><p>我無法完全捨棄並遺留下來的感受讓人十分</p><p>憎い憎い憎い憎い憎い</p><p>憎恨憎恨憎恨憎恨憎恨</p><p>憎い憎い憎い憎い憎い</p><p>憎恨憎恨憎恨憎恨憎恨</p><p>憎い憎い憎い憎い　許されないの？</p><p>憎恨憎恨憎恨憎恨　不被他人原諒嗎？</p><p>ああ　夢を夢を見てたはずが</p><p>啊啊　我本應該正在做夢　但卻感到了</p><p>怖い怖い怖い怖い怖い</p><p>恐懼恐懼恐懼恐懼恐懼</p><p>怖い怖い怖い怖い怖い</p><p>恐懼恐懼恐懼恐懼恐懼</p><p>怖い怖い怖い怖い　近づかないで</p><p>恐懼恐懼恐懼恐懼　別靠近我啊</p><p>合言葉を繰り返すだけ</p><p>我只是不斷重複著暗語而已</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い寒い</p><p>好冷好冷好冷好冷好冷</p><p>寒い寒い寒い寒い　お願いだから</p><p>好冷好冷好冷好冷　拜託你</p><p>何番目でも　何番目でも</p><p>不管是第幾個　不管是第幾個</p><p>僕が僕であるために…</p><p>我也希望我能保有自我…</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>雨とカプチーノ - ヨルシカ</title>
    <link href="/2024/12/30/%E9%9B%A8%E3%81%A8%E3%82%AB%E3%83%97%E3%83%81%E3%83%BC%E3%83%8E%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/12/30/%E9%9B%A8%E3%81%A8%E3%82%AB%E3%83%97%E3%83%81%E3%83%BC%E3%83%8E%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>雨とカプチーノ - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>灰色に白んだ言葉はカプチーノみたいな色してる</p><p>言い訳はいいよ　窓辺に置いてきて</p><p>数え切れないよ</p><hr /><p>灰色に白んだ心はカプチーノみたいな色をしてる</p><p>言い訳はいいよ　<ruby>呷<rt>あお</rt></ruby>ろうカプチーノ</p><p><ruby>戯<rt>おど</rt></ruby>けた振りをして</p><hr /><p>さぁ<ruby>揺蕩<rt>たゆた</rt></ruby>うように雨流れ</p><p>僕らに<ruby>嵐<rt>あら</rt></ruby>す花に溺れ</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないような思い出を</p><p>どうか、どうか、どうか君が溢れないように</p><hr /><p><ruby>波<rt>なみ</rt></ruby>待つ海岸　<ruby>紅<rt>くれない</rt></ruby>夕差す日</p><p>窓に反射して</p><p>八月のヴィスビー　<ruby>潮騒<rt>しおさい</rt></ruby></p><p>待ちぼうけ　海風一つで</p><hr /><p>夏泳いだ花の白さ、<ruby>宵<rt>よい</rt></ruby>の雨</p><p>流れる夜に溺れ</p><p>誰も褪せないような花一つ</p><p>どうか、どうか、どうか胸の内側に挿して</p><hr /><p>ずっとおかしいんだ</p><p>生き方一つを教えてほしいだけ</p><p>払えるものなんて僕にはもうないけど</p><p>何も答えられないなら言葉一つでもいいよ</p><p>わからないよ</p><p>本当にわからないんだよ</p><hr /><p>さぁ<ruby>揺蕩<rt>たゆた</rt></ruby>うように雨流れ</p><p>僕らに<ruby>嵐<rt>あら</rt></ruby>す花に溺れ</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないように書く詩を</p><p>どうか、どうか、どうか今も忘れないように</p><p>また一つ夏が終わって、花一つを胸に抱いて、</p><p>流れる<ruby>目蓋<rt>まぶた</rt></ruby>の裏で</p><p>君が<ruby>褪<rt>あ</rt></ruby>せないようにこの詩を</p><p>どうか、どうか君が溢れないように</p><hr />]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神様のダンス - ヨルシカ</title>
    <link href="/2024/12/27/%E7%A5%9E%E6%A7%98%E3%81%AE%E3%83%80%E3%83%B3%E3%82%B9%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/12/27/%E7%A5%9E%E6%A7%98%E3%81%AE%E3%83%80%E3%83%B3%E3%82%B9%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>神様のダンス - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><hr /><p>忘れるなんて酷いだろ</p><p>幸せになんてなるものか</p><p>色のない何かが咲いた</p><p>君のいない夏に咲いた</p><hr /><p>人に笑われたくないから</p><p>怯えるように下を向く</p><p>心より大事な何かが</p><p>あってたまるものか</p><hr /><p>暮れない夕に茜追い付いて</p><p>君を染め抜いた</p><p>見えないように僕を追い越して</p><p>行かないで</p><hr /><p>僕たち神様なんて知らん顔</p><p>どこまでだって行ける</p><p>なぁ、心まで醜い僕らだ</p><p>世界は僕らのものだ</p><hr /><p>音楽だけでいいんだろ</p><p>他人に合わせて歩くなよ</p><p>教えてくれたのはあんたじゃないか</p><hr /><p>どうだっていいよ、このまま遠くへ</p><p>誰も知らない場所で月明かりを探すのだ</p><hr /><p>名もない花が綺麗のだ</p><p>どうでもいいことばっかだ</p><p>君の口癖が感染ってる</p><p>喉の真下には君がいる</p><hr /><p>言葉も生活も愛想も</p><p>全て捨ててこそ音楽だ</p><p>その価値も知らないあんたに</p><p>わかって堪るものか</p><hr /><p>暮れない夕に茜追い付いて</p><p>僕を染め抜いた</p><p>いつか時間が全て追い抜いて</p><p>消えないで</p><hr /><p>僕たち神様なんて知らん顔</p><p>世界の全部が欲しい</p><p>なぁ心まで醜いあんたの、想い出全部をくれよ</p><p>価値観だって自由なら</p><p>人を傷付けていいだろ</p><p>教えなかったのはあんたじゃないか</p><hr /><p>どうだっていいよ、このまま遠くへ</p><p>誰も見てない場所で生きる真似をしてるのさ</p><p>酷い顔で踊るのさ</p><p>胸も痛いままで</p><hr /><p>神様僕たちなんて知らん顔</p><p>どこまでだって行ける</p><p>なぁ、言葉が世界だと云うなら、世界は僕らのものだ</p><p>忘れるなんて酷いだろ</p><p>幸せになんてなれるかよ</p><p>僕を歪めたのはあんたじゃないか</p><hr /><p>そうだった、僕はこのまま遠くへ</p><p>誰も知らない場所で月明かりを探すのだ</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HDLBits刷题笔记</title>
    <link href="/2024/11/28/Verilog/"/>
    <url>/2024/11/28/Verilog/</url>
    
    <content type="html"><![CDATA[<p>最近试了一下Verilog刷题网站HDLBits，感觉还是蛮有意思的。这里记录一下刷题的一些收获。</p><h2 id="bit-slicing的简化语法">Bit slicing的简化语法</h2><p><em><strong>Bit slicing</strong> ("Indexed vector part select", sinceVerilog-2001) has an even more compact syntax.</em></p><p>来源：Circuits-Multiplexers-Mux256to1v</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1023</span>:<span class="hljs-number">0</span>] in,   <span class="hljs-comment">// 1024-bit input</span><br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] sel,      <span class="hljs-comment">// 8-bit select input</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] out      <span class="hljs-comment">// 4-bit output</span><br>);<br><br>    <span class="hljs-keyword">assign</span> out = in[sel*<span class="hljs-number">4</span> +: <span class="hljs-number">4</span>];  <span class="hljs-comment">// Compact syntax for bit slicing</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p><code>in[sel*4 +: 4]</code> 是 Verilog-2001 中引入的 “indexed partselect” 语法：<br /><code>sel*4</code> 表示选择从哪个位开始（包含该位）。<br /><code>+: 4</code>表示从 sel*4 开始，选择 4 位宽的数据。<br />这个语法非常简洁，并且可以避免合成工具无法推断切片宽度为常数的问题。</p><p>类似的还有<code>assign out = in[sel*4+3 -: 4];</code></p><h2 id="加法器">加法器</h2><p><em>Create a 100-bit binary adder. The adder adds two 100-bit numbersand a carry-in to produce a 100-bit sum and carry out.</em></p><p><strong>正解：没有必要重新构造全加器模块了，直接使用现有的运算符号。</strong><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br><span class="hljs-keyword">input</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] a,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] b,<br><span class="hljs-keyword">input</span> cin,<br><span class="hljs-keyword">output</span> cout,<br><span class="hljs-keyword">output</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] sum<br>);<br><br><span class="hljs-comment">// The concatenation &#123;cout, sum&#125; is a 101-bit vector.</span><br><span class="hljs-keyword">assign</span> &#123;cout, sum&#125; = a+b+cin;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure></p><h2 id="卡诺图的两种形式">卡诺图的两种形式</h2><p>77.<em>A single-output digital system with four inputs (a,b,c,d)generates a logic-1 when 2, 7, or 15 appears on the inputs, and alogic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The inputconditions for the numbers 3, 8, 11, and 12 never occur in this system.For example, 7 corresponds to a,b,c,d being set to 0,1,1,1,respectively.</em></p><p><em>Determine the output out_sop in minimum SOP form, and the outputout_pos in minimum POS form.</em></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">input</span> b,<br>    <span class="hljs-keyword">input</span> c,<br>    <span class="hljs-keyword">input</span> d,<br>    <span class="hljs-keyword">output</span> out_sop,<br>    <span class="hljs-keyword">output</span> out_pos<br>); <br>    <span class="hljs-keyword">assign</span> out_sop = (c&amp;d) | (~a&amp;~b&amp;c&amp;~d);<br>    <span class="hljs-keyword">assign</span> out_pos = c &amp; (~b|d) &amp; (~a|d);<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="dff8">Dff8</h2><p><em>Create 8 D flip-flops. All DFFs should be triggered by thepositive edge of clk.</em></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br><span class="hljs-keyword">input</span> clk,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q);<br><br><span class="hljs-comment">// Because q is a vector, this creates multiple DFFs.</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<br>q &lt;= d;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>因为q在这里是一个向量，所以可以一次性创建出8个D触发器。</p><h2 id="异步复位">异步复位</h2><p>异步复位和同步复位相比，唯一的区别在于always的敏感列表中包含了复位信号reset。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br><span class="hljs-keyword">input</span> clk,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] d,<br><span class="hljs-keyword">input</span> areset,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] q);<br><br><span class="hljs-comment">// The only difference in code compared to synchronous reset is in the sensitivity list.</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk, <span class="hljs-keyword">posedge</span> areset)<br><span class="hljs-keyword">if</span> (areset)<br>q &lt;= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>q &lt;= d;<br><br><br><span class="hljs-comment">// In Verilog, the sensitivity list looks strange. The FF&#x27;s reset is sensitive to the</span><br><span class="hljs-comment">// *level* of areset, so why does using &quot;posedge areset&quot; work?</span><br><span class="hljs-comment">// To see why it works, consider the truth table for all events that change the input </span><br><span class="hljs-comment">// signals, assuming clk and areset do not switch at precisely the same time:</span><br><br><span class="hljs-comment">//  clkaresetoutput</span><br><span class="hljs-comment">//   x 0-&gt;1q &lt;= 0; (because areset = 1)</span><br><span class="hljs-comment">//   x 1-&gt;0no change (always block not triggered)</span><br><span class="hljs-comment">//  0-&gt;1   0q &lt;= d; (not resetting)</span><br><span class="hljs-comment">//  0-&gt;1   1q &lt;= 0; (still resetting, q was 0 before too)</span><br><span class="hljs-comment">//  1-&gt;0   xno change (always block not triggered)</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="problem-85-dff-with-byte-enabledff16e">Problem 85 : DFF withbyte enable(Dff16e)</h2><p><em>Create 16 D flip-flops. It's sometimes useful to only modifyparts of a group of flip-flops. The byte-enable inputs control whethereach byte of the 16 registers should be written to on that cycle.byteena[1] controls the upper byte d[15:8], while byteena[0] controlsthe lower byte d[7:0].</em></p><p><em>resetn is a synchronous, active-low reset.</em></p><p><em>All DFFs should be triggered by the positive edge ofclk.</em></p><p>这道题的要求是创建一个 16 路D触发器。部分情况下，只需要多路触发器中的一部分触发器工作，此时可以通过ena 使能端进行控制。使能端 ena 信号有效时，触发器在时钟上升沿工作。</p><p><strong>注意：当byteena=2'b11时，两个部分均可被写入，因此要慎重选择if~else的结构</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> resetn,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] byteena,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] d,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] q<br>);<br><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(~resetn)<br>            q &lt;= <span class="hljs-number">16&#x27;b0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(byteena[<span class="hljs-number">1</span>] || byteena[<span class="hljs-number">0</span>] ) <span class="hljs-keyword">begin</span><span class="hljs-comment">//注意这个地方要兼顾2&#x27;b11的情况</span><br>        <span class="hljs-keyword">if</span>(byteena[<span class="hljs-number">1</span>])<br>            q[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>] &lt;= d[<span class="hljs-number">15</span>:<span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">if</span>(byteena[<span class="hljs-number">0</span>])<br>            q[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] &lt;= d[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>            <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="边沿捕获">边沿捕获</h2><p>96.当reset信号为高时，强制输出为低电平；当输入信号in出现下降沿时，输出out保持为1，也就是说只有reset能将out拉低。</p><p><img src="https://i.imgur.com/0iKObkG.png" /></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out<br>);<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] temp;<br>    <br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <br>        temp &lt;= in;<span class="hljs-comment">//record the previous state.</span><br>        <br>        <span class="hljs-keyword">if</span>(reset)<br>            out &lt;= <span class="hljs-number">32&#x27;b0</span>;<br>        <span class="hljs-keyword">else</span><br>            out = (temp &amp; ~in) | (out);<span class="hljs-comment">//这里是关键，|out 保证了原来是1的位仍保持为1</span><br>    <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="双边沿触发器">双边沿触发器</h2><p>Verilog的always语句块的敏感变量列表不能同时支持posedge和negedge，自己单独搭建电路实现双边沿触发的功能。</p><p>时序图如下：</p><p><img src="https://i.imgur.com/iMKGS2u.png" /></p><p>利用二选一数据选择器的实现思路：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> d,<br>    <span class="hljs-keyword">output</span> q<br>);<br>    <span class="hljs-keyword">reg</span> q1, q2;<br>    <span class="hljs-comment">//这里来实现clk的上升沿与下降沿</span><br>    <span class="hljs-keyword">assign</span> q = clk?q1:q2;<br><br>    <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk)<br>        <span class="hljs-keyword">begin</span><br>            q1 &lt;= d;<br>        <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">negedge</span> clk)<br>        <span class="hljs-keyword">begin</span><br>           q2 &lt;= d; <br>        <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="暂停计数器">暂停计数器</h2><p>Problem 101 Slow decade counter</p><p>在时钟上升沿对0~9递增计数，高电平复位，当slowena为低时暂停计数。</p><p><img src="https://i.imgur.com/tBfNOqY.png" /></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> slowena,<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] q);<br>   <br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(reset)<br>            q &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slowena)<span class="hljs-comment">//the counter can increment only when slowena is &#x27;1&#x27;</span><br>            <span class="hljs-keyword">begin</span><br>                <span class="hljs-keyword">if</span> (q == <span class="hljs-number">4&#x27;d9</span>)   <span class="hljs-comment">//counter overflow</span><br>                    q &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>                <span class="hljs-keyword">else</span>             <span class="hljs-comment">//normal counting</span><br>                    q &lt;= q + <span class="hljs-number">1&#x27;b1</span>;<br>            <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="problem-104-4-digit-decimal-counter">Problem 104 4-digit decimalcounter</h2><p><em>Build a 4-digit BCD (binary-coded decimal) counter. Each decimaldigit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is thetens digit, etc. For digits [3:1], also output an enable signalindicating when each of the upper three digits should beincremented.</em></p><p><em>You may want to instantiate or modify some one-digit decadecounters.</em></p><p>这道题要求我们设计一个四位BCD码计数器。由于每一位BCD码要用4位二进制数表示，因此输出为16位二进制数。基本思路是先建立一个一位BCD码计数器的基本单元，再实例化得到4位的。</p><p>个人觉得这里比较难搞的地方是怎么处理进位。在组合逻辑电路中，4位BCD码加法器的进位只需要把低位端的进位输出连接到高位的进位输入即可。对于时序逻辑来说，进位也可以理解为<strong>使能</strong>，计数可以理解为<strong>翻转</strong>，只有当计数溢出时才使能一次高位，使高位在时钟信号到来的时候翻转一次。</p><p>以T触发器构成的计数器为例，T触发器有以下特征：</p><ul><li>当使能信号T=1时，每次触发会使输出翻转；</li><li>当使能信号T=0时，输出保持不变；</li></ul><p>计数器在递增计数的过程中，计数值的变化体现为位的翻转，低位对高位的影响体现在只有当低位全为1时高位才可翻转（进位），用激励方程来描述就是</p><p><img src="https://i.imgur.com/TKEXS3Q.png" /></p><p>对应的硬件电路为</p><p><img src="https://i.imgur.com/TToOypW.png" /></p><p>对于BCD计数器来说也是一样的道理。4位BCD计数器由4个BCD技术单元组成，每一个单元都有使能端，以最高位为例，只有当四位BCD的低三位全为<code>4'b1001</code>时，最高位才被使能，这只需要用与门就可以实现，类似上图中的G1,G2,G3。用Verilog来描述的话，可以是<code>.ena(q[11:8] == 4'd9 &amp;&amp; q[7:4] == 4'd9 &amp;&amp; q[3:0] == 4'd9),</code>或者直接写为<code>.ena(q[11:0] == 12'h999),</code>，二者是等价的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset,   <span class="hljs-comment">// Synchronous active-high reset</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">1</span>] ena,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] q);<br><br>    BCDadd counter0 (<br>        <span class="hljs-variable">.reset</span>(reset),<br>        <span class="hljs-variable">.ena</span>(<span class="hljs-number">1&#x27;b1</span>),<br>        <span class="hljs-variable">.clk</span>(clk),<br>        <span class="hljs-variable">.q</span>(q[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>])<br>    );<br>    BCDadd counter1 (<br>        <span class="hljs-variable">.reset</span>(reset),<br>        <span class="hljs-variable">.ena</span>(q[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">4&#x27;b1001</span>),<br>        <span class="hljs-variable">.clk</span>(clk),<br>        <span class="hljs-variable">.q</span>(q[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>])<br>    );    <br>    BCDadd counter2 (<br>        <span class="hljs-variable">.reset</span>(reset),<br>        <span class="hljs-variable">.ena</span>(q[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">8&#x27;h99</span>),<br>        <span class="hljs-variable">.clk</span>(clk),<br>        <span class="hljs-variable">.q</span>(q[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>])<br>    );    <br>    BCDadd counter3 (<br>        <span class="hljs-variable">.reset</span>(reset),<br>        <span class="hljs-variable">.ena</span>(q[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">12&#x27;h999</span>),<br>        <span class="hljs-variable">.clk</span>(clk),<br>        <span class="hljs-variable">.q</span>(q[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>])<br>    );        <br>    <br>    <span class="hljs-keyword">assign</span> ena[<span class="hljs-number">3</span>:<span class="hljs-number">1</span>] = &#123;q[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]==<span class="hljs-number">12&#x27;h999</span>, q[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">8&#x27;h99</span>, q[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] == <span class="hljs-number">4&#x27;b1001</span>&#125;;<br>   <br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> BCDadd (<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">input</span> ena,<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] q<br>);<br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span> (reset)<br>            q &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ena) <span class="hljs-keyword">begin</span><br>            <span class="hljs-keyword">if</span> (q == <span class="hljs-number">4&#x27;b1001</span>)<br>                q &lt;= <span class="hljs-number">4&#x27;b0</span>;<br>            <span class="hljs-keyword">else</span> <br>                q &lt;= q + <span class="hljs-number">1&#x27;b1</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h2 id="lfsr">LFSR</h2><p>Linear-feedback shift register，线性反馈移位寄存器 未完待续</p><p><img src="https://i.imgur.com/yZmHE3W.png" /></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module (<br><span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] SW,      <span class="hljs-comment">// R</span><br><span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] KEY,     <span class="hljs-comment">// L and clk</span><br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] LEDR<br>    );  <span class="hljs-comment">// Q</span><br><br>    <span class="hljs-keyword">wire</span> clk = KEY[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">wire</span> l = KEY[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] d = l ? SW : &#123;LEDR[<span class="hljs-number">1</span>]^LEDR[<span class="hljs-number">2</span>],LEDR[<span class="hljs-number">0</span>],LEDR[<span class="hljs-number">2</span>]&#125;;<br>    <br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>            LEDR &lt;= d;<br>    <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="rule-90">Rule 90</h2><p>Rule90是一种一维“元胞自动机”（cellularautomaton），在每个时间步骤，每个细胞的下一个状态是它两个当前邻居的异或（XOR）值。</p><p><em>In this circuit, create a 512-cell system (q[511:0]), and advanceby one time step each clock cycle. The load input indicates the state ofthe system should be loaded with data[511:0]. Assume the boundaries(q[-1] and q[512]) are both zero (off).</em></p><p>官方解答：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module(<br><span class="hljs-keyword">input</span> clk,<br><span class="hljs-keyword">input</span> load,<br><span class="hljs-keyword">input</span> [<span class="hljs-number">511</span>:<span class="hljs-number">0</span>] data,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">511</span>:<span class="hljs-number">0</span>] q);<br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span> (load)<br>q &lt;= data;<span class="hljs-comment">// 给D触发器赋值</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br><span class="hljs-comment">// 在每个时钟周期，D触发器储存的值变成它的左右邻居的异或值</span><br><span class="hljs-comment">// 因此对每一位进行的操作是相同的</span><br><span class="hljs-comment">// 这可以用数组很简单地表达出来</span><br><span class="hljs-comment">// 使用部分选择和连接符描述移位操作</span><br>q &lt;= &#123;<span class="hljs-number">1&#x27;b0</span>,q[<span class="hljs-number">511</span>:<span class="hljs-number">1</span>]&#125; ^ &#123;q[<span class="hljs-number">510</span>:<span class="hljs-number">0</span>], <span class="hljs-number">1&#x27;b0</span>&#125; ;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>0</th><th>q[511]</th><th>q[510]</th><th>…</th><th>q[2]</th><th>q[1]</th></tr></thead><tbody><tr><td>q[510]</td><td>q[509]</td><td>q[508]</td><td>…</td><td>q[0]</td><td>0</td></tr></tbody></table><p>可以看出每来一个时钟沿，q的每一位都会变成相邻两位的异或。</p>]]></content>
    
    
    <categories>
      
      <category>EE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>レプリカント - ヨルシカ</title>
    <link href="/2024/11/25/%E3%83%AC%E3%83%97%E3%83%AA%E3%82%AB%E3%83%B3%E3%83%88%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/"/>
    <url>/2024/11/25/%E3%83%AC%E3%83%97%E3%83%AA%E3%82%AB%E3%83%B3%E3%83%88%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>レプリカント - ヨルシカ</p><p>詞：n-buna</p><p>曲：n-buna</p><p>編曲：n-buna</p><p>君は映画をずっと観ている<br />在空无一人的劇場之中</p><p>誰一人もない劇場で<br />你一个人独自看着電影</p><p>今思えばチープなセットで<br />那是部現在看来布景廉价</p><p>人のよく死ぬSF映画<br />常有人死去的科幻電影</p><p>いつか世界が真面になって<br />如果将来世界能變得積極美好</p><p>人の寿命さえ随分伸びて<br />人的寿命也无限延長</p><p>死ねない世界になればいいのにね<br />可以不用經歷死亡就好了</p><p>そしたら心以外は偽物だ<br />這樣一来 除了真心其余皆是虚假的</p><p>言葉以外は偽物だ<br />除了話語其余皆是虚假的</p><p>神様だって作品なんだから<br />因為神明也不過是个作品罷了</p><p>僕ら皆レプリカだ<br />我們全都是複製品</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>冷たくなって年老いて<br />天气轉冷 年華逝去</p><p>その時に<br />届時</p><hr /><p>僕は映画をずっと観ている<br />我一直在看着一部電影</p><p>つまらないほどに薄い映画<br />一部庸俗到无聊的電影</p><p>席を立ってからやっと気付く<br />起身离席時我才終于發現</p><p>これは僕を描いたドラマだ<br />劇情所講述的正是我自己的故事啊</p><p>いつか僕らは大人になって<br />我們終将長大成人</p><p>手に入れるものも大きくなった<br />所獲之物也日益重大</p><p>次は愛でも買えればいいのにね<br />接下来要是連愛也能買到就好了呢</p><p>あんたの価値観なんて偽物だ<br />你的価値観全都是虚假的</p><p>思い出だって偽物だ<br />連回憶也全都是虚假的</p><p>心は腦の信号なんだから<br />因為心思不過是大腦傳輸的信号罷了</p><p>愛も皆レプリカだ<br />所有的愛也全都是複製品</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>思い出ばかりが募って<br />只有回憶靜靜堆積</p><p>その時に<br />届時</p><hr /><p>満たされるならそれで良かった<br />只要能感到滿足就好</p><p>歌を歌うのに理由も無いは<br />歌唱并不需要理由</p><p>他人の為に生きられない<br />我不会為他人而活</p><p>さよなら以外全部塵<br />离别以外 全部如塵</p><p>人を呪う歌を描きたい<br />想譜寫出詛咒他人的歌</p><p>それで誰かを殺せればいいぜ<br />若是能借此取人性命就好了</p><p>夏の匂いに胸が詰まっていた<br />夏日的气息郁結滿懷</p><p>僕らの心以外は偽物だ<br />除了我們的心其余皆是虚假的</p><p>言葉以外は偽物だ<br />除了話語其余皆是虚假的</p><p>この世の全部は主観なんだから<br />因為世界全凭主觀而存在啊</p><p>君も皆レプリカだ<br />你也同樣是複製品</p><p>さよならだって投げ出して<br />豁出一切道别离开</p><p>このまま遠く逃げ出して<br />就這樣逃向遠方</p><p>言葉で全部表して<br />用語言来表述一切</p><p>心も愛も書き足して<br />添注上真心与愛</p><p>それでも空は酷く青いんだから<br />因為即便如此 天空仍是无可比擬的蔚藍</p><p>それはきっと魔法だから<br />那一定是魔法</p><p>いつか季節が過ぎ去って<br />終有一天季節会流逝而過</p><p>冷たくなって年老いて<br />天气轉冷 年華逝去</p><p>その時にやっとわかる<br />届時才終于明白</p><p>僕もその青さがわかる<br />我也懂得那份蔚藍</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>锁相环CD4046使用心得</title>
    <link href="/2024/11/23/%E9%94%81%E7%9B%B8%E7%8E%AFCD4046%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/2024/11/23/%E9%94%81%E7%9B%B8%E7%8E%AFCD4046%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<figure><img src="https://i.imgur.com/ZpUo6qu.jpg" alt="成品" /><figcaption aria-hidden="true">成品</figcaption></figure><h1 id="前言">前言</h1><p>最近在忙着做校队招新的题目，要求是用锁相环CD4046B做一个倍频器，倍频系数为1，2，4，8，16，32，64。这个题最烦人的地方在于覆盖的频率范围很大，输入信号范围是1kHz~100kHz，这样来算输出最大要达到6.4MHz，然而以CD4046B来说这根本不可能，因为这款锁相环上集成的VCO的输出频率最大也就1MHz左右：</p><p><img src="https://i.imgur.com/51pBwa3.png" /></p><p>如你所见，输出最大频率的典型值为<strong>1.4MHz</strong>，这也基本符合我实测的结果。总之这题做满100kHz的64倍频基本是没戏了，但是听说有个组做到了7MHz？搞不懂是什么情况。（再吐槽一句，TI的CD4046B的数据手册真的太古老了啊，赶紧更新一下吧）</p><h1 id="引脚说明">引脚说明</h1><p><img src="https://i.imgur.com/Z91APjn.png" /></p><p>见上图。</p><ul><li>3；鉴相器输入</li><li>4：VCO输出</li><li>6、7之间的<spanclass="math inline">\(C_1\)</span>是VCO的起振电容</li><li>12脚<spanclass="math inline">\(R_2\)</span>决定了输出频率是否叠加一个偏置。如果不接，那么输出无偏置，频率就可以达到比较低的范围；如果接上电阻，频率范围整体会往上移动。</li><li>11脚<spanclass="math inline">\(R_1\)</span>也影响了输出频率·范围，R1越小输出频率越大，我这里取的是10k欧。</li><li>5脚禁止端，低电平使能器件。</li><li>13，鉴相器2的输出，它接入环路滤波器的输入端。</li><li>9，VCO的输入，这个输入电压应当尽可能平稳，这样VCO才会有稳定的输出。</li></ul><p>我这次在调试电路过程中动的最多的就是C1和引脚，4。通过调整C1的值来获得不同的频率输出范围；将3、4直接连接来测试锁相环的功能；确定锁相环能正常工作后再把3、4断开，接入分频器。</p><h1 id="频率范围">频率范围</h1><p>CD4046B的输出频率与供电电压有关，供电电压越大，能够输出的频率也越大，但是不能超过15V。根据我的测试，在5V供电，R2不接，R1=10k欧，C1=100pF的情况下，VCO的输出频率最多只有大约700kHZ。想达到1MHz以上的频率必须增大电压到10V，但是这又会产生一问题：锁相环是10V电平输入输出，而分频器是5V电平，两种电平并不互容，必须进行<strong>电平转换</strong>。这是我们组在昨天得到的结论，然后今天我自己花了半个上午的时间才总算是调好了。为了能够覆盖从1kHz~1MHz的频率范围，我切换了三个电容：</p><table><thead><tr><th>100pF</th><th>4.7nF</th><th>3.3nF</th></tr></thead><tbody><tr><td>41k~1.2M</td><td>2k~40k</td><td>1k~29k</td></tr></tbody></table><p>注意这里的频率应当是<strong>倍频后最终输出的频率</strong>。</p><h1 id="电平转换">电平转换</h1><p>这里的电平转换，具体来说：</p><ul><li>锁相环VCO输出的10V方波要被转换为5V方波</li><li>分频器输出的5V方波要被转换为10V方波</li></ul><p>LTspice仿真结果如下：</p><p><img src="https://i.imgur.com/3vQpjKX.png" /></p><p>高电平转低电平用的是左边那个电路，其实就是一个反相器。需要注意的是上拉电阻R1不要取得太大，不然上升沿过于缓慢，适应不了1MHz。而且这个电路实际测试的时候输出在下降沿的振铃非常大，大概是杂散电容和寄生电感的影响（毕竟是焊接到洞洞板上的）。</p><p>低电平转高电平用的是右边的电路，因为左边的电路这时候就不能用了。</p><h1 id="环路滤波器">环路滤波器</h1><p>这是锁相环相当重要的一环。环路滤波器的职责就是将鉴相器输出的高频分量尽可能地滤干净。网上关于环路滤波器的设计方法资料并不是很多，可以参见该博客：<ahref="https://www.cnblogs.com/qm1412/p/18222379">锁相环学习---CD4046</a></p><p>环路滤波器有专用的设计软件，但是非常古老，必须再下载一个XP系统的虚拟机，非常麻烦，所以我就直接使用博客里设计好的电路了：</p><p><img src="https://i.imgur.com/yCQpeqy.jpg" /></p><p>LTspice仿真得到其幅频响应和相频响应如下：</p><p><img src="https://i.imgur.com/LWBPZIo.png" /></p><p>实测这个滤波器可以用于1kHz~1MHz的范围。</p><h1 id="对vco输出进行整形">对VCO输出进行整形</h1><p>这一步其实并不是必要的，但是我还是使用告诉比较器把输出波形整成好看一点的方波，这主要是因为我所用的10V转5V的电平转换电路上升沿非常慢，以至于方波几乎已经变成锯齿波了，非常难受。</p><p><img src="https://i.imgur.com/NrkVsnV.png" /></p><p>注意我最终电路中VIN是经过电容之后才送入比较器，这样隔离直流分量，比较器容易产生正确的结果。另外R1可以稍微取得大一些，比如500欧，对噪声的抑制能力也会强一些。这个比较器的输出为3.3V、0V，可以直接送入单片机的外部时钟输入引脚用来测量频率。</p><h1 id="总结">总结</h1><p>最后实现的效果如图（输入信号与输出信号稳定同频显示不漂移）只拍了N=1的情况，N=64也能非常稳</p><p><img src="https://i.imgur.com/PvEWWA3.jpg" /></p><p>这次与锁相环有关的电路基本都是我负责的，焊接在一大块洞洞板上，焊锡丝的助焊剂快熏死我了。。。不过好在最后的成品表现非常不错，最大能锁定到1.2MHz的频率，已经接近CD4046B的极限了。另外队友也买了一大堆CD4046B，过几天我想用这些多余的芯片测试一下锁相环的FM解调功能。</p>]]></content>
    
    
    <categories>
      
      <category>电子设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日語中的「くの字点」</title>
    <link href="/2024/10/30/%E6%97%A5%E8%AA%9E%E4%B8%AD%E7%9A%84%E3%80%8C%E3%81%8F%E3%81%AE%E5%AD%97%E7%82%B9%E3%80%8D/"/>
    <url>/2024/10/30/%E6%97%A5%E8%AA%9E%E4%B8%AD%E7%9A%84%E3%80%8C%E3%81%8F%E3%81%AE%E5%AD%97%E7%82%B9%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<style>p { font: 12pt Yu Mincho !important; }</style><p>最近在青空文庫上閲讀日語圖書的時候發現了這樣一段文字：</p><blockquote><p>表記について<br />このファイルは W3C 勧告 XHTML1.1 にそった形式で作成されています。<br />「くの字点」は「／＼」で表しました。</p></blockquote><p>即：此文件是根据W3C推荐的XHTML1.1格式制作的。'くの字点'用'／＼'表示。</p><p>「くの字点」是什麽？</p><p>我找到了這樣一篇解釋文章：<ahref="https://www.canon-its.co.jp/files/topics/2560_ext_06_0.pdf">https://www.canon-its.co.jp/files/topics/2560_ext_06_0.pdf</a></p><p>所謂'くの字点'，就是在重复两个字以上的假名，或漢字与假名時使用的標記符號。如果在重複時漢字的讀音變爲濁音，那麽くの字点也要相應地加上濁音符號。一個くの字点要占用兩個字節的位置。以下圖爲例：</p><p><img src="https://i.imgur.com/7NyGuQV.png" /></p><p>まあまあー＞まあ／＼ 大致，還算過得去<br />しかじかー＞しか／"＼　云云，等等<br />見る見るー＞見る／＼　眼看著，轉眼間<br />離れ離れー＞離れ／＼　失散</p><p>由於日語文章經常按照縱向排列，因此青空文庫就使用“／＼”來代替這個符號了。</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LTspice中SW元件的使用</title>
    <link href="/2024/10/14/LTspice%E4%B8%ADSW%E5%85%83%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/10/14/LTspice%E4%B8%ADSW%E5%85%83%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>LTspice不像Multisim那样有现成的手动开关。开关功能可以用<strong>S.Voltage Controlled Switch</strong>（压控开关）实现。</p><p><img src="https://i.imgur.com/1EAGN5i.png" /></p><ol type="1"><li>按P键打开元件库，搜索"SW"，放置在图纸中</li><li>插入指令定义SW元件的行为，例如：<code>.model MYSW SW(Ron=1 Roff=1Meg Vt=.5 Vh=-.4)</code>，其中<code>Ron</code>是导通电阻（<strong>导通电阻不能为0！</strong>），<code>Roff</code>为断开电阻，Vt和Vh决定了开关的阈值电压，在本例中为0.9V和0.1V</li><li>将开关模型的名称改成MYSW</li><li>放置一个电压源用来控制开关，这里用的是Pulse，开关在闭合1s后保持关断状态。</li></ol><p>SW相关的所有参数如下表格：</p><table><thead><tr><th style="text-align: center;">Name</th><th style="text-align: center;">Description</th><th style="text-align: center;">Units</th><th style="text-align: center;">default</th></tr></thead><tbody><tr><td style="text-align: center;">Vt</td><td style="text-align: center;">阈值电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Vh</td><td style="text-align: center;">滞后电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Ron</td><td style="text-align: center;">导通电阻</td><td style="text-align: center;">Ω</td><td style="text-align: center;">1.0</td></tr><tr><td style="text-align: center;">Roff</td><td style="text-align: center;">关断电阻</td><td style="text-align: center;">Ω</td><td style="text-align: center;">1/Gmin</td></tr><tr><td style="text-align: center;">Lser</td><td style="text-align: center;">串联电感</td><td style="text-align: center;">H</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Vser</td><td style="text-align: center;">串联电压</td><td style="text-align: center;">V</td><td style="text-align: center;">0.0</td></tr><tr><td style="text-align: center;">Ilimit</td><td style="text-align: center;">限制电流</td><td style="text-align: center;">A</td><td style="text-align: center;">Infin.</td></tr></tbody></table><p><strong>该开关根据滞回电压 Vh的值，具有三种不同的电压控制模式:</strong></p><ul><li>如果 Vh为零，开关将始终完全导通或关断，具体取决于输入电压是否超过阈值电压。</li><li>如果 Vh为正值，开关将表现出滞回现象，就像通过施密特触发器控制一样，触发点为 Vt- Vh 和 Vt + Vh。需要注意的是，Vh是触发点之间电压的一半，这与常见的实验室术语有所不同。</li><li>如果 Vh为负值，开关将在导通和关断阻抗之间平滑过渡。过渡发生在控制电压 Vt - Vh和 Vt + Vh 之间，且平滑过渡遵循开关导通行为的对数的低阶多项式拟合。</li></ul><p>平时设Vh为负值就好。</p><p>参考链接：<br /><ahref="https://www.analog.com/cn/resources/technical-articles/ltspiceiv-voltage-controlled-switches.html#:~:text=To%20insert%20and%20configure%20a%20switch%20in%20LTspice%E2%80%A6,this%20example%3A.model%20MYSW%20SW%20%28Ron%3D1%20Roff%3D1Meg%20Vt%3D.5%20Vh%3D-.4%29">LTspice:Voltage Controlled Switches</a></p>]]></content>
    
    
    <categories>
      
      <category>EE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为Fluid主题首页的副标题添加淡入效果</title>
    <link href="/2024/10/04/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E7%9A%84%E5%89%AF%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%B7%A1%E5%85%A5%E6%95%88%E6%9E%9C/"/>
    <url>/2024/10/04/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E7%9A%84%E5%89%AF%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%B7%A1%E5%85%A5%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近又折腾了一下博客的美化。默认Fluid主题的首页副标题用的是打字机特效，不过我不太喜欢，于是琢磨了一下淡入效果。我并没有学过前端，一下代码主要靠chatgpt和其他网友得到。</p><h1 id="过程">过程</h1><p>使用F12打开开发者模式，定位副标题：<br /><img src="https://i.imgur.com/mgjRfJ2.jpg" alt="Imgur" />目标对应的元素为<code>.h2 #subtitle</code>，在外部CSS文件中加入下列代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Si Yuan&quot;</span>;<br>    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;../fonts/Si Yuan.otf&quot;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;truetype&quot;</span>);<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">400</span>;<br>  &#125;<br><br><span class="hljs-selector-class">.h2</span> <span class="hljs-selector-id">#subtitle</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Si Yuan&#x27;</span>, sans-serif; <span class="hljs-comment">/* 替换为你想要的字体 */</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32px</span>; <span class="hljs-comment">/* 调整字体大小 */</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>; <span class="hljs-comment">/* 设置字体颜色 */</span><br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 初始透明度为0，隐藏 */</span><br>    <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">1.5s</span> linear; <span class="hljs-comment">/* 设置过渡效果 */</span><br>  &#125;<br><br><span class="hljs-selector-class">.h2</span> <span class="hljs-selector-id">#subtitle</span><span class="hljs-selector-class">.visible</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 完全可见 */</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>由于这里我使用的是思源宋体，并非系统自带的字体，因此额外使用<code>@font-face</code>引入外来字体。</p><p>另外，注意文章页的标题和首页的标题用的是同一个元素，二者会同时发生变更。</p><p>再向外部js文件中加入下列代码： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> subtitle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;subtitle&#x27;</span>);<br>    subtitle.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;visible&#x27;</span>); <span class="hljs-comment">// 页面加载后添加 visible 类</span><br>&#125;);<br></code></pre></td></tr></table></figure> 完成。</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>雪酷字幕组的特效注释字幕分析</title>
    <link href="/2024/10/02/%E9%9B%AA%E9%85%B7%E5%AD%97%E5%B9%95%E7%BB%84%E7%9A%84%E7%89%B9%E6%95%88%E6%B3%A8%E9%87%8A%E5%AD%97%E5%B9%95%E5%88%86%E6%9E%90/"/>
    <url>/2024/10/02/%E9%9B%AA%E9%85%B7%E5%AD%97%E5%B9%95%E7%BB%84%E7%9A%84%E7%89%B9%E6%95%88%E6%B3%A8%E9%87%8A%E5%AD%97%E5%B9%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>雪酷字幕组在2011至2012年期间与曙光字幕组合作完成了《命运石之门》的翻译工作，这也是我最早看的一个版本，翻译非常贴切自然，并且动漫中出现的流行词汇也都附上了详尽的注释。可惜在2014年之后雪酷字幕组就突然失踪了……这里我想分析一下他们在为《命运石之门》做字幕注释时用到的特效方案，从中窥视那个时代的字幕组对待字幕工作是何等敬业。</p><span id="more"></span><p>以繁体版第10集3:46处的注释为例，ass文件代码如下：</p><pre><code class="hljs">3:46.19~3:51.20     &#123;\move(15,20,15,10,0,200)\pos(15,10)\fad(300, 300)&#125;Blood Tune3:45.90~3:51.41   &#123;\fscx0\pos(15,20)\t(0,200,1,\fscx100)\t(5300,0,1,\fscx0)&#125;————3:46.19~3:51.20   &#123;\move(15,20,15,50,0,200)\pos(15,50)\fad(300, 300)&#125;（架空）ＴＶ動畫『BLOOD TUNE THE ANIMATION』。\N原作是漫畫，隨著多元媒體化的風潮終於在去年動畫化。\N作品被製作成為全２６話的作品，受到了動漫愛好者們的廣泛關注，\N特別是女主角『星來Orujeru』的PVC模型擁有相當高的人氣。</code></pre><p>上面一共用了三段字幕来完成对【BloodTune】的注释。而且，三段字幕分别使用了三种不同大小的字体（在1080p清晰度下）：</p><ol type="1"><li>neta1-微软雅黑，用于注释对象的名称，字号26，边框2，阴影0</li><li>neta2-微软雅黑，用于创造分界线，字号40，边框2，阴影0</li><li>neta3-微软雅黑，用于注释的具体内容，字号28，边框2，阴影0</li></ol><p>实现的效果如图 <imgsrc="https://media.giphy.com/media/EuIDh9scyssnZXBT39/giphy.gif" /></p><p>下面对这三段代码进行逐行分析。</p><h1 id="平滑的文本展示效果">平滑的文本展示效果</h1><p><code>\move</code>用于设置文本的<strong>移动轨迹</strong>，其基本语法是<code>\move(x1,y1,x2,y2,start_time,end_time)</code>，其中<code>(x1,y1)</code>是起始位置，<code>(x2,y2)</code>是结束位置，<code>start_time</code>和<code>end_time</code>定义动画的开始和结束时间（单位：毫秒）。</p><p><code>\pos</code>用于设置文本的<strong>绝对位置</strong>，其语法是(x,y)，其中 x 和 y是屏幕坐标。这个命令将文本固定在指定的位置，不随时间变化。</p><p><code>\fad</code>用于设置文本的<strong>淡入淡出</strong>效果，其基本语法是<code>\fad(fade_in_time, fade_out_time)</code>，其中<code>fade_in_time</code>是淡入持续的时间（毫秒），<code>fade_out_time</code>是淡出持续的时间（毫秒）。</p><p><code>&#123;\move(15,20,15,10,0,200)\pos(15,10)\fad(300, 300)&#125;Blood Tune</code>是一串复合代码，综合以上三点，其作用为：- 文本从屏幕坐标<code>(15, 20)</code>移动到<code>(15, 10)</code>，在 0毫秒时开始，200 毫秒时结束。 -文本运动到<code>(15,10)</code>后会被固定到这个位置。 -在文本开始移动的同时，会附加一个300毫秒的淡入效果，在文本消失时则有300毫秒的淡出效果。</p><h1 id="动态的分界线">动态的分界线</h1><p><code>\fscx</code>用于设置文本的<strong>水平缩放</strong>(<strong>f</strong>ront<strong>sc</strong>ale<strong>x</strong>)，其基本语法是<code>\fscx&lt;value&gt;</code>，其中<code>&lt;value&gt;</code>是缩放的百分比值。例如：</p><ul><li><code>\fscx100</code>表示正常大小</li><li><code>\fscx50</code>表示正常大小的一半</li></ul><p><code>\t</code>用于创建<strong>动画效果</strong>（transformation），从一个样式动画渐变到另外一个。Aegisub手册给出的语法如下：</p><pre><code class="hljs">\t(&lt;style modifiers&gt;)\t(&lt;accel&gt;,&lt;style modifiers&gt;)\t(&lt;t1&gt;,&lt;t2&gt;,&lt;style modifiers&gt;)\t(&lt;t1&gt;,&lt;t2&gt;,&lt;accel&gt;,&lt;style modifiers&gt;)</code></pre><p>本例使用的是第四个。其中<code>&lt;style modifiers&gt;</code>参数是特效标签，<code>accel</code>参数可以让动画效果不再是匀速的，而是满足一条指数曲线。该参数为1时，运动速度是恒定的。参数在0和1之间时，运动速度逐渐变慢。参数大于1时，运动速度越来越快。</p><p>整个代码的运行逻辑可以用下图概括：<br /><img src="https://i.imgur.com/r6Rsdn7.png" /></p>]]></content>
    
    
    <categories>
      
      <category>字幕</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid主题渲染LaTeX数学公式的问题总结</title>
    <link href="/2024/09/15/Hexo%20Fluid%E4%B8%BB%E9%A2%98%E6%B8%B2%E6%9F%93LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2024/09/15/Hexo%20Fluid%E4%B8%BB%E9%A2%98%E6%B8%B2%E6%9F%93LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>在Fluid的<ahref="https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">官方指南文档</a>中已经做了详尽的说明，一步一步跟着做就没问题。值得注意的是，在主题配置的代码</p><pre><code class="hljs">post:math:enable: truespecific: falseengine: mathjax</code></pre><p>中，要想使用数学公式，<code>enable</code>一项必须是<code>true</code>才行，否则会出现渲染错误，比如像下面这样：</p><p><imgsrc="https://github.com/banyee19/blog_images/blob/main/%E4%B8%8D%E5%90%AF%E7%94%A8.jpg?raw=true" /></p><p>同样的公式渲染了一次之后又重复了一次。</p><p>另外，Hexo中无法使用换行符<code>\\</code>，原因是<code>\</code>在Markdown属于特殊字符，用于字符转义，所以两个<code>\</code>经过Markdown引擎处理为html后，只剩下一个，等到LaTex渲染引擎处理时，实际上只看到一个<code>\</code>，渲染引擎把它当作LaTeX 中的空格。</p><p>在不改动现有代码的情况下，我的解决方法是直接改变公式的写法。比如下边这个公式</p><pre><code class="hljs">$$a_11=b_11 \\a_22=b_22+c_22$$</code></pre><p>改为</p><pre><code class="hljs">$$\begin&#123;aligned&#125;a_&#123;11&#125;&amp; =b_&#123;11&#125;\\a_&#123;22&#125;&amp; =b_&#123;22&#125;+c_&#123;22&#125;\end&#123;aligned&#125;$$</code></pre><p>渲染效果如下： <span class="math display">\[\begin{aligned}a_{11}&amp; =b_{11}\\a_{22}&amp; =b_{22}+c_{22}\end{aligned}\]</span> 更复杂的公式同理： <span class="math display">\[\begin{aligned}    F_x&#39;&amp;=\gamma\{q[\frac{-i\gamma}{c}(u_t&#39;+i\betau_x&#39;)E_x+u_y&#39;B_z-u_z&#39;B_y]    +i\beta\frac{iq}{c}[\gamma(u_x&#39;-i\betau_t&#39;)E_x+u_y&#39;E_y+u_z&#39;E_z] \}\\    &amp;=\frac{-iq\gamma^2}{c}(1-\beta^2)E_xu_t&#39;-q\gamma(B_y+\frac{\beta}{c}E_z)u_z&#39;+q\gamma(B_z-\frac{\beta}{c}E_y)u_y&#39;\end{aligned}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>序章-新博客的诞生</title>
    <link href="/2024/09/13/hello-world/"/>
    <url>/2024/09/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>新博客建成祝贺！ <span id="more"></span>经过两天的配置，，终于成功用Github把博客搭建出来了！</p><p>其实之前我一直是在博客园上面写博客的（虽然也才刚写了几个月），但是最近博客园的运营情况令人堪忧，可能再过几个月就要被收购了，嘛这样的话到时候博客园大概率要植入广告了，所以索性自己创建一个博客好了。另一方面，我写博客的目的是把自己的想法记录下来，或者分享自己的知识，所以博客园那种类似于论坛式的模式其实并不是很适合我。只要把博文发出来，我就达到目的了，就算没有人看也没关系。</p><p>不出意外的话这个博客应该会长期更新下去。毕竟是自己费了好大的功夫才建出来的嘛（笑）我在生活中并不喜欢和别人交流，周围能和我一起交流喜欢的事物的人几乎没有，但是我还是希望把自己思考的东西分享出来。那干脆就借助博客好了。以后这个博客上会发布各种我感兴趣的内容。</p><p>总之，我宣布，Banyee's Blog从今天开始正式成立了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>初次见面</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
